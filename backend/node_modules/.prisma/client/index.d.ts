
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "User"
  objects: {
    filiere: FilierePayload<ExtArgs> | null
    niveau: NiveauPayload<ExtArgs> | null
    documents: DocumentPayload<ExtArgs>[]
    deletedDocuments: DocumentPayload<ExtArgs>[]
    commentaires: CommentairePayload<ExtArgs>[]
    professeurMatieres: ProfesseurMatierePayload<ExtArgs>[]
    auditLogs: AuditLogPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive: boolean
    filiereId: string | null
    niveauId: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model User
 * 
 */
export type User = runtime.Types.DefaultSelection<UserPayload>
export type NiveauPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Niveau"
  objects: {
    filieres: FilierePayload<ExtArgs>[]
    semestres: SemestrePayload<ExtArgs>[]
    users: UserPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    nom: string
    type: NiveauType
    ordre: number
  }, ExtArgs["result"]["niveau"]>
  composites: {}
}

/**
 * Model Niveau
 * 
 */
export type Niveau = runtime.Types.DefaultSelection<NiveauPayload>
export type FilierePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Filiere"
  objects: {
    niveau: NiveauPayload<ExtArgs>
    matieres: MatierePayload<ExtArgs>[]
    users: UserPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    nom: string
    code: string
    niveauId: string
    isDeleted: boolean
    deletedAt: Date | null
    createdAt: Date
  }, ExtArgs["result"]["filiere"]>
  composites: {}
}

/**
 * Model Filiere
 * 
 */
export type Filiere = runtime.Types.DefaultSelection<FilierePayload>
export type SemestrePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Semestre"
  objects: {
    niveau: NiveauPayload<ExtArgs>
    matieres: MatierePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    nom: string
    niveauId: string
    ordre: number
  }, ExtArgs["result"]["semestre"]>
  composites: {}
}

/**
 * Model Semestre
 * 
 */
export type Semestre = runtime.Types.DefaultSelection<SemestrePayload>
export type MatierePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Matiere"
  objects: {
    filiere: FilierePayload<ExtArgs>
    semestre: SemestrePayload<ExtArgs>
    documents: DocumentPayload<ExtArgs>[]
    documentMatieres: DocumentMatierePayload<ExtArgs>[]
    professeurMatieres: ProfesseurMatierePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    nom: string
    code: string
    filiereId: string
    semestreId: string
    isDeleted: boolean
    deletedAt: Date | null
    createdAt: Date
  }, ExtArgs["result"]["matiere"]>
  composites: {}
}

/**
 * Model Matiere
 * 
 */
export type Matiere = runtime.Types.DefaultSelection<MatierePayload>
export type ProfesseurMatierePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ProfesseurMatiere"
  objects: {
    professeur: UserPayload<ExtArgs>
    matiere: MatierePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    professeurId: string
    matiereId: string
    role: ProfesseurRole
    createdAt: Date
  }, ExtArgs["result"]["professeurMatiere"]>
  composites: {}
}

/**
 * Model ProfesseurMatiere
 * 
 */
export type ProfesseurMatiere = runtime.Types.DefaultSelection<ProfesseurMatierePayload>
export type DocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Document"
  objects: {
    matiere: MatierePayload<ExtArgs> | null
    uploader: UserPayload<ExtArgs>
    deleter: UserPayload<ExtArgs> | null
    commentaires: CommentairePayload<ExtArgs>[]
    documentPFE: DocumentPFEPayload<ExtArgs> | null
    documentMatieres: DocumentMatierePayload<ExtArgs>[]
    correctionPour: DocumentPayload<ExtArgs> | null
    correction: DocumentPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    titre: string
    description: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint
    typeMime: string
    categorie: DocumentCategorie
    matiereId: string | null
    telchargePar: string
    correctionId: string | null
    downloadCount: number
    viewCount: number
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["document"]>
  composites: {}
}

/**
 * Model Document
 * 
 */
export type Document = runtime.Types.DefaultSelection<DocumentPayload>
export type DocumentPFEPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "DocumentPFE"
  objects: {
    document: DocumentPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    documentId: string
    anneeDiplome: number
    filiereDiplome: string
    titreProjet: string
    resume: string | null
    motsCles: string[]
    createdAt: Date
  }, ExtArgs["result"]["documentPFE"]>
  composites: {}
}

/**
 * Model DocumentPFE
 * 
 */
export type DocumentPFE = runtime.Types.DefaultSelection<DocumentPFEPayload>
export type CommentairePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Commentaire"
  objects: {
    document: DocumentPayload<ExtArgs>
    user: UserPayload<ExtArgs>
    parent: CommentairePayload<ExtArgs> | null
    replies: CommentairePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    contenu: string
    documentId: string
    userId: string
    parentId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    isEdited: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["commentaire"]>
  composites: {}
}

/**
 * Model Commentaire
 * 
 */
export type Commentaire = runtime.Types.DefaultSelection<CommentairePayload>
export type AuditLogPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "AuditLog"
  objects: {
    user: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string | null
    action: AuditAction
    resource: string | null
    resourceId: string | null
    details: Prisma.JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
  }, ExtArgs["result"]["auditLog"]>
  composites: {}
}

/**
 * Model AuditLog
 * 
 */
export type AuditLog = runtime.Types.DefaultSelection<AuditLogPayload>
export type DocumentMatierePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "DocumentMatiere"
  objects: {
    document: DocumentPayload<ExtArgs>
    matiere: MatierePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    documentId: string
    matiereId: string
    createdAt: Date
  }, ExtArgs["result"]["documentMatiere"]>
  composites: {}
}

/**
 * Model DocumentMatiere
 * 
 */
export type DocumentMatiere = runtime.Types.DefaultSelection<DocumentMatierePayload>

/**
 * Enums
 */

export const UserRole: {
  etudiant: 'etudiant',
  professeur: 'professeur',
  admin: 'admin'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const NiveauType: {
  licence: 'licence',
  master: 'master',
  ingenieur: 'ingenieur'
};

export type NiveauType = (typeof NiveauType)[keyof typeof NiveauType]


export const ProfesseurRole: {
  cours: 'cours',
  td: 'td',
  tp: 'tp'
};

export type ProfesseurRole = (typeof ProfesseurRole)[keyof typeof ProfesseurRole]


export const DocumentCategorie: {
  cours: 'cours',
  td: 'td',
  tp: 'tp',
  examen: 'examen',
  pfe: 'pfe'
};

export type DocumentCategorie = (typeof DocumentCategorie)[keyof typeof DocumentCategorie]


export const AuditAction: {
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  DOCUMENT_VIEW: 'DOCUMENT_VIEW',
  DOCUMENT_DOWNLOAD: 'DOCUMENT_DOWNLOAD',
  DOCUMENT_UPLOAD: 'DOCUMENT_UPLOAD',
  DOCUMENT_UPDATE: 'DOCUMENT_UPDATE',
  DOCUMENT_DELETE: 'DOCUMENT_DELETE',
  DOCUMENT_RESTORE: 'DOCUMENT_RESTORE',
  COMMENT_CREATE: 'COMMENT_CREATE',
  COMMENT_UPDATE: 'COMMENT_UPDATE',
  COMMENT_DELETE: 'COMMENT_DELETE',
  USER_CREATE: 'USER_CREATE',
  USER_UPDATE: 'USER_UPDATE',
  USER_DELETE: 'USER_DELETE',
  FILIERE_CREATE: 'FILIERE_CREATE',
  FILIERE_UPDATE: 'FILIERE_UPDATE',
  FILIERE_DELETE: 'FILIERE_DELETE',
  FILIERE_RESTORE: 'FILIERE_RESTORE',
  MATIERE_CREATE: 'MATIERE_CREATE',
  MATIERE_UPDATE: 'MATIERE_UPDATE',
  MATIERE_DELETE: 'MATIERE_DELETE',
  MATIERE_RESTORE: 'MATIERE_RESTORE',
  PAGE_ACCESS: 'PAGE_ACCESS',
  PROFILE_UPDATE: 'PROFILE_UPDATE',
  PASSWORD_CHANGE: 'PASSWORD_CHANGE',
  DASHBOARD_VIEW: 'DASHBOARD_VIEW'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.niveau`: Exposes CRUD operations for the **Niveau** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Niveaus
    * const niveaus = await prisma.niveau.findMany()
    * ```
    */
  get niveau(): Prisma.NiveauDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.filiere`: Exposes CRUD operations for the **Filiere** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Filieres
    * const filieres = await prisma.filiere.findMany()
    * ```
    */
  get filiere(): Prisma.FiliereDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.semestre`: Exposes CRUD operations for the **Semestre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Semestres
    * const semestres = await prisma.semestre.findMany()
    * ```
    */
  get semestre(): Prisma.SemestreDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.matiere`: Exposes CRUD operations for the **Matiere** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matieres
    * const matieres = await prisma.matiere.findMany()
    * ```
    */
  get matiere(): Prisma.MatiereDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.professeurMatiere`: Exposes CRUD operations for the **ProfesseurMatiere** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfesseurMatieres
    * const professeurMatieres = await prisma.professeurMatiere.findMany()
    * ```
    */
  get professeurMatiere(): Prisma.ProfesseurMatiereDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.documentPFE`: Exposes CRUD operations for the **DocumentPFE** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentPFES
    * const documentPFES = await prisma.documentPFE.findMany()
    * ```
    */
  get documentPFE(): Prisma.DocumentPFEDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.commentaire`: Exposes CRUD operations for the **Commentaire** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commentaires
    * const commentaires = await prisma.commentaire.findMany()
    * ```
    */
  get commentaire(): Prisma.CommentaireDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.documentMatiere`: Exposes CRUD operations for the **DocumentMatiere** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentMatieres
    * const documentMatieres = await prisma.documentMatiere.findMany()
    * ```
    */
  get documentMatiere(): Prisma.DocumentMatiereDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Niveau: 'Niveau',
    Filiere: 'Filiere',
    Semestre: 'Semestre',
    Matiere: 'Matiere',
    ProfesseurMatiere: 'ProfesseurMatiere',
    Document: 'Document',
    DocumentPFE: 'DocumentPFE',
    Commentaire: 'Commentaire',
    AuditLog: 'AuditLog',
    DocumentMatiere: 'DocumentMatiere'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'niveau' | 'filiere' | 'semestre' | 'matiere' | 'professeurMatiere' | 'document' | 'documentPFE' | 'commentaire' | 'auditLog' | 'documentMatiere'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: UserPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Niveau: {
        payload: NiveauPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.NiveauFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NiveauPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NiveauFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NiveauPayload>
          }
          findFirst: {
            args: Prisma.NiveauFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NiveauPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NiveauFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NiveauPayload>
          }
          findMany: {
            args: Prisma.NiveauFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NiveauPayload>[]
          }
          create: {
            args: Prisma.NiveauCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NiveauPayload>
          }
          createMany: {
            args: Prisma.NiveauCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NiveauDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NiveauPayload>
          }
          update: {
            args: Prisma.NiveauUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NiveauPayload>
          }
          deleteMany: {
            args: Prisma.NiveauDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NiveauUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NiveauUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<NiveauPayload>
          }
          aggregate: {
            args: Prisma.NiveauAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNiveau>
          }
          groupBy: {
            args: Prisma.NiveauGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NiveauGroupByOutputType>[]
          }
          count: {
            args: Prisma.NiveauCountArgs<ExtArgs>,
            result: $Utils.Optional<NiveauCountAggregateOutputType> | number
          }
        }
      }
      Filiere: {
        payload: FilierePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.FiliereFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FilierePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FiliereFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FilierePayload>
          }
          findFirst: {
            args: Prisma.FiliereFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FilierePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FiliereFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FilierePayload>
          }
          findMany: {
            args: Prisma.FiliereFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FilierePayload>[]
          }
          create: {
            args: Prisma.FiliereCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FilierePayload>
          }
          createMany: {
            args: Prisma.FiliereCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FiliereDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FilierePayload>
          }
          update: {
            args: Prisma.FiliereUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FilierePayload>
          }
          deleteMany: {
            args: Prisma.FiliereDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FiliereUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FiliereUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<FilierePayload>
          }
          aggregate: {
            args: Prisma.FiliereAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFiliere>
          }
          groupBy: {
            args: Prisma.FiliereGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FiliereGroupByOutputType>[]
          }
          count: {
            args: Prisma.FiliereCountArgs<ExtArgs>,
            result: $Utils.Optional<FiliereCountAggregateOutputType> | number
          }
        }
      }
      Semestre: {
        payload: SemestrePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.SemestreFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SemestrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SemestreFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SemestrePayload>
          }
          findFirst: {
            args: Prisma.SemestreFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SemestrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SemestreFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SemestrePayload>
          }
          findMany: {
            args: Prisma.SemestreFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SemestrePayload>[]
          }
          create: {
            args: Prisma.SemestreCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SemestrePayload>
          }
          createMany: {
            args: Prisma.SemestreCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SemestreDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SemestrePayload>
          }
          update: {
            args: Prisma.SemestreUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SemestrePayload>
          }
          deleteMany: {
            args: Prisma.SemestreDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SemestreUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SemestreUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SemestrePayload>
          }
          aggregate: {
            args: Prisma.SemestreAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSemestre>
          }
          groupBy: {
            args: Prisma.SemestreGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SemestreGroupByOutputType>[]
          }
          count: {
            args: Prisma.SemestreCountArgs<ExtArgs>,
            result: $Utils.Optional<SemestreCountAggregateOutputType> | number
          }
        }
      }
      Matiere: {
        payload: MatierePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.MatiereFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MatierePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatiereFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MatierePayload>
          }
          findFirst: {
            args: Prisma.MatiereFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MatierePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatiereFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MatierePayload>
          }
          findMany: {
            args: Prisma.MatiereFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MatierePayload>[]
          }
          create: {
            args: Prisma.MatiereCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MatierePayload>
          }
          createMany: {
            args: Prisma.MatiereCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MatiereDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MatierePayload>
          }
          update: {
            args: Prisma.MatiereUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MatierePayload>
          }
          deleteMany: {
            args: Prisma.MatiereDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MatiereUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MatiereUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MatierePayload>
          }
          aggregate: {
            args: Prisma.MatiereAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMatiere>
          }
          groupBy: {
            args: Prisma.MatiereGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MatiereGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatiereCountArgs<ExtArgs>,
            result: $Utils.Optional<MatiereCountAggregateOutputType> | number
          }
        }
      }
      ProfesseurMatiere: {
        payload: ProfesseurMatierePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ProfesseurMatiereFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProfesseurMatierePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfesseurMatiereFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProfesseurMatierePayload>
          }
          findFirst: {
            args: Prisma.ProfesseurMatiereFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProfesseurMatierePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfesseurMatiereFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProfesseurMatierePayload>
          }
          findMany: {
            args: Prisma.ProfesseurMatiereFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProfesseurMatierePayload>[]
          }
          create: {
            args: Prisma.ProfesseurMatiereCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProfesseurMatierePayload>
          }
          createMany: {
            args: Prisma.ProfesseurMatiereCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProfesseurMatiereDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProfesseurMatierePayload>
          }
          update: {
            args: Prisma.ProfesseurMatiereUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProfesseurMatierePayload>
          }
          deleteMany: {
            args: Prisma.ProfesseurMatiereDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProfesseurMatiereUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProfesseurMatiereUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ProfesseurMatierePayload>
          }
          aggregate: {
            args: Prisma.ProfesseurMatiereAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProfesseurMatiere>
          }
          groupBy: {
            args: Prisma.ProfesseurMatiereGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProfesseurMatiereGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfesseurMatiereCountArgs<ExtArgs>,
            result: $Utils.Optional<ProfesseurMatiereCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: DocumentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentPFE: {
        payload: DocumentPFEPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DocumentPFEFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPFEPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentPFEFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPFEPayload>
          }
          findFirst: {
            args: Prisma.DocumentPFEFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPFEPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentPFEFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPFEPayload>
          }
          findMany: {
            args: Prisma.DocumentPFEFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPFEPayload>[]
          }
          create: {
            args: Prisma.DocumentPFECreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPFEPayload>
          }
          createMany: {
            args: Prisma.DocumentPFECreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentPFEDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPFEPayload>
          }
          update: {
            args: Prisma.DocumentPFEUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPFEPayload>
          }
          deleteMany: {
            args: Prisma.DocumentPFEDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentPFEUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentPFEUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentPFEPayload>
          }
          aggregate: {
            args: Prisma.DocumentPFEAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocumentPFE>
          }
          groupBy: {
            args: Prisma.DocumentPFEGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentPFEGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentPFECountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentPFECountAggregateOutputType> | number
          }
        }
      }
      Commentaire: {
        payload: CommentairePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CommentaireFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentairePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentaireFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentairePayload>
          }
          findFirst: {
            args: Prisma.CommentaireFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentairePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentaireFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentairePayload>
          }
          findMany: {
            args: Prisma.CommentaireFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentairePayload>[]
          }
          create: {
            args: Prisma.CommentaireCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentairePayload>
          }
          createMany: {
            args: Prisma.CommentaireCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommentaireDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentairePayload>
          }
          update: {
            args: Prisma.CommentaireUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentairePayload>
          }
          deleteMany: {
            args: Prisma.CommentaireDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommentaireUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommentaireUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentairePayload>
          }
          aggregate: {
            args: Prisma.CommentaireAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCommentaire>
          }
          groupBy: {
            args: Prisma.CommentaireGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentaireGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentaireCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentaireCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: AuditLogPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>,
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      DocumentMatiere: {
        payload: DocumentMatierePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DocumentMatiereFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentMatierePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentMatiereFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentMatierePayload>
          }
          findFirst: {
            args: Prisma.DocumentMatiereFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentMatierePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentMatiereFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentMatierePayload>
          }
          findMany: {
            args: Prisma.DocumentMatiereFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentMatierePayload>[]
          }
          create: {
            args: Prisma.DocumentMatiereCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentMatierePayload>
          }
          createMany: {
            args: Prisma.DocumentMatiereCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentMatiereDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentMatierePayload>
          }
          update: {
            args: Prisma.DocumentMatiereUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentMatierePayload>
          }
          deleteMany: {
            args: Prisma.DocumentMatiereDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentMatiereUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentMatiereUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentMatierePayload>
          }
          aggregate: {
            args: Prisma.DocumentMatiereAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocumentMatiere>
          }
          groupBy: {
            args: Prisma.DocumentMatiereGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentMatiereGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentMatiereCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentMatiereCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    documents: number
    deletedDocuments: number
    commentaires: number
    professeurMatieres: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    deletedDocuments?: boolean | UserCountOutputTypeCountDeletedDocumentsArgs
    commentaires?: boolean | UserCountOutputTypeCountCommentairesArgs
    professeurMatieres?: boolean | UserCountOutputTypeCountProfesseurMatieresArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeletedDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentairesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentaireWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfesseurMatieresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProfesseurMatiereWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }



  /**
   * Count Type NiveauCountOutputType
   */


  export type NiveauCountOutputType = {
    filieres: number
    semestres: number
    users: number
  }

  export type NiveauCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    filieres?: boolean | NiveauCountOutputTypeCountFilieresArgs
    semestres?: boolean | NiveauCountOutputTypeCountSemestresArgs
    users?: boolean | NiveauCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes

  /**
   * NiveauCountOutputType without action
   */
  export type NiveauCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NiveauCountOutputType
     */
    select?: NiveauCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * NiveauCountOutputType without action
   */
  export type NiveauCountOutputTypeCountFilieresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FiliereWhereInput
  }


  /**
   * NiveauCountOutputType without action
   */
  export type NiveauCountOutputTypeCountSemestresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SemestreWhereInput
  }


  /**
   * NiveauCountOutputType without action
   */
  export type NiveauCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }



  /**
   * Count Type FiliereCountOutputType
   */


  export type FiliereCountOutputType = {
    matieres: number
    users: number
  }

  export type FiliereCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    matieres?: boolean | FiliereCountOutputTypeCountMatieresArgs
    users?: boolean | FiliereCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes

  /**
   * FiliereCountOutputType without action
   */
  export type FiliereCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiliereCountOutputType
     */
    select?: FiliereCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * FiliereCountOutputType without action
   */
  export type FiliereCountOutputTypeCountMatieresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MatiereWhereInput
  }


  /**
   * FiliereCountOutputType without action
   */
  export type FiliereCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }



  /**
   * Count Type SemestreCountOutputType
   */


  export type SemestreCountOutputType = {
    matieres: number
  }

  export type SemestreCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    matieres?: boolean | SemestreCountOutputTypeCountMatieresArgs
  }

  // Custom InputTypes

  /**
   * SemestreCountOutputType without action
   */
  export type SemestreCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemestreCountOutputType
     */
    select?: SemestreCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SemestreCountOutputType without action
   */
  export type SemestreCountOutputTypeCountMatieresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MatiereWhereInput
  }



  /**
   * Count Type MatiereCountOutputType
   */


  export type MatiereCountOutputType = {
    documents: number
    documentMatieres: number
    professeurMatieres: number
  }

  export type MatiereCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    documents?: boolean | MatiereCountOutputTypeCountDocumentsArgs
    documentMatieres?: boolean | MatiereCountOutputTypeCountDocumentMatieresArgs
    professeurMatieres?: boolean | MatiereCountOutputTypeCountProfesseurMatieresArgs
  }

  // Custom InputTypes

  /**
   * MatiereCountOutputType without action
   */
  export type MatiereCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatiereCountOutputType
     */
    select?: MatiereCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MatiereCountOutputType without action
   */
  export type MatiereCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * MatiereCountOutputType without action
   */
  export type MatiereCountOutputTypeCountDocumentMatieresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentMatiereWhereInput
  }


  /**
   * MatiereCountOutputType without action
   */
  export type MatiereCountOutputTypeCountProfesseurMatieresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProfesseurMatiereWhereInput
  }



  /**
   * Count Type DocumentCountOutputType
   */


  export type DocumentCountOutputType = {
    commentaires: number
    documentMatieres: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    commentaires?: boolean | DocumentCountOutputTypeCountCommentairesArgs
    documentMatieres?: boolean | DocumentCountOutputTypeCountDocumentMatieresArgs
  }

  // Custom InputTypes

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountCommentairesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentaireWhereInput
  }


  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountDocumentMatieresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentMatiereWhereInput
  }



  /**
   * Count Type CommentaireCountOutputType
   */


  export type CommentaireCountOutputType = {
    replies: number
  }

  export type CommentaireCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentaireCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes

  /**
   * CommentaireCountOutputType without action
   */
  export type CommentaireCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentaireCountOutputType
     */
    select?: CommentaireCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CommentaireCountOutputType without action
   */
  export type CommentaireCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentaireWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    prenom: string | null
    nom: string | null
    role: UserRole | null
    isActive: boolean | null
    filiereId: string | null
    niveauId: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    prenom: string | null
    nom: string | null
    role: UserRole | null
    isActive: boolean | null
    filiereId: string | null
    niveauId: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    prenom: number
    nom: number
    role: number
    isActive: number
    filiereId: number
    niveauId: number
    resetToken: number
    resetTokenExpiry: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    prenom?: true
    nom?: true
    role?: true
    isActive?: true
    filiereId?: true
    niveauId?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    prenom?: true
    nom?: true
    role?: true
    isActive?: true
    filiereId?: true
    niveauId?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    prenom?: true
    nom?: true
    role?: true
    isActive?: true
    filiereId?: true
    niveauId?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive: boolean
    filiereId: string | null
    niveauId: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    prenom?: boolean
    nom?: boolean
    role?: boolean
    isActive?: boolean
    filiereId?: boolean
    niveauId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    filiere?: boolean | FiliereArgs<ExtArgs>
    niveau?: boolean | NiveauArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    deletedDocuments?: boolean | User$deletedDocumentsArgs<ExtArgs>
    commentaires?: boolean | User$commentairesArgs<ExtArgs>
    professeurMatieres?: boolean | User$professeurMatieresArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    prenom?: boolean
    nom?: boolean
    role?: boolean
    isActive?: boolean
    filiereId?: boolean
    niveauId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    filiere?: boolean | FiliereArgs<ExtArgs>
    niveau?: boolean | NiveauArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    deletedDocuments?: boolean | User$deletedDocumentsArgs<ExtArgs>
    commentaires?: boolean | User$commentairesArgs<ExtArgs>
    professeurMatieres?: boolean | User$professeurMatieresArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type UserGetPayload<S extends boolean | null | undefined | UserArgs> = $Types.GetResult<UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    filiere<T extends FiliereArgs<ExtArgs> = {}>(args?: Subset<T, FiliereArgs<ExtArgs>>): Prisma__FiliereClient<$Types.GetResult<FilierePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    niveau<T extends NiveauArgs<ExtArgs> = {}>(args?: Subset<T, NiveauArgs<ExtArgs>>): Prisma__NiveauClient<$Types.GetResult<NiveauPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    deletedDocuments<T extends User$deletedDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$deletedDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    commentaires<T extends User$commentairesArgs<ExtArgs> = {}>(args?: Subset<T, User$commentairesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'findMany', never>| Null>;

    professeurMatieres<T extends User$professeurMatieresArgs<ExtArgs> = {}>(args?: Subset<T, User$professeurMatieresArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProfesseurMatierePayload<ExtArgs>, T, 'findMany', never>| Null>;

    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * User.deletedDocuments
   */
  export type User$deletedDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * User.commentaires
   */
  export type User$commentairesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    where?: CommentaireWhereInput
    orderBy?: Enumerable<CommentaireOrderByWithRelationInput>
    cursor?: CommentaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentaireScalarFieldEnum>
  }


  /**
   * User.professeurMatieres
   */
  export type User$professeurMatieresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesseurMatiere
     */
    select?: ProfesseurMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurMatiereInclude<ExtArgs> | null
    where?: ProfesseurMatiereWhereInput
    orderBy?: Enumerable<ProfesseurMatiereOrderByWithRelationInput>
    cursor?: ProfesseurMatiereWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProfesseurMatiereScalarFieldEnum>
  }


  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AuditLogScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Niveau
   */


  export type AggregateNiveau = {
    _count: NiveauCountAggregateOutputType | null
    _avg: NiveauAvgAggregateOutputType | null
    _sum: NiveauSumAggregateOutputType | null
    _min: NiveauMinAggregateOutputType | null
    _max: NiveauMaxAggregateOutputType | null
  }

  export type NiveauAvgAggregateOutputType = {
    ordre: number | null
  }

  export type NiveauSumAggregateOutputType = {
    ordre: number | null
  }

  export type NiveauMinAggregateOutputType = {
    id: string | null
    nom: string | null
    type: NiveauType | null
    ordre: number | null
  }

  export type NiveauMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    type: NiveauType | null
    ordre: number | null
  }

  export type NiveauCountAggregateOutputType = {
    id: number
    nom: number
    type: number
    ordre: number
    _all: number
  }


  export type NiveauAvgAggregateInputType = {
    ordre?: true
  }

  export type NiveauSumAggregateInputType = {
    ordre?: true
  }

  export type NiveauMinAggregateInputType = {
    id?: true
    nom?: true
    type?: true
    ordre?: true
  }

  export type NiveauMaxAggregateInputType = {
    id?: true
    nom?: true
    type?: true
    ordre?: true
  }

  export type NiveauCountAggregateInputType = {
    id?: true
    nom?: true
    type?: true
    ordre?: true
    _all?: true
  }

  export type NiveauAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Niveau to aggregate.
     */
    where?: NiveauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Niveaus to fetch.
     */
    orderBy?: Enumerable<NiveauOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NiveauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Niveaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Niveaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Niveaus
    **/
    _count?: true | NiveauCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NiveauAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NiveauSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NiveauMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NiveauMaxAggregateInputType
  }

  export type GetNiveauAggregateType<T extends NiveauAggregateArgs> = {
        [P in keyof T & keyof AggregateNiveau]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNiveau[P]>
      : GetScalarType<T[P], AggregateNiveau[P]>
  }




  export type NiveauGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NiveauWhereInput
    orderBy?: Enumerable<NiveauOrderByWithAggregationInput>
    by: NiveauScalarFieldEnum[]
    having?: NiveauScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NiveauCountAggregateInputType | true
    _avg?: NiveauAvgAggregateInputType
    _sum?: NiveauSumAggregateInputType
    _min?: NiveauMinAggregateInputType
    _max?: NiveauMaxAggregateInputType
  }


  export type NiveauGroupByOutputType = {
    id: string
    nom: string
    type: NiveauType
    ordre: number
    _count: NiveauCountAggregateOutputType | null
    _avg: NiveauAvgAggregateOutputType | null
    _sum: NiveauSumAggregateOutputType | null
    _min: NiveauMinAggregateOutputType | null
    _max: NiveauMaxAggregateOutputType | null
  }

  type GetNiveauGroupByPayload<T extends NiveauGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NiveauGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NiveauGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NiveauGroupByOutputType[P]>
            : GetScalarType<T[P], NiveauGroupByOutputType[P]>
        }
      >
    >


  export type NiveauSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    type?: boolean
    ordre?: boolean
    filieres?: boolean | Niveau$filieresArgs<ExtArgs>
    semestres?: boolean | Niveau$semestresArgs<ExtArgs>
    users?: boolean | Niveau$usersArgs<ExtArgs>
    _count?: boolean | NiveauCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["niveau"]>

  export type NiveauSelectScalar = {
    id?: boolean
    nom?: boolean
    type?: boolean
    ordre?: boolean
  }

  export type NiveauInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    filieres?: boolean | Niveau$filieresArgs<ExtArgs>
    semestres?: boolean | Niveau$semestresArgs<ExtArgs>
    users?: boolean | Niveau$usersArgs<ExtArgs>
    _count?: boolean | NiveauCountOutputTypeArgs<ExtArgs>
  }


  type NiveauGetPayload<S extends boolean | null | undefined | NiveauArgs> = $Types.GetResult<NiveauPayload, S>

  type NiveauCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<NiveauFindManyArgs, 'select' | 'include'> & {
      select?: NiveauCountAggregateInputType | true
    }

  export interface NiveauDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Niveau'], meta: { name: 'Niveau' } }
    /**
     * Find zero or one Niveau that matches the filter.
     * @param {NiveauFindUniqueArgs} args - Arguments to find a Niveau
     * @example
     * // Get one Niveau
     * const niveau = await prisma.niveau.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NiveauFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NiveauFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Niveau'> extends True ? Prisma__NiveauClient<$Types.GetResult<NiveauPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__NiveauClient<$Types.GetResult<NiveauPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Niveau that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NiveauFindUniqueOrThrowArgs} args - Arguments to find a Niveau
     * @example
     * // Get one Niveau
     * const niveau = await prisma.niveau.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NiveauFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NiveauFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NiveauClient<$Types.GetResult<NiveauPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Niveau that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NiveauFindFirstArgs} args - Arguments to find a Niveau
     * @example
     * // Get one Niveau
     * const niveau = await prisma.niveau.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NiveauFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NiveauFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Niveau'> extends True ? Prisma__NiveauClient<$Types.GetResult<NiveauPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__NiveauClient<$Types.GetResult<NiveauPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Niveau that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NiveauFindFirstOrThrowArgs} args - Arguments to find a Niveau
     * @example
     * // Get one Niveau
     * const niveau = await prisma.niveau.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NiveauFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NiveauFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NiveauClient<$Types.GetResult<NiveauPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Niveaus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NiveauFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Niveaus
     * const niveaus = await prisma.niveau.findMany()
     * 
     * // Get first 10 Niveaus
     * const niveaus = await prisma.niveau.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const niveauWithIdOnly = await prisma.niveau.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NiveauFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NiveauFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<NiveauPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Niveau.
     * @param {NiveauCreateArgs} args - Arguments to create a Niveau.
     * @example
     * // Create one Niveau
     * const Niveau = await prisma.niveau.create({
     *   data: {
     *     // ... data to create a Niveau
     *   }
     * })
     * 
    **/
    create<T extends NiveauCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NiveauCreateArgs<ExtArgs>>
    ): Prisma__NiveauClient<$Types.GetResult<NiveauPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Niveaus.
     *     @param {NiveauCreateManyArgs} args - Arguments to create many Niveaus.
     *     @example
     *     // Create many Niveaus
     *     const niveau = await prisma.niveau.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NiveauCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NiveauCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Niveau.
     * @param {NiveauDeleteArgs} args - Arguments to delete one Niveau.
     * @example
     * // Delete one Niveau
     * const Niveau = await prisma.niveau.delete({
     *   where: {
     *     // ... filter to delete one Niveau
     *   }
     * })
     * 
    **/
    delete<T extends NiveauDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NiveauDeleteArgs<ExtArgs>>
    ): Prisma__NiveauClient<$Types.GetResult<NiveauPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Niveau.
     * @param {NiveauUpdateArgs} args - Arguments to update one Niveau.
     * @example
     * // Update one Niveau
     * const niveau = await prisma.niveau.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NiveauUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NiveauUpdateArgs<ExtArgs>>
    ): Prisma__NiveauClient<$Types.GetResult<NiveauPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Niveaus.
     * @param {NiveauDeleteManyArgs} args - Arguments to filter Niveaus to delete.
     * @example
     * // Delete a few Niveaus
     * const { count } = await prisma.niveau.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NiveauDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NiveauDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Niveaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NiveauUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Niveaus
     * const niveau = await prisma.niveau.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NiveauUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NiveauUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Niveau.
     * @param {NiveauUpsertArgs} args - Arguments to update or create a Niveau.
     * @example
     * // Update or create a Niveau
     * const niveau = await prisma.niveau.upsert({
     *   create: {
     *     // ... data to create a Niveau
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Niveau we want to update
     *   }
     * })
    **/
    upsert<T extends NiveauUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NiveauUpsertArgs<ExtArgs>>
    ): Prisma__NiveauClient<$Types.GetResult<NiveauPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Niveaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NiveauCountArgs} args - Arguments to filter Niveaus to count.
     * @example
     * // Count the number of Niveaus
     * const count = await prisma.niveau.count({
     *   where: {
     *     // ... the filter for the Niveaus we want to count
     *   }
     * })
    **/
    count<T extends NiveauCountArgs>(
      args?: Subset<T, NiveauCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NiveauCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Niveau.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NiveauAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NiveauAggregateArgs>(args: Subset<T, NiveauAggregateArgs>): Prisma.PrismaPromise<GetNiveauAggregateType<T>>

    /**
     * Group by Niveau.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NiveauGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NiveauGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NiveauGroupByArgs['orderBy'] }
        : { orderBy?: NiveauGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NiveauGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNiveauGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Niveau.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NiveauClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    filieres<T extends Niveau$filieresArgs<ExtArgs> = {}>(args?: Subset<T, Niveau$filieresArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<FilierePayload<ExtArgs>, T, 'findMany', never>| Null>;

    semestres<T extends Niveau$semestresArgs<ExtArgs> = {}>(args?: Subset<T, Niveau$semestresArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SemestrePayload<ExtArgs>, T, 'findMany', never>| Null>;

    users<T extends Niveau$usersArgs<ExtArgs> = {}>(args?: Subset<T, Niveau$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Niveau base type for findUnique actions
   */
  export type NiveauFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * Filter, which Niveau to fetch.
     */
    where: NiveauWhereUniqueInput
  }

  /**
   * Niveau findUnique
   */
  export interface NiveauFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NiveauFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Niveau findUniqueOrThrow
   */
  export type NiveauFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * Filter, which Niveau to fetch.
     */
    where: NiveauWhereUniqueInput
  }


  /**
   * Niveau base type for findFirst actions
   */
  export type NiveauFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * Filter, which Niveau to fetch.
     */
    where?: NiveauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Niveaus to fetch.
     */
    orderBy?: Enumerable<NiveauOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Niveaus.
     */
    cursor?: NiveauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Niveaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Niveaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Niveaus.
     */
    distinct?: Enumerable<NiveauScalarFieldEnum>
  }

  /**
   * Niveau findFirst
   */
  export interface NiveauFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NiveauFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Niveau findFirstOrThrow
   */
  export type NiveauFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * Filter, which Niveau to fetch.
     */
    where?: NiveauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Niveaus to fetch.
     */
    orderBy?: Enumerable<NiveauOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Niveaus.
     */
    cursor?: NiveauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Niveaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Niveaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Niveaus.
     */
    distinct?: Enumerable<NiveauScalarFieldEnum>
  }


  /**
   * Niveau findMany
   */
  export type NiveauFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * Filter, which Niveaus to fetch.
     */
    where?: NiveauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Niveaus to fetch.
     */
    orderBy?: Enumerable<NiveauOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Niveaus.
     */
    cursor?: NiveauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Niveaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Niveaus.
     */
    skip?: number
    distinct?: Enumerable<NiveauScalarFieldEnum>
  }


  /**
   * Niveau create
   */
  export type NiveauCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * The data needed to create a Niveau.
     */
    data: XOR<NiveauCreateInput, NiveauUncheckedCreateInput>
  }


  /**
   * Niveau createMany
   */
  export type NiveauCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Niveaus.
     */
    data: Enumerable<NiveauCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Niveau update
   */
  export type NiveauUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * The data needed to update a Niveau.
     */
    data: XOR<NiveauUpdateInput, NiveauUncheckedUpdateInput>
    /**
     * Choose, which Niveau to update.
     */
    where: NiveauWhereUniqueInput
  }


  /**
   * Niveau updateMany
   */
  export type NiveauUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Niveaus.
     */
    data: XOR<NiveauUpdateManyMutationInput, NiveauUncheckedUpdateManyInput>
    /**
     * Filter which Niveaus to update
     */
    where?: NiveauWhereInput
  }


  /**
   * Niveau upsert
   */
  export type NiveauUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * The filter to search for the Niveau to update in case it exists.
     */
    where: NiveauWhereUniqueInput
    /**
     * In case the Niveau found by the `where` argument doesn't exist, create a new Niveau with this data.
     */
    create: XOR<NiveauCreateInput, NiveauUncheckedCreateInput>
    /**
     * In case the Niveau was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NiveauUpdateInput, NiveauUncheckedUpdateInput>
  }


  /**
   * Niveau delete
   */
  export type NiveauDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
    /**
     * Filter which Niveau to delete.
     */
    where: NiveauWhereUniqueInput
  }


  /**
   * Niveau deleteMany
   */
  export type NiveauDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Niveaus to delete
     */
    where?: NiveauWhereInput
  }


  /**
   * Niveau.filieres
   */
  export type Niveau$filieresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filiere
     */
    select?: FiliereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiliereInclude<ExtArgs> | null
    where?: FiliereWhereInput
    orderBy?: Enumerable<FiliereOrderByWithRelationInput>
    cursor?: FiliereWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FiliereScalarFieldEnum>
  }


  /**
   * Niveau.semestres
   */
  export type Niveau$semestresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    where?: SemestreWhereInput
    orderBy?: Enumerable<SemestreOrderByWithRelationInput>
    cursor?: SemestreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SemestreScalarFieldEnum>
  }


  /**
   * Niveau.users
   */
  export type Niveau$usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Niveau without action
   */
  export type NiveauArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveau
     */
    select?: NiveauSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NiveauInclude<ExtArgs> | null
  }



  /**
   * Model Filiere
   */


  export type AggregateFiliere = {
    _count: FiliereCountAggregateOutputType | null
    _min: FiliereMinAggregateOutputType | null
    _max: FiliereMaxAggregateOutputType | null
  }

  export type FiliereMinAggregateOutputType = {
    id: string | null
    nom: string | null
    code: string | null
    niveauId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type FiliereMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    code: string | null
    niveauId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type FiliereCountAggregateOutputType = {
    id: number
    nom: number
    code: number
    niveauId: number
    isDeleted: number
    deletedAt: number
    createdAt: number
    _all: number
  }


  export type FiliereMinAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    niveauId?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
  }

  export type FiliereMaxAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    niveauId?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
  }

  export type FiliereCountAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    niveauId?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    _all?: true
  }

  export type FiliereAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Filiere to aggregate.
     */
    where?: FiliereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filieres to fetch.
     */
    orderBy?: Enumerable<FiliereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FiliereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Filieres
    **/
    _count?: true | FiliereCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FiliereMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FiliereMaxAggregateInputType
  }

  export type GetFiliereAggregateType<T extends FiliereAggregateArgs> = {
        [P in keyof T & keyof AggregateFiliere]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiliere[P]>
      : GetScalarType<T[P], AggregateFiliere[P]>
  }




  export type FiliereGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FiliereWhereInput
    orderBy?: Enumerable<FiliereOrderByWithAggregationInput>
    by: FiliereScalarFieldEnum[]
    having?: FiliereScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FiliereCountAggregateInputType | true
    _min?: FiliereMinAggregateInputType
    _max?: FiliereMaxAggregateInputType
  }


  export type FiliereGroupByOutputType = {
    id: string
    nom: string
    code: string
    niveauId: string
    isDeleted: boolean
    deletedAt: Date | null
    createdAt: Date
    _count: FiliereCountAggregateOutputType | null
    _min: FiliereMinAggregateOutputType | null
    _max: FiliereMaxAggregateOutputType | null
  }

  type GetFiliereGroupByPayload<T extends FiliereGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FiliereGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FiliereGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FiliereGroupByOutputType[P]>
            : GetScalarType<T[P], FiliereGroupByOutputType[P]>
        }
      >
    >


  export type FiliereSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code?: boolean
    niveauId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    niveau?: boolean | NiveauArgs<ExtArgs>
    matieres?: boolean | Filiere$matieresArgs<ExtArgs>
    users?: boolean | Filiere$usersArgs<ExtArgs>
    _count?: boolean | FiliereCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["filiere"]>

  export type FiliereSelectScalar = {
    id?: boolean
    nom?: boolean
    code?: boolean
    niveauId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
  }

  export type FiliereInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    niveau?: boolean | NiveauArgs<ExtArgs>
    matieres?: boolean | Filiere$matieresArgs<ExtArgs>
    users?: boolean | Filiere$usersArgs<ExtArgs>
    _count?: boolean | FiliereCountOutputTypeArgs<ExtArgs>
  }


  type FiliereGetPayload<S extends boolean | null | undefined | FiliereArgs> = $Types.GetResult<FilierePayload, S>

  type FiliereCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<FiliereFindManyArgs, 'select' | 'include'> & {
      select?: FiliereCountAggregateInputType | true
    }

  export interface FiliereDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Filiere'], meta: { name: 'Filiere' } }
    /**
     * Find zero or one Filiere that matches the filter.
     * @param {FiliereFindUniqueArgs} args - Arguments to find a Filiere
     * @example
     * // Get one Filiere
     * const filiere = await prisma.filiere.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FiliereFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FiliereFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Filiere'> extends True ? Prisma__FiliereClient<$Types.GetResult<FilierePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__FiliereClient<$Types.GetResult<FilierePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Filiere that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FiliereFindUniqueOrThrowArgs} args - Arguments to find a Filiere
     * @example
     * // Get one Filiere
     * const filiere = await prisma.filiere.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FiliereFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FiliereFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FiliereClient<$Types.GetResult<FilierePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Filiere that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiliereFindFirstArgs} args - Arguments to find a Filiere
     * @example
     * // Get one Filiere
     * const filiere = await prisma.filiere.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FiliereFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FiliereFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Filiere'> extends True ? Prisma__FiliereClient<$Types.GetResult<FilierePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__FiliereClient<$Types.GetResult<FilierePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Filiere that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiliereFindFirstOrThrowArgs} args - Arguments to find a Filiere
     * @example
     * // Get one Filiere
     * const filiere = await prisma.filiere.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FiliereFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FiliereFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FiliereClient<$Types.GetResult<FilierePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Filieres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiliereFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Filieres
     * const filieres = await prisma.filiere.findMany()
     * 
     * // Get first 10 Filieres
     * const filieres = await prisma.filiere.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filiereWithIdOnly = await prisma.filiere.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FiliereFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FiliereFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<FilierePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Filiere.
     * @param {FiliereCreateArgs} args - Arguments to create a Filiere.
     * @example
     * // Create one Filiere
     * const Filiere = await prisma.filiere.create({
     *   data: {
     *     // ... data to create a Filiere
     *   }
     * })
     * 
    **/
    create<T extends FiliereCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FiliereCreateArgs<ExtArgs>>
    ): Prisma__FiliereClient<$Types.GetResult<FilierePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Filieres.
     *     @param {FiliereCreateManyArgs} args - Arguments to create many Filieres.
     *     @example
     *     // Create many Filieres
     *     const filiere = await prisma.filiere.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FiliereCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FiliereCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Filiere.
     * @param {FiliereDeleteArgs} args - Arguments to delete one Filiere.
     * @example
     * // Delete one Filiere
     * const Filiere = await prisma.filiere.delete({
     *   where: {
     *     // ... filter to delete one Filiere
     *   }
     * })
     * 
    **/
    delete<T extends FiliereDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FiliereDeleteArgs<ExtArgs>>
    ): Prisma__FiliereClient<$Types.GetResult<FilierePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Filiere.
     * @param {FiliereUpdateArgs} args - Arguments to update one Filiere.
     * @example
     * // Update one Filiere
     * const filiere = await prisma.filiere.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FiliereUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FiliereUpdateArgs<ExtArgs>>
    ): Prisma__FiliereClient<$Types.GetResult<FilierePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Filieres.
     * @param {FiliereDeleteManyArgs} args - Arguments to filter Filieres to delete.
     * @example
     * // Delete a few Filieres
     * const { count } = await prisma.filiere.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FiliereDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FiliereDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Filieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiliereUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Filieres
     * const filiere = await prisma.filiere.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FiliereUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FiliereUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Filiere.
     * @param {FiliereUpsertArgs} args - Arguments to update or create a Filiere.
     * @example
     * // Update or create a Filiere
     * const filiere = await prisma.filiere.upsert({
     *   create: {
     *     // ... data to create a Filiere
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Filiere we want to update
     *   }
     * })
    **/
    upsert<T extends FiliereUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FiliereUpsertArgs<ExtArgs>>
    ): Prisma__FiliereClient<$Types.GetResult<FilierePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Filieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiliereCountArgs} args - Arguments to filter Filieres to count.
     * @example
     * // Count the number of Filieres
     * const count = await prisma.filiere.count({
     *   where: {
     *     // ... the filter for the Filieres we want to count
     *   }
     * })
    **/
    count<T extends FiliereCountArgs>(
      args?: Subset<T, FiliereCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FiliereCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Filiere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiliereAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FiliereAggregateArgs>(args: Subset<T, FiliereAggregateArgs>): Prisma.PrismaPromise<GetFiliereAggregateType<T>>

    /**
     * Group by Filiere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiliereGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FiliereGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FiliereGroupByArgs['orderBy'] }
        : { orderBy?: FiliereGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FiliereGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFiliereGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Filiere.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FiliereClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    niveau<T extends NiveauArgs<ExtArgs> = {}>(args?: Subset<T, NiveauArgs<ExtArgs>>): Prisma__NiveauClient<$Types.GetResult<NiveauPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    matieres<T extends Filiere$matieresArgs<ExtArgs> = {}>(args?: Subset<T, Filiere$matieresArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MatierePayload<ExtArgs>, T, 'findMany', never>| Null>;

    users<T extends Filiere$usersArgs<ExtArgs> = {}>(args?: Subset<T, Filiere$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Filiere base type for findUnique actions
   */
  export type FiliereFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filiere
     */
    select?: FiliereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiliereInclude<ExtArgs> | null
    /**
     * Filter, which Filiere to fetch.
     */
    where: FiliereWhereUniqueInput
  }

  /**
   * Filiere findUnique
   */
  export interface FiliereFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends FiliereFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Filiere findUniqueOrThrow
   */
  export type FiliereFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filiere
     */
    select?: FiliereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiliereInclude<ExtArgs> | null
    /**
     * Filter, which Filiere to fetch.
     */
    where: FiliereWhereUniqueInput
  }


  /**
   * Filiere base type for findFirst actions
   */
  export type FiliereFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filiere
     */
    select?: FiliereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiliereInclude<ExtArgs> | null
    /**
     * Filter, which Filiere to fetch.
     */
    where?: FiliereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filieres to fetch.
     */
    orderBy?: Enumerable<FiliereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Filieres.
     */
    cursor?: FiliereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Filieres.
     */
    distinct?: Enumerable<FiliereScalarFieldEnum>
  }

  /**
   * Filiere findFirst
   */
  export interface FiliereFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends FiliereFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Filiere findFirstOrThrow
   */
  export type FiliereFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filiere
     */
    select?: FiliereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiliereInclude<ExtArgs> | null
    /**
     * Filter, which Filiere to fetch.
     */
    where?: FiliereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filieres to fetch.
     */
    orderBy?: Enumerable<FiliereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Filieres.
     */
    cursor?: FiliereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Filieres.
     */
    distinct?: Enumerable<FiliereScalarFieldEnum>
  }


  /**
   * Filiere findMany
   */
  export type FiliereFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filiere
     */
    select?: FiliereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiliereInclude<ExtArgs> | null
    /**
     * Filter, which Filieres to fetch.
     */
    where?: FiliereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filieres to fetch.
     */
    orderBy?: Enumerable<FiliereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Filieres.
     */
    cursor?: FiliereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filieres.
     */
    skip?: number
    distinct?: Enumerable<FiliereScalarFieldEnum>
  }


  /**
   * Filiere create
   */
  export type FiliereCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filiere
     */
    select?: FiliereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiliereInclude<ExtArgs> | null
    /**
     * The data needed to create a Filiere.
     */
    data: XOR<FiliereCreateInput, FiliereUncheckedCreateInput>
  }


  /**
   * Filiere createMany
   */
  export type FiliereCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Filieres.
     */
    data: Enumerable<FiliereCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Filiere update
   */
  export type FiliereUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filiere
     */
    select?: FiliereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiliereInclude<ExtArgs> | null
    /**
     * The data needed to update a Filiere.
     */
    data: XOR<FiliereUpdateInput, FiliereUncheckedUpdateInput>
    /**
     * Choose, which Filiere to update.
     */
    where: FiliereWhereUniqueInput
  }


  /**
   * Filiere updateMany
   */
  export type FiliereUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Filieres.
     */
    data: XOR<FiliereUpdateManyMutationInput, FiliereUncheckedUpdateManyInput>
    /**
     * Filter which Filieres to update
     */
    where?: FiliereWhereInput
  }


  /**
   * Filiere upsert
   */
  export type FiliereUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filiere
     */
    select?: FiliereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiliereInclude<ExtArgs> | null
    /**
     * The filter to search for the Filiere to update in case it exists.
     */
    where: FiliereWhereUniqueInput
    /**
     * In case the Filiere found by the `where` argument doesn't exist, create a new Filiere with this data.
     */
    create: XOR<FiliereCreateInput, FiliereUncheckedCreateInput>
    /**
     * In case the Filiere was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FiliereUpdateInput, FiliereUncheckedUpdateInput>
  }


  /**
   * Filiere delete
   */
  export type FiliereDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filiere
     */
    select?: FiliereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiliereInclude<ExtArgs> | null
    /**
     * Filter which Filiere to delete.
     */
    where: FiliereWhereUniqueInput
  }


  /**
   * Filiere deleteMany
   */
  export type FiliereDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Filieres to delete
     */
    where?: FiliereWhereInput
  }


  /**
   * Filiere.matieres
   */
  export type Filiere$matieresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    where?: MatiereWhereInput
    orderBy?: Enumerable<MatiereOrderByWithRelationInput>
    cursor?: MatiereWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MatiereScalarFieldEnum>
  }


  /**
   * Filiere.users
   */
  export type Filiere$usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Filiere without action
   */
  export type FiliereArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filiere
     */
    select?: FiliereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FiliereInclude<ExtArgs> | null
  }



  /**
   * Model Semestre
   */


  export type AggregateSemestre = {
    _count: SemestreCountAggregateOutputType | null
    _avg: SemestreAvgAggregateOutputType | null
    _sum: SemestreSumAggregateOutputType | null
    _min: SemestreMinAggregateOutputType | null
    _max: SemestreMaxAggregateOutputType | null
  }

  export type SemestreAvgAggregateOutputType = {
    ordre: number | null
  }

  export type SemestreSumAggregateOutputType = {
    ordre: number | null
  }

  export type SemestreMinAggregateOutputType = {
    id: string | null
    nom: string | null
    niveauId: string | null
    ordre: number | null
  }

  export type SemestreMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    niveauId: string | null
    ordre: number | null
  }

  export type SemestreCountAggregateOutputType = {
    id: number
    nom: number
    niveauId: number
    ordre: number
    _all: number
  }


  export type SemestreAvgAggregateInputType = {
    ordre?: true
  }

  export type SemestreSumAggregateInputType = {
    ordre?: true
  }

  export type SemestreMinAggregateInputType = {
    id?: true
    nom?: true
    niveauId?: true
    ordre?: true
  }

  export type SemestreMaxAggregateInputType = {
    id?: true
    nom?: true
    niveauId?: true
    ordre?: true
  }

  export type SemestreCountAggregateInputType = {
    id?: true
    nom?: true
    niveauId?: true
    ordre?: true
    _all?: true
  }

  export type SemestreAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Semestre to aggregate.
     */
    where?: SemestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semestres to fetch.
     */
    orderBy?: Enumerable<SemestreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SemestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semestres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Semestres
    **/
    _count?: true | SemestreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SemestreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SemestreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SemestreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SemestreMaxAggregateInputType
  }

  export type GetSemestreAggregateType<T extends SemestreAggregateArgs> = {
        [P in keyof T & keyof AggregateSemestre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSemestre[P]>
      : GetScalarType<T[P], AggregateSemestre[P]>
  }




  export type SemestreGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SemestreWhereInput
    orderBy?: Enumerable<SemestreOrderByWithAggregationInput>
    by: SemestreScalarFieldEnum[]
    having?: SemestreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SemestreCountAggregateInputType | true
    _avg?: SemestreAvgAggregateInputType
    _sum?: SemestreSumAggregateInputType
    _min?: SemestreMinAggregateInputType
    _max?: SemestreMaxAggregateInputType
  }


  export type SemestreGroupByOutputType = {
    id: string
    nom: string
    niveauId: string
    ordre: number
    _count: SemestreCountAggregateOutputType | null
    _avg: SemestreAvgAggregateOutputType | null
    _sum: SemestreSumAggregateOutputType | null
    _min: SemestreMinAggregateOutputType | null
    _max: SemestreMaxAggregateOutputType | null
  }

  type GetSemestreGroupByPayload<T extends SemestreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SemestreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SemestreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SemestreGroupByOutputType[P]>
            : GetScalarType<T[P], SemestreGroupByOutputType[P]>
        }
      >
    >


  export type SemestreSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    niveauId?: boolean
    ordre?: boolean
    niveau?: boolean | NiveauArgs<ExtArgs>
    matieres?: boolean | Semestre$matieresArgs<ExtArgs>
    _count?: boolean | SemestreCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["semestre"]>

  export type SemestreSelectScalar = {
    id?: boolean
    nom?: boolean
    niveauId?: boolean
    ordre?: boolean
  }

  export type SemestreInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    niveau?: boolean | NiveauArgs<ExtArgs>
    matieres?: boolean | Semestre$matieresArgs<ExtArgs>
    _count?: boolean | SemestreCountOutputTypeArgs<ExtArgs>
  }


  type SemestreGetPayload<S extends boolean | null | undefined | SemestreArgs> = $Types.GetResult<SemestrePayload, S>

  type SemestreCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SemestreFindManyArgs, 'select' | 'include'> & {
      select?: SemestreCountAggregateInputType | true
    }

  export interface SemestreDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Semestre'], meta: { name: 'Semestre' } }
    /**
     * Find zero or one Semestre that matches the filter.
     * @param {SemestreFindUniqueArgs} args - Arguments to find a Semestre
     * @example
     * // Get one Semestre
     * const semestre = await prisma.semestre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SemestreFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SemestreFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Semestre'> extends True ? Prisma__SemestreClient<$Types.GetResult<SemestrePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SemestreClient<$Types.GetResult<SemestrePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Semestre that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SemestreFindUniqueOrThrowArgs} args - Arguments to find a Semestre
     * @example
     * // Get one Semestre
     * const semestre = await prisma.semestre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SemestreFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SemestreFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SemestreClient<$Types.GetResult<SemestrePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Semestre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestreFindFirstArgs} args - Arguments to find a Semestre
     * @example
     * // Get one Semestre
     * const semestre = await prisma.semestre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SemestreFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SemestreFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Semestre'> extends True ? Prisma__SemestreClient<$Types.GetResult<SemestrePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SemestreClient<$Types.GetResult<SemestrePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Semestre that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestreFindFirstOrThrowArgs} args - Arguments to find a Semestre
     * @example
     * // Get one Semestre
     * const semestre = await prisma.semestre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SemestreFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SemestreFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SemestreClient<$Types.GetResult<SemestrePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Semestres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestreFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Semestres
     * const semestres = await prisma.semestre.findMany()
     * 
     * // Get first 10 Semestres
     * const semestres = await prisma.semestre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const semestreWithIdOnly = await prisma.semestre.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SemestreFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemestreFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SemestrePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Semestre.
     * @param {SemestreCreateArgs} args - Arguments to create a Semestre.
     * @example
     * // Create one Semestre
     * const Semestre = await prisma.semestre.create({
     *   data: {
     *     // ... data to create a Semestre
     *   }
     * })
     * 
    **/
    create<T extends SemestreCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SemestreCreateArgs<ExtArgs>>
    ): Prisma__SemestreClient<$Types.GetResult<SemestrePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Semestres.
     *     @param {SemestreCreateManyArgs} args - Arguments to create many Semestres.
     *     @example
     *     // Create many Semestres
     *     const semestre = await prisma.semestre.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SemestreCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemestreCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Semestre.
     * @param {SemestreDeleteArgs} args - Arguments to delete one Semestre.
     * @example
     * // Delete one Semestre
     * const Semestre = await prisma.semestre.delete({
     *   where: {
     *     // ... filter to delete one Semestre
     *   }
     * })
     * 
    **/
    delete<T extends SemestreDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SemestreDeleteArgs<ExtArgs>>
    ): Prisma__SemestreClient<$Types.GetResult<SemestrePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Semestre.
     * @param {SemestreUpdateArgs} args - Arguments to update one Semestre.
     * @example
     * // Update one Semestre
     * const semestre = await prisma.semestre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SemestreUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SemestreUpdateArgs<ExtArgs>>
    ): Prisma__SemestreClient<$Types.GetResult<SemestrePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Semestres.
     * @param {SemestreDeleteManyArgs} args - Arguments to filter Semestres to delete.
     * @example
     * // Delete a few Semestres
     * const { count } = await prisma.semestre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SemestreDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemestreDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Semestres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Semestres
     * const semestre = await prisma.semestre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SemestreUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SemestreUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Semestre.
     * @param {SemestreUpsertArgs} args - Arguments to update or create a Semestre.
     * @example
     * // Update or create a Semestre
     * const semestre = await prisma.semestre.upsert({
     *   create: {
     *     // ... data to create a Semestre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Semestre we want to update
     *   }
     * })
    **/
    upsert<T extends SemestreUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SemestreUpsertArgs<ExtArgs>>
    ): Prisma__SemestreClient<$Types.GetResult<SemestrePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Semestres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestreCountArgs} args - Arguments to filter Semestres to count.
     * @example
     * // Count the number of Semestres
     * const count = await prisma.semestre.count({
     *   where: {
     *     // ... the filter for the Semestres we want to count
     *   }
     * })
    **/
    count<T extends SemestreCountArgs>(
      args?: Subset<T, SemestreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SemestreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Semestre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SemestreAggregateArgs>(args: Subset<T, SemestreAggregateArgs>): Prisma.PrismaPromise<GetSemestreAggregateType<T>>

    /**
     * Group by Semestre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemestreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SemestreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SemestreGroupByArgs['orderBy'] }
        : { orderBy?: SemestreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SemestreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSemestreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Semestre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SemestreClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    niveau<T extends NiveauArgs<ExtArgs> = {}>(args?: Subset<T, NiveauArgs<ExtArgs>>): Prisma__NiveauClient<$Types.GetResult<NiveauPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    matieres<T extends Semestre$matieresArgs<ExtArgs> = {}>(args?: Subset<T, Semestre$matieresArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MatierePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Semestre base type for findUnique actions
   */
  export type SemestreFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * Filter, which Semestre to fetch.
     */
    where: SemestreWhereUniqueInput
  }

  /**
   * Semestre findUnique
   */
  export interface SemestreFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SemestreFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Semestre findUniqueOrThrow
   */
  export type SemestreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * Filter, which Semestre to fetch.
     */
    where: SemestreWhereUniqueInput
  }


  /**
   * Semestre base type for findFirst actions
   */
  export type SemestreFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * Filter, which Semestre to fetch.
     */
    where?: SemestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semestres to fetch.
     */
    orderBy?: Enumerable<SemestreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Semestres.
     */
    cursor?: SemestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semestres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Semestres.
     */
    distinct?: Enumerable<SemestreScalarFieldEnum>
  }

  /**
   * Semestre findFirst
   */
  export interface SemestreFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SemestreFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Semestre findFirstOrThrow
   */
  export type SemestreFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * Filter, which Semestre to fetch.
     */
    where?: SemestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semestres to fetch.
     */
    orderBy?: Enumerable<SemestreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Semestres.
     */
    cursor?: SemestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semestres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Semestres.
     */
    distinct?: Enumerable<SemestreScalarFieldEnum>
  }


  /**
   * Semestre findMany
   */
  export type SemestreFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * Filter, which Semestres to fetch.
     */
    where?: SemestreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Semestres to fetch.
     */
    orderBy?: Enumerable<SemestreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Semestres.
     */
    cursor?: SemestreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Semestres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Semestres.
     */
    skip?: number
    distinct?: Enumerable<SemestreScalarFieldEnum>
  }


  /**
   * Semestre create
   */
  export type SemestreCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * The data needed to create a Semestre.
     */
    data: XOR<SemestreCreateInput, SemestreUncheckedCreateInput>
  }


  /**
   * Semestre createMany
   */
  export type SemestreCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Semestres.
     */
    data: Enumerable<SemestreCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Semestre update
   */
  export type SemestreUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * The data needed to update a Semestre.
     */
    data: XOR<SemestreUpdateInput, SemestreUncheckedUpdateInput>
    /**
     * Choose, which Semestre to update.
     */
    where: SemestreWhereUniqueInput
  }


  /**
   * Semestre updateMany
   */
  export type SemestreUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Semestres.
     */
    data: XOR<SemestreUpdateManyMutationInput, SemestreUncheckedUpdateManyInput>
    /**
     * Filter which Semestres to update
     */
    where?: SemestreWhereInput
  }


  /**
   * Semestre upsert
   */
  export type SemestreUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * The filter to search for the Semestre to update in case it exists.
     */
    where: SemestreWhereUniqueInput
    /**
     * In case the Semestre found by the `where` argument doesn't exist, create a new Semestre with this data.
     */
    create: XOR<SemestreCreateInput, SemestreUncheckedCreateInput>
    /**
     * In case the Semestre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SemestreUpdateInput, SemestreUncheckedUpdateInput>
  }


  /**
   * Semestre delete
   */
  export type SemestreDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
    /**
     * Filter which Semestre to delete.
     */
    where: SemestreWhereUniqueInput
  }


  /**
   * Semestre deleteMany
   */
  export type SemestreDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Semestres to delete
     */
    where?: SemestreWhereInput
  }


  /**
   * Semestre.matieres
   */
  export type Semestre$matieresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    where?: MatiereWhereInput
    orderBy?: Enumerable<MatiereOrderByWithRelationInput>
    cursor?: MatiereWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MatiereScalarFieldEnum>
  }


  /**
   * Semestre without action
   */
  export type SemestreArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Semestre
     */
    select?: SemestreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemestreInclude<ExtArgs> | null
  }



  /**
   * Model Matiere
   */


  export type AggregateMatiere = {
    _count: MatiereCountAggregateOutputType | null
    _min: MatiereMinAggregateOutputType | null
    _max: MatiereMaxAggregateOutputType | null
  }

  export type MatiereMinAggregateOutputType = {
    id: string | null
    nom: string | null
    code: string | null
    filiereId: string | null
    semestreId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type MatiereMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    code: string | null
    filiereId: string | null
    semestreId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type MatiereCountAggregateOutputType = {
    id: number
    nom: number
    code: number
    filiereId: number
    semestreId: number
    isDeleted: number
    deletedAt: number
    createdAt: number
    _all: number
  }


  export type MatiereMinAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    filiereId?: true
    semestreId?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
  }

  export type MatiereMaxAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    filiereId?: true
    semestreId?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
  }

  export type MatiereCountAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    filiereId?: true
    semestreId?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    _all?: true
  }

  export type MatiereAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matiere to aggregate.
     */
    where?: MatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matieres to fetch.
     */
    orderBy?: Enumerable<MatiereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matieres
    **/
    _count?: true | MatiereCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatiereMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatiereMaxAggregateInputType
  }

  export type GetMatiereAggregateType<T extends MatiereAggregateArgs> = {
        [P in keyof T & keyof AggregateMatiere]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatiere[P]>
      : GetScalarType<T[P], AggregateMatiere[P]>
  }




  export type MatiereGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MatiereWhereInput
    orderBy?: Enumerable<MatiereOrderByWithAggregationInput>
    by: MatiereScalarFieldEnum[]
    having?: MatiereScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatiereCountAggregateInputType | true
    _min?: MatiereMinAggregateInputType
    _max?: MatiereMaxAggregateInputType
  }


  export type MatiereGroupByOutputType = {
    id: string
    nom: string
    code: string
    filiereId: string
    semestreId: string
    isDeleted: boolean
    deletedAt: Date | null
    createdAt: Date
    _count: MatiereCountAggregateOutputType | null
    _min: MatiereMinAggregateOutputType | null
    _max: MatiereMaxAggregateOutputType | null
  }

  type GetMatiereGroupByPayload<T extends MatiereGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MatiereGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatiereGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatiereGroupByOutputType[P]>
            : GetScalarType<T[P], MatiereGroupByOutputType[P]>
        }
      >
    >


  export type MatiereSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code?: boolean
    filiereId?: boolean
    semestreId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    filiere?: boolean | FiliereArgs<ExtArgs>
    semestre?: boolean | SemestreArgs<ExtArgs>
    documents?: boolean | Matiere$documentsArgs<ExtArgs>
    documentMatieres?: boolean | Matiere$documentMatieresArgs<ExtArgs>
    professeurMatieres?: boolean | Matiere$professeurMatieresArgs<ExtArgs>
    _count?: boolean | MatiereCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["matiere"]>

  export type MatiereSelectScalar = {
    id?: boolean
    nom?: boolean
    code?: boolean
    filiereId?: boolean
    semestreId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
  }

  export type MatiereInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    filiere?: boolean | FiliereArgs<ExtArgs>
    semestre?: boolean | SemestreArgs<ExtArgs>
    documents?: boolean | Matiere$documentsArgs<ExtArgs>
    documentMatieres?: boolean | Matiere$documentMatieresArgs<ExtArgs>
    professeurMatieres?: boolean | Matiere$professeurMatieresArgs<ExtArgs>
    _count?: boolean | MatiereCountOutputTypeArgs<ExtArgs>
  }


  type MatiereGetPayload<S extends boolean | null | undefined | MatiereArgs> = $Types.GetResult<MatierePayload, S>

  type MatiereCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MatiereFindManyArgs, 'select' | 'include'> & {
      select?: MatiereCountAggregateInputType | true
    }

  export interface MatiereDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Matiere'], meta: { name: 'Matiere' } }
    /**
     * Find zero or one Matiere that matches the filter.
     * @param {MatiereFindUniqueArgs} args - Arguments to find a Matiere
     * @example
     * // Get one Matiere
     * const matiere = await prisma.matiere.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MatiereFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MatiereFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Matiere'> extends True ? Prisma__MatiereClient<$Types.GetResult<MatierePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__MatiereClient<$Types.GetResult<MatierePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Matiere that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MatiereFindUniqueOrThrowArgs} args - Arguments to find a Matiere
     * @example
     * // Get one Matiere
     * const matiere = await prisma.matiere.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MatiereFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MatiereFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MatiereClient<$Types.GetResult<MatierePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Matiere that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereFindFirstArgs} args - Arguments to find a Matiere
     * @example
     * // Get one Matiere
     * const matiere = await prisma.matiere.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MatiereFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MatiereFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Matiere'> extends True ? Prisma__MatiereClient<$Types.GetResult<MatierePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__MatiereClient<$Types.GetResult<MatierePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Matiere that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereFindFirstOrThrowArgs} args - Arguments to find a Matiere
     * @example
     * // Get one Matiere
     * const matiere = await prisma.matiere.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MatiereFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MatiereFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MatiereClient<$Types.GetResult<MatierePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Matieres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matieres
     * const matieres = await prisma.matiere.findMany()
     * 
     * // Get first 10 Matieres
     * const matieres = await prisma.matiere.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matiereWithIdOnly = await prisma.matiere.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MatiereFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatiereFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<MatierePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Matiere.
     * @param {MatiereCreateArgs} args - Arguments to create a Matiere.
     * @example
     * // Create one Matiere
     * const Matiere = await prisma.matiere.create({
     *   data: {
     *     // ... data to create a Matiere
     *   }
     * })
     * 
    **/
    create<T extends MatiereCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MatiereCreateArgs<ExtArgs>>
    ): Prisma__MatiereClient<$Types.GetResult<MatierePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Matieres.
     *     @param {MatiereCreateManyArgs} args - Arguments to create many Matieres.
     *     @example
     *     // Create many Matieres
     *     const matiere = await prisma.matiere.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MatiereCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatiereCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Matiere.
     * @param {MatiereDeleteArgs} args - Arguments to delete one Matiere.
     * @example
     * // Delete one Matiere
     * const Matiere = await prisma.matiere.delete({
     *   where: {
     *     // ... filter to delete one Matiere
     *   }
     * })
     * 
    **/
    delete<T extends MatiereDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MatiereDeleteArgs<ExtArgs>>
    ): Prisma__MatiereClient<$Types.GetResult<MatierePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Matiere.
     * @param {MatiereUpdateArgs} args - Arguments to update one Matiere.
     * @example
     * // Update one Matiere
     * const matiere = await prisma.matiere.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MatiereUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MatiereUpdateArgs<ExtArgs>>
    ): Prisma__MatiereClient<$Types.GetResult<MatierePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Matieres.
     * @param {MatiereDeleteManyArgs} args - Arguments to filter Matieres to delete.
     * @example
     * // Delete a few Matieres
     * const { count } = await prisma.matiere.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MatiereDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MatiereDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matieres
     * const matiere = await prisma.matiere.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MatiereUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MatiereUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Matiere.
     * @param {MatiereUpsertArgs} args - Arguments to update or create a Matiere.
     * @example
     * // Update or create a Matiere
     * const matiere = await prisma.matiere.upsert({
     *   create: {
     *     // ... data to create a Matiere
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Matiere we want to update
     *   }
     * })
    **/
    upsert<T extends MatiereUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MatiereUpsertArgs<ExtArgs>>
    ): Prisma__MatiereClient<$Types.GetResult<MatierePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Matieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereCountArgs} args - Arguments to filter Matieres to count.
     * @example
     * // Count the number of Matieres
     * const count = await prisma.matiere.count({
     *   where: {
     *     // ... the filter for the Matieres we want to count
     *   }
     * })
    **/
    count<T extends MatiereCountArgs>(
      args?: Subset<T, MatiereCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatiereCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Matiere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatiereAggregateArgs>(args: Subset<T, MatiereAggregateArgs>): Prisma.PrismaPromise<GetMatiereAggregateType<T>>

    /**
     * Group by Matiere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatiereGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatiereGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatiereGroupByArgs['orderBy'] }
        : { orderBy?: MatiereGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatiereGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatiereGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Matiere.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MatiereClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    filiere<T extends FiliereArgs<ExtArgs> = {}>(args?: Subset<T, FiliereArgs<ExtArgs>>): Prisma__FiliereClient<$Types.GetResult<FilierePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    semestre<T extends SemestreArgs<ExtArgs> = {}>(args?: Subset<T, SemestreArgs<ExtArgs>>): Prisma__SemestreClient<$Types.GetResult<SemestrePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    documents<T extends Matiere$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Matiere$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    documentMatieres<T extends Matiere$documentMatieresArgs<ExtArgs> = {}>(args?: Subset<T, Matiere$documentMatieresArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentMatierePayload<ExtArgs>, T, 'findMany', never>| Null>;

    professeurMatieres<T extends Matiere$professeurMatieresArgs<ExtArgs> = {}>(args?: Subset<T, Matiere$professeurMatieresArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ProfesseurMatierePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Matiere base type for findUnique actions
   */
  export type MatiereFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matiere to fetch.
     */
    where: MatiereWhereUniqueInput
  }

  /**
   * Matiere findUnique
   */
  export interface MatiereFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MatiereFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Matiere findUniqueOrThrow
   */
  export type MatiereFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matiere to fetch.
     */
    where: MatiereWhereUniqueInput
  }


  /**
   * Matiere base type for findFirst actions
   */
  export type MatiereFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matiere to fetch.
     */
    where?: MatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matieres to fetch.
     */
    orderBy?: Enumerable<MatiereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matieres.
     */
    cursor?: MatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matieres.
     */
    distinct?: Enumerable<MatiereScalarFieldEnum>
  }

  /**
   * Matiere findFirst
   */
  export interface MatiereFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MatiereFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Matiere findFirstOrThrow
   */
  export type MatiereFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matiere to fetch.
     */
    where?: MatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matieres to fetch.
     */
    orderBy?: Enumerable<MatiereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matieres.
     */
    cursor?: MatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matieres.
     */
    distinct?: Enumerable<MatiereScalarFieldEnum>
  }


  /**
   * Matiere findMany
   */
  export type MatiereFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter, which Matieres to fetch.
     */
    where?: MatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matieres to fetch.
     */
    orderBy?: Enumerable<MatiereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matieres.
     */
    cursor?: MatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matieres.
     */
    skip?: number
    distinct?: Enumerable<MatiereScalarFieldEnum>
  }


  /**
   * Matiere create
   */
  export type MatiereCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * The data needed to create a Matiere.
     */
    data: XOR<MatiereCreateInput, MatiereUncheckedCreateInput>
  }


  /**
   * Matiere createMany
   */
  export type MatiereCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matieres.
     */
    data: Enumerable<MatiereCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Matiere update
   */
  export type MatiereUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * The data needed to update a Matiere.
     */
    data: XOR<MatiereUpdateInput, MatiereUncheckedUpdateInput>
    /**
     * Choose, which Matiere to update.
     */
    where: MatiereWhereUniqueInput
  }


  /**
   * Matiere updateMany
   */
  export type MatiereUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matieres.
     */
    data: XOR<MatiereUpdateManyMutationInput, MatiereUncheckedUpdateManyInput>
    /**
     * Filter which Matieres to update
     */
    where?: MatiereWhereInput
  }


  /**
   * Matiere upsert
   */
  export type MatiereUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * The filter to search for the Matiere to update in case it exists.
     */
    where: MatiereWhereUniqueInput
    /**
     * In case the Matiere found by the `where` argument doesn't exist, create a new Matiere with this data.
     */
    create: XOR<MatiereCreateInput, MatiereUncheckedCreateInput>
    /**
     * In case the Matiere was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatiereUpdateInput, MatiereUncheckedUpdateInput>
  }


  /**
   * Matiere delete
   */
  export type MatiereDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
    /**
     * Filter which Matiere to delete.
     */
    where: MatiereWhereUniqueInput
  }


  /**
   * Matiere deleteMany
   */
  export type MatiereDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matieres to delete
     */
    where?: MatiereWhereInput
  }


  /**
   * Matiere.documents
   */
  export type Matiere$documentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Matiere.documentMatieres
   */
  export type Matiere$documentMatieresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMatiere
     */
    select?: DocumentMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentMatiereInclude<ExtArgs> | null
    where?: DocumentMatiereWhereInput
    orderBy?: Enumerable<DocumentMatiereOrderByWithRelationInput>
    cursor?: DocumentMatiereWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DocumentMatiereScalarFieldEnum>
  }


  /**
   * Matiere.professeurMatieres
   */
  export type Matiere$professeurMatieresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesseurMatiere
     */
    select?: ProfesseurMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurMatiereInclude<ExtArgs> | null
    where?: ProfesseurMatiereWhereInput
    orderBy?: Enumerable<ProfesseurMatiereOrderByWithRelationInput>
    cursor?: ProfesseurMatiereWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProfesseurMatiereScalarFieldEnum>
  }


  /**
   * Matiere without action
   */
  export type MatiereArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matiere
     */
    select?: MatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MatiereInclude<ExtArgs> | null
  }



  /**
   * Model ProfesseurMatiere
   */


  export type AggregateProfesseurMatiere = {
    _count: ProfesseurMatiereCountAggregateOutputType | null
    _min: ProfesseurMatiereMinAggregateOutputType | null
    _max: ProfesseurMatiereMaxAggregateOutputType | null
  }

  export type ProfesseurMatiereMinAggregateOutputType = {
    id: string | null
    professeurId: string | null
    matiereId: string | null
    role: ProfesseurRole | null
    createdAt: Date | null
  }

  export type ProfesseurMatiereMaxAggregateOutputType = {
    id: string | null
    professeurId: string | null
    matiereId: string | null
    role: ProfesseurRole | null
    createdAt: Date | null
  }

  export type ProfesseurMatiereCountAggregateOutputType = {
    id: number
    professeurId: number
    matiereId: number
    role: number
    createdAt: number
    _all: number
  }


  export type ProfesseurMatiereMinAggregateInputType = {
    id?: true
    professeurId?: true
    matiereId?: true
    role?: true
    createdAt?: true
  }

  export type ProfesseurMatiereMaxAggregateInputType = {
    id?: true
    professeurId?: true
    matiereId?: true
    role?: true
    createdAt?: true
  }

  export type ProfesseurMatiereCountAggregateInputType = {
    id?: true
    professeurId?: true
    matiereId?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type ProfesseurMatiereAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfesseurMatiere to aggregate.
     */
    where?: ProfesseurMatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfesseurMatieres to fetch.
     */
    orderBy?: Enumerable<ProfesseurMatiereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfesseurMatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfesseurMatieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfesseurMatieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfesseurMatieres
    **/
    _count?: true | ProfesseurMatiereCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfesseurMatiereMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfesseurMatiereMaxAggregateInputType
  }

  export type GetProfesseurMatiereAggregateType<T extends ProfesseurMatiereAggregateArgs> = {
        [P in keyof T & keyof AggregateProfesseurMatiere]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfesseurMatiere[P]>
      : GetScalarType<T[P], AggregateProfesseurMatiere[P]>
  }




  export type ProfesseurMatiereGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ProfesseurMatiereWhereInput
    orderBy?: Enumerable<ProfesseurMatiereOrderByWithAggregationInput>
    by: ProfesseurMatiereScalarFieldEnum[]
    having?: ProfesseurMatiereScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfesseurMatiereCountAggregateInputType | true
    _min?: ProfesseurMatiereMinAggregateInputType
    _max?: ProfesseurMatiereMaxAggregateInputType
  }


  export type ProfesseurMatiereGroupByOutputType = {
    id: string
    professeurId: string
    matiereId: string
    role: ProfesseurRole
    createdAt: Date
    _count: ProfesseurMatiereCountAggregateOutputType | null
    _min: ProfesseurMatiereMinAggregateOutputType | null
    _max: ProfesseurMatiereMaxAggregateOutputType | null
  }

  type GetProfesseurMatiereGroupByPayload<T extends ProfesseurMatiereGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProfesseurMatiereGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfesseurMatiereGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfesseurMatiereGroupByOutputType[P]>
            : GetScalarType<T[P], ProfesseurMatiereGroupByOutputType[P]>
        }
      >
    >


  export type ProfesseurMatiereSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    professeurId?: boolean
    matiereId?: boolean
    role?: boolean
    createdAt?: boolean
    professeur?: boolean | UserArgs<ExtArgs>
    matiere?: boolean | MatiereArgs<ExtArgs>
  }, ExtArgs["result"]["professeurMatiere"]>

  export type ProfesseurMatiereSelectScalar = {
    id?: boolean
    professeurId?: boolean
    matiereId?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type ProfesseurMatiereInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    professeur?: boolean | UserArgs<ExtArgs>
    matiere?: boolean | MatiereArgs<ExtArgs>
  }


  type ProfesseurMatiereGetPayload<S extends boolean | null | undefined | ProfesseurMatiereArgs> = $Types.GetResult<ProfesseurMatierePayload, S>

  type ProfesseurMatiereCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ProfesseurMatiereFindManyArgs, 'select' | 'include'> & {
      select?: ProfesseurMatiereCountAggregateInputType | true
    }

  export interface ProfesseurMatiereDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfesseurMatiere'], meta: { name: 'ProfesseurMatiere' } }
    /**
     * Find zero or one ProfesseurMatiere that matches the filter.
     * @param {ProfesseurMatiereFindUniqueArgs} args - Arguments to find a ProfesseurMatiere
     * @example
     * // Get one ProfesseurMatiere
     * const professeurMatiere = await prisma.professeurMatiere.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProfesseurMatiereFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProfesseurMatiereFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ProfesseurMatiere'> extends True ? Prisma__ProfesseurMatiereClient<$Types.GetResult<ProfesseurMatierePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ProfesseurMatiereClient<$Types.GetResult<ProfesseurMatierePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ProfesseurMatiere that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProfesseurMatiereFindUniqueOrThrowArgs} args - Arguments to find a ProfesseurMatiere
     * @example
     * // Get one ProfesseurMatiere
     * const professeurMatiere = await prisma.professeurMatiere.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProfesseurMatiereFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfesseurMatiereFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProfesseurMatiereClient<$Types.GetResult<ProfesseurMatierePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ProfesseurMatiere that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesseurMatiereFindFirstArgs} args - Arguments to find a ProfesseurMatiere
     * @example
     * // Get one ProfesseurMatiere
     * const professeurMatiere = await prisma.professeurMatiere.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProfesseurMatiereFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProfesseurMatiereFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ProfesseurMatiere'> extends True ? Prisma__ProfesseurMatiereClient<$Types.GetResult<ProfesseurMatierePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ProfesseurMatiereClient<$Types.GetResult<ProfesseurMatierePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ProfesseurMatiere that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesseurMatiereFindFirstOrThrowArgs} args - Arguments to find a ProfesseurMatiere
     * @example
     * // Get one ProfesseurMatiere
     * const professeurMatiere = await prisma.professeurMatiere.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProfesseurMatiereFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfesseurMatiereFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProfesseurMatiereClient<$Types.GetResult<ProfesseurMatierePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ProfesseurMatieres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesseurMatiereFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfesseurMatieres
     * const professeurMatieres = await prisma.professeurMatiere.findMany()
     * 
     * // Get first 10 ProfesseurMatieres
     * const professeurMatieres = await prisma.professeurMatiere.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const professeurMatiereWithIdOnly = await prisma.professeurMatiere.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProfesseurMatiereFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfesseurMatiereFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ProfesseurMatierePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ProfesseurMatiere.
     * @param {ProfesseurMatiereCreateArgs} args - Arguments to create a ProfesseurMatiere.
     * @example
     * // Create one ProfesseurMatiere
     * const ProfesseurMatiere = await prisma.professeurMatiere.create({
     *   data: {
     *     // ... data to create a ProfesseurMatiere
     *   }
     * })
     * 
    **/
    create<T extends ProfesseurMatiereCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProfesseurMatiereCreateArgs<ExtArgs>>
    ): Prisma__ProfesseurMatiereClient<$Types.GetResult<ProfesseurMatierePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ProfesseurMatieres.
     *     @param {ProfesseurMatiereCreateManyArgs} args - Arguments to create many ProfesseurMatieres.
     *     @example
     *     // Create many ProfesseurMatieres
     *     const professeurMatiere = await prisma.professeurMatiere.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProfesseurMatiereCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfesseurMatiereCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProfesseurMatiere.
     * @param {ProfesseurMatiereDeleteArgs} args - Arguments to delete one ProfesseurMatiere.
     * @example
     * // Delete one ProfesseurMatiere
     * const ProfesseurMatiere = await prisma.professeurMatiere.delete({
     *   where: {
     *     // ... filter to delete one ProfesseurMatiere
     *   }
     * })
     * 
    **/
    delete<T extends ProfesseurMatiereDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProfesseurMatiereDeleteArgs<ExtArgs>>
    ): Prisma__ProfesseurMatiereClient<$Types.GetResult<ProfesseurMatierePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ProfesseurMatiere.
     * @param {ProfesseurMatiereUpdateArgs} args - Arguments to update one ProfesseurMatiere.
     * @example
     * // Update one ProfesseurMatiere
     * const professeurMatiere = await prisma.professeurMatiere.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProfesseurMatiereUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProfesseurMatiereUpdateArgs<ExtArgs>>
    ): Prisma__ProfesseurMatiereClient<$Types.GetResult<ProfesseurMatierePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ProfesseurMatieres.
     * @param {ProfesseurMatiereDeleteManyArgs} args - Arguments to filter ProfesseurMatieres to delete.
     * @example
     * // Delete a few ProfesseurMatieres
     * const { count } = await prisma.professeurMatiere.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProfesseurMatiereDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProfesseurMatiereDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfesseurMatieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesseurMatiereUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfesseurMatieres
     * const professeurMatiere = await prisma.professeurMatiere.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProfesseurMatiereUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProfesseurMatiereUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfesseurMatiere.
     * @param {ProfesseurMatiereUpsertArgs} args - Arguments to update or create a ProfesseurMatiere.
     * @example
     * // Update or create a ProfesseurMatiere
     * const professeurMatiere = await prisma.professeurMatiere.upsert({
     *   create: {
     *     // ... data to create a ProfesseurMatiere
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfesseurMatiere we want to update
     *   }
     * })
    **/
    upsert<T extends ProfesseurMatiereUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProfesseurMatiereUpsertArgs<ExtArgs>>
    ): Prisma__ProfesseurMatiereClient<$Types.GetResult<ProfesseurMatierePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ProfesseurMatieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesseurMatiereCountArgs} args - Arguments to filter ProfesseurMatieres to count.
     * @example
     * // Count the number of ProfesseurMatieres
     * const count = await prisma.professeurMatiere.count({
     *   where: {
     *     // ... the filter for the ProfesseurMatieres we want to count
     *   }
     * })
    **/
    count<T extends ProfesseurMatiereCountArgs>(
      args?: Subset<T, ProfesseurMatiereCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfesseurMatiereCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfesseurMatiere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesseurMatiereAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfesseurMatiereAggregateArgs>(args: Subset<T, ProfesseurMatiereAggregateArgs>): Prisma.PrismaPromise<GetProfesseurMatiereAggregateType<T>>

    /**
     * Group by ProfesseurMatiere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfesseurMatiereGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfesseurMatiereGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfesseurMatiereGroupByArgs['orderBy'] }
        : { orderBy?: ProfesseurMatiereGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfesseurMatiereGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfesseurMatiereGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfesseurMatiere.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProfesseurMatiereClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    professeur<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    matiere<T extends MatiereArgs<ExtArgs> = {}>(args?: Subset<T, MatiereArgs<ExtArgs>>): Prisma__MatiereClient<$Types.GetResult<MatierePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ProfesseurMatiere base type for findUnique actions
   */
  export type ProfesseurMatiereFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesseurMatiere
     */
    select?: ProfesseurMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurMatiereInclude<ExtArgs> | null
    /**
     * Filter, which ProfesseurMatiere to fetch.
     */
    where: ProfesseurMatiereWhereUniqueInput
  }

  /**
   * ProfesseurMatiere findUnique
   */
  export interface ProfesseurMatiereFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProfesseurMatiereFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProfesseurMatiere findUniqueOrThrow
   */
  export type ProfesseurMatiereFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesseurMatiere
     */
    select?: ProfesseurMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurMatiereInclude<ExtArgs> | null
    /**
     * Filter, which ProfesseurMatiere to fetch.
     */
    where: ProfesseurMatiereWhereUniqueInput
  }


  /**
   * ProfesseurMatiere base type for findFirst actions
   */
  export type ProfesseurMatiereFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesseurMatiere
     */
    select?: ProfesseurMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurMatiereInclude<ExtArgs> | null
    /**
     * Filter, which ProfesseurMatiere to fetch.
     */
    where?: ProfesseurMatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfesseurMatieres to fetch.
     */
    orderBy?: Enumerable<ProfesseurMatiereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfesseurMatieres.
     */
    cursor?: ProfesseurMatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfesseurMatieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfesseurMatieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfesseurMatieres.
     */
    distinct?: Enumerable<ProfesseurMatiereScalarFieldEnum>
  }

  /**
   * ProfesseurMatiere findFirst
   */
  export interface ProfesseurMatiereFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ProfesseurMatiereFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ProfesseurMatiere findFirstOrThrow
   */
  export type ProfesseurMatiereFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesseurMatiere
     */
    select?: ProfesseurMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurMatiereInclude<ExtArgs> | null
    /**
     * Filter, which ProfesseurMatiere to fetch.
     */
    where?: ProfesseurMatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfesseurMatieres to fetch.
     */
    orderBy?: Enumerable<ProfesseurMatiereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfesseurMatieres.
     */
    cursor?: ProfesseurMatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfesseurMatieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfesseurMatieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfesseurMatieres.
     */
    distinct?: Enumerable<ProfesseurMatiereScalarFieldEnum>
  }


  /**
   * ProfesseurMatiere findMany
   */
  export type ProfesseurMatiereFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesseurMatiere
     */
    select?: ProfesseurMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurMatiereInclude<ExtArgs> | null
    /**
     * Filter, which ProfesseurMatieres to fetch.
     */
    where?: ProfesseurMatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfesseurMatieres to fetch.
     */
    orderBy?: Enumerable<ProfesseurMatiereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfesseurMatieres.
     */
    cursor?: ProfesseurMatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfesseurMatieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfesseurMatieres.
     */
    skip?: number
    distinct?: Enumerable<ProfesseurMatiereScalarFieldEnum>
  }


  /**
   * ProfesseurMatiere create
   */
  export type ProfesseurMatiereCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesseurMatiere
     */
    select?: ProfesseurMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurMatiereInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfesseurMatiere.
     */
    data: XOR<ProfesseurMatiereCreateInput, ProfesseurMatiereUncheckedCreateInput>
  }


  /**
   * ProfesseurMatiere createMany
   */
  export type ProfesseurMatiereCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfesseurMatieres.
     */
    data: Enumerable<ProfesseurMatiereCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ProfesseurMatiere update
   */
  export type ProfesseurMatiereUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesseurMatiere
     */
    select?: ProfesseurMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurMatiereInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfesseurMatiere.
     */
    data: XOR<ProfesseurMatiereUpdateInput, ProfesseurMatiereUncheckedUpdateInput>
    /**
     * Choose, which ProfesseurMatiere to update.
     */
    where: ProfesseurMatiereWhereUniqueInput
  }


  /**
   * ProfesseurMatiere updateMany
   */
  export type ProfesseurMatiereUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfesseurMatieres.
     */
    data: XOR<ProfesseurMatiereUpdateManyMutationInput, ProfesseurMatiereUncheckedUpdateManyInput>
    /**
     * Filter which ProfesseurMatieres to update
     */
    where?: ProfesseurMatiereWhereInput
  }


  /**
   * ProfesseurMatiere upsert
   */
  export type ProfesseurMatiereUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesseurMatiere
     */
    select?: ProfesseurMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurMatiereInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfesseurMatiere to update in case it exists.
     */
    where: ProfesseurMatiereWhereUniqueInput
    /**
     * In case the ProfesseurMatiere found by the `where` argument doesn't exist, create a new ProfesseurMatiere with this data.
     */
    create: XOR<ProfesseurMatiereCreateInput, ProfesseurMatiereUncheckedCreateInput>
    /**
     * In case the ProfesseurMatiere was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfesseurMatiereUpdateInput, ProfesseurMatiereUncheckedUpdateInput>
  }


  /**
   * ProfesseurMatiere delete
   */
  export type ProfesseurMatiereDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesseurMatiere
     */
    select?: ProfesseurMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurMatiereInclude<ExtArgs> | null
    /**
     * Filter which ProfesseurMatiere to delete.
     */
    where: ProfesseurMatiereWhereUniqueInput
  }


  /**
   * ProfesseurMatiere deleteMany
   */
  export type ProfesseurMatiereDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfesseurMatieres to delete
     */
    where?: ProfesseurMatiereWhereInput
  }


  /**
   * ProfesseurMatiere without action
   */
  export type ProfesseurMatiereArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfesseurMatiere
     */
    select?: ProfesseurMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProfesseurMatiereInclude<ExtArgs> | null
  }



  /**
   * Model Document
   */


  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    tailleFichier: number | null
    downloadCount: number | null
    viewCount: number | null
  }

  export type DocumentSumAggregateOutputType = {
    tailleFichier: bigint | null
    downloadCount: number | null
    viewCount: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    titre: string | null
    description: string | null
    cheminFichier: string | null
    nomFichier: string | null
    tailleFichier: bigint | null
    typeMime: string | null
    categorie: DocumentCategorie | null
    matiereId: string | null
    telchargePar: string | null
    correctionId: string | null
    downloadCount: number | null
    viewCount: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    titre: string | null
    description: string | null
    cheminFichier: string | null
    nomFichier: string | null
    tailleFichier: bigint | null
    typeMime: string | null
    categorie: DocumentCategorie | null
    matiereId: string | null
    telchargePar: string | null
    correctionId: string | null
    downloadCount: number | null
    viewCount: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    titre: number
    description: number
    cheminFichier: number
    nomFichier: number
    tailleFichier: number
    typeMime: number
    categorie: number
    matiereId: number
    telchargePar: number
    correctionId: number
    downloadCount: number
    viewCount: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    tailleFichier?: true
    downloadCount?: true
    viewCount?: true
  }

  export type DocumentSumAggregateInputType = {
    tailleFichier?: true
    downloadCount?: true
    viewCount?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    titre?: true
    description?: true
    cheminFichier?: true
    nomFichier?: true
    tailleFichier?: true
    typeMime?: true
    categorie?: true
    matiereId?: true
    telchargePar?: true
    correctionId?: true
    downloadCount?: true
    viewCount?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    titre?: true
    description?: true
    cheminFichier?: true
    nomFichier?: true
    tailleFichier?: true
    typeMime?: true
    categorie?: true
    matiereId?: true
    telchargePar?: true
    correctionId?: true
    downloadCount?: true
    viewCount?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    titre?: true
    description?: true
    cheminFichier?: true
    nomFichier?: true
    tailleFichier?: true
    typeMime?: true
    categorie?: true
    matiereId?: true
    telchargePar?: true
    correctionId?: true
    downloadCount?: true
    viewCount?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithAggregationInput>
    by: DocumentScalarFieldEnum[]
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }


  export type DocumentGroupByOutputType = {
    id: string
    titre: string
    description: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint
    typeMime: string
    categorie: DocumentCategorie
    matiereId: string | null
    telchargePar: string
    correctionId: string | null
    downloadCount: number
    viewCount: number
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titre?: boolean
    description?: boolean
    cheminFichier?: boolean
    nomFichier?: boolean
    tailleFichier?: boolean
    typeMime?: boolean
    categorie?: boolean
    matiereId?: boolean
    telchargePar?: boolean
    correctionId?: boolean
    downloadCount?: boolean
    viewCount?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    matiere?: boolean | MatiereArgs<ExtArgs>
    uploader?: boolean | UserArgs<ExtArgs>
    deleter?: boolean | UserArgs<ExtArgs>
    commentaires?: boolean | Document$commentairesArgs<ExtArgs>
    documentPFE?: boolean | DocumentPFEArgs<ExtArgs>
    documentMatieres?: boolean | Document$documentMatieresArgs<ExtArgs>
    correctionPour?: boolean | DocumentArgs<ExtArgs>
    correction?: boolean | DocumentArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    titre?: boolean
    description?: boolean
    cheminFichier?: boolean
    nomFichier?: boolean
    tailleFichier?: boolean
    typeMime?: boolean
    categorie?: boolean
    matiereId?: boolean
    telchargePar?: boolean
    correctionId?: boolean
    downloadCount?: boolean
    viewCount?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    matiere?: boolean | MatiereArgs<ExtArgs>
    uploader?: boolean | UserArgs<ExtArgs>
    deleter?: boolean | UserArgs<ExtArgs>
    commentaires?: boolean | Document$commentairesArgs<ExtArgs>
    documentPFE?: boolean | DocumentPFEArgs<ExtArgs>
    documentMatieres?: boolean | Document$documentMatieresArgs<ExtArgs>
    correctionPour?: boolean | DocumentArgs<ExtArgs>
    correction?: boolean | DocumentArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeArgs<ExtArgs>
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentArgs> = $Types.GetResult<DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    matiere<T extends MatiereArgs<ExtArgs> = {}>(args?: Subset<T, MatiereArgs<ExtArgs>>): Prisma__MatiereClient<$Types.GetResult<MatierePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    uploader<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    deleter<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    commentaires<T extends Document$commentairesArgs<ExtArgs> = {}>(args?: Subset<T, Document$commentairesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'findMany', never>| Null>;

    documentPFE<T extends DocumentPFEArgs<ExtArgs> = {}>(args?: Subset<T, DocumentPFEArgs<ExtArgs>>): Prisma__DocumentPFEClient<$Types.GetResult<DocumentPFEPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    documentMatieres<T extends Document$documentMatieresArgs<ExtArgs> = {}>(args?: Subset<T, Document$documentMatieresArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentMatierePayload<ExtArgs>, T, 'findMany', never>| Null>;

    correctionPour<T extends DocumentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentArgs<ExtArgs>>): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    correction<T extends DocumentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentArgs<ExtArgs>>): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Document base type for findUnique actions
   */
  export type DocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUnique
   */
  export interface DocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document base type for findFirst actions
   */
  export type DocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }

  /**
   * Document findFirst
   */
  export interface DocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: Enumerable<DocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document.commentaires
   */
  export type Document$commentairesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    where?: CommentaireWhereInput
    orderBy?: Enumerable<CommentaireOrderByWithRelationInput>
    cursor?: CommentaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentaireScalarFieldEnum>
  }


  /**
   * Document.documentMatieres
   */
  export type Document$documentMatieresArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMatiere
     */
    select?: DocumentMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentMatiereInclude<ExtArgs> | null
    where?: DocumentMatiereWhereInput
    orderBy?: Enumerable<DocumentMatiereOrderByWithRelationInput>
    cursor?: DocumentMatiereWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DocumentMatiereScalarFieldEnum>
  }


  /**
   * Document without action
   */
  export type DocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model DocumentPFE
   */


  export type AggregateDocumentPFE = {
    _count: DocumentPFECountAggregateOutputType | null
    _avg: DocumentPFEAvgAggregateOutputType | null
    _sum: DocumentPFESumAggregateOutputType | null
    _min: DocumentPFEMinAggregateOutputType | null
    _max: DocumentPFEMaxAggregateOutputType | null
  }

  export type DocumentPFEAvgAggregateOutputType = {
    anneeDiplome: number | null
  }

  export type DocumentPFESumAggregateOutputType = {
    anneeDiplome: number | null
  }

  export type DocumentPFEMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    anneeDiplome: number | null
    filiereDiplome: string | null
    titreProjet: string | null
    resume: string | null
    createdAt: Date | null
  }

  export type DocumentPFEMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    anneeDiplome: number | null
    filiereDiplome: string | null
    titreProjet: string | null
    resume: string | null
    createdAt: Date | null
  }

  export type DocumentPFECountAggregateOutputType = {
    id: number
    documentId: number
    anneeDiplome: number
    filiereDiplome: number
    titreProjet: number
    resume: number
    motsCles: number
    createdAt: number
    _all: number
  }


  export type DocumentPFEAvgAggregateInputType = {
    anneeDiplome?: true
  }

  export type DocumentPFESumAggregateInputType = {
    anneeDiplome?: true
  }

  export type DocumentPFEMinAggregateInputType = {
    id?: true
    documentId?: true
    anneeDiplome?: true
    filiereDiplome?: true
    titreProjet?: true
    resume?: true
    createdAt?: true
  }

  export type DocumentPFEMaxAggregateInputType = {
    id?: true
    documentId?: true
    anneeDiplome?: true
    filiereDiplome?: true
    titreProjet?: true
    resume?: true
    createdAt?: true
  }

  export type DocumentPFECountAggregateInputType = {
    id?: true
    documentId?: true
    anneeDiplome?: true
    filiereDiplome?: true
    titreProjet?: true
    resume?: true
    motsCles?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentPFEAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentPFE to aggregate.
     */
    where?: DocumentPFEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPFES to fetch.
     */
    orderBy?: Enumerable<DocumentPFEOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentPFEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPFES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPFES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentPFES
    **/
    _count?: true | DocumentPFECountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentPFEAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentPFESumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentPFEMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentPFEMaxAggregateInputType
  }

  export type GetDocumentPFEAggregateType<T extends DocumentPFEAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentPFE]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentPFE[P]>
      : GetScalarType<T[P], AggregateDocumentPFE[P]>
  }




  export type DocumentPFEGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentPFEWhereInput
    orderBy?: Enumerable<DocumentPFEOrderByWithAggregationInput>
    by: DocumentPFEScalarFieldEnum[]
    having?: DocumentPFEScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentPFECountAggregateInputType | true
    _avg?: DocumentPFEAvgAggregateInputType
    _sum?: DocumentPFESumAggregateInputType
    _min?: DocumentPFEMinAggregateInputType
    _max?: DocumentPFEMaxAggregateInputType
  }


  export type DocumentPFEGroupByOutputType = {
    id: string
    documentId: string
    anneeDiplome: number
    filiereDiplome: string
    titreProjet: string
    resume: string | null
    motsCles: string[]
    createdAt: Date
    _count: DocumentPFECountAggregateOutputType | null
    _avg: DocumentPFEAvgAggregateOutputType | null
    _sum: DocumentPFESumAggregateOutputType | null
    _min: DocumentPFEMinAggregateOutputType | null
    _max: DocumentPFEMaxAggregateOutputType | null
  }

  type GetDocumentPFEGroupByPayload<T extends DocumentPFEGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DocumentPFEGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentPFEGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentPFEGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentPFEGroupByOutputType[P]>
        }
      >
    >


  export type DocumentPFESelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    anneeDiplome?: boolean
    filiereDiplome?: boolean
    titreProjet?: boolean
    resume?: boolean
    motsCles?: boolean
    createdAt?: boolean
    document?: boolean | DocumentArgs<ExtArgs>
  }, ExtArgs["result"]["documentPFE"]>

  export type DocumentPFESelectScalar = {
    id?: boolean
    documentId?: boolean
    anneeDiplome?: boolean
    filiereDiplome?: boolean
    titreProjet?: boolean
    resume?: boolean
    motsCles?: boolean
    createdAt?: boolean
  }

  export type DocumentPFEInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentArgs<ExtArgs>
  }


  type DocumentPFEGetPayload<S extends boolean | null | undefined | DocumentPFEArgs> = $Types.GetResult<DocumentPFEPayload, S>

  type DocumentPFECountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DocumentPFEFindManyArgs, 'select' | 'include'> & {
      select?: DocumentPFECountAggregateInputType | true
    }

  export interface DocumentPFEDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentPFE'], meta: { name: 'DocumentPFE' } }
    /**
     * Find zero or one DocumentPFE that matches the filter.
     * @param {DocumentPFEFindUniqueArgs} args - Arguments to find a DocumentPFE
     * @example
     * // Get one DocumentPFE
     * const documentPFE = await prisma.documentPFE.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentPFEFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentPFEFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DocumentPFE'> extends True ? Prisma__DocumentPFEClient<$Types.GetResult<DocumentPFEPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DocumentPFEClient<$Types.GetResult<DocumentPFEPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one DocumentPFE that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentPFEFindUniqueOrThrowArgs} args - Arguments to find a DocumentPFE
     * @example
     * // Get one DocumentPFE
     * const documentPFE = await prisma.documentPFE.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentPFEFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentPFEFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentPFEClient<$Types.GetResult<DocumentPFEPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first DocumentPFE that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPFEFindFirstArgs} args - Arguments to find a DocumentPFE
     * @example
     * // Get one DocumentPFE
     * const documentPFE = await prisma.documentPFE.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentPFEFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentPFEFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DocumentPFE'> extends True ? Prisma__DocumentPFEClient<$Types.GetResult<DocumentPFEPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DocumentPFEClient<$Types.GetResult<DocumentPFEPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first DocumentPFE that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPFEFindFirstOrThrowArgs} args - Arguments to find a DocumentPFE
     * @example
     * // Get one DocumentPFE
     * const documentPFE = await prisma.documentPFE.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentPFEFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentPFEFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentPFEClient<$Types.GetResult<DocumentPFEPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more DocumentPFES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPFEFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentPFES
     * const documentPFES = await prisma.documentPFE.findMany()
     * 
     * // Get first 10 DocumentPFES
     * const documentPFES = await prisma.documentPFE.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentPFEWithIdOnly = await prisma.documentPFE.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentPFEFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentPFEFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DocumentPFEPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a DocumentPFE.
     * @param {DocumentPFECreateArgs} args - Arguments to create a DocumentPFE.
     * @example
     * // Create one DocumentPFE
     * const DocumentPFE = await prisma.documentPFE.create({
     *   data: {
     *     // ... data to create a DocumentPFE
     *   }
     * })
     * 
    **/
    create<T extends DocumentPFECreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentPFECreateArgs<ExtArgs>>
    ): Prisma__DocumentPFEClient<$Types.GetResult<DocumentPFEPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many DocumentPFES.
     *     @param {DocumentPFECreateManyArgs} args - Arguments to create many DocumentPFES.
     *     @example
     *     // Create many DocumentPFES
     *     const documentPFE = await prisma.documentPFE.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentPFECreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentPFECreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentPFE.
     * @param {DocumentPFEDeleteArgs} args - Arguments to delete one DocumentPFE.
     * @example
     * // Delete one DocumentPFE
     * const DocumentPFE = await prisma.documentPFE.delete({
     *   where: {
     *     // ... filter to delete one DocumentPFE
     *   }
     * })
     * 
    **/
    delete<T extends DocumentPFEDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentPFEDeleteArgs<ExtArgs>>
    ): Prisma__DocumentPFEClient<$Types.GetResult<DocumentPFEPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one DocumentPFE.
     * @param {DocumentPFEUpdateArgs} args - Arguments to update one DocumentPFE.
     * @example
     * // Update one DocumentPFE
     * const documentPFE = await prisma.documentPFE.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentPFEUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentPFEUpdateArgs<ExtArgs>>
    ): Prisma__DocumentPFEClient<$Types.GetResult<DocumentPFEPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more DocumentPFES.
     * @param {DocumentPFEDeleteManyArgs} args - Arguments to filter DocumentPFES to delete.
     * @example
     * // Delete a few DocumentPFES
     * const { count } = await prisma.documentPFE.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentPFEDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentPFEDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentPFES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPFEUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentPFES
     * const documentPFE = await prisma.documentPFE.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentPFEUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentPFEUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentPFE.
     * @param {DocumentPFEUpsertArgs} args - Arguments to update or create a DocumentPFE.
     * @example
     * // Update or create a DocumentPFE
     * const documentPFE = await prisma.documentPFE.upsert({
     *   create: {
     *     // ... data to create a DocumentPFE
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentPFE we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentPFEUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentPFEUpsertArgs<ExtArgs>>
    ): Prisma__DocumentPFEClient<$Types.GetResult<DocumentPFEPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of DocumentPFES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPFECountArgs} args - Arguments to filter DocumentPFES to count.
     * @example
     * // Count the number of DocumentPFES
     * const count = await prisma.documentPFE.count({
     *   where: {
     *     // ... the filter for the DocumentPFES we want to count
     *   }
     * })
    **/
    count<T extends DocumentPFECountArgs>(
      args?: Subset<T, DocumentPFECountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentPFECountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentPFE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPFEAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentPFEAggregateArgs>(args: Subset<T, DocumentPFEAggregateArgs>): Prisma.PrismaPromise<GetDocumentPFEAggregateType<T>>

    /**
     * Group by DocumentPFE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPFEGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentPFEGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentPFEGroupByArgs['orderBy'] }
        : { orderBy?: DocumentPFEGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentPFEGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentPFEGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentPFE.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentPFEClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    document<T extends DocumentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentArgs<ExtArgs>>): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DocumentPFE base type for findUnique actions
   */
  export type DocumentPFEFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPFE
     */
    select?: DocumentPFESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentPFEInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPFE to fetch.
     */
    where: DocumentPFEWhereUniqueInput
  }

  /**
   * DocumentPFE findUnique
   */
  export interface DocumentPFEFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentPFEFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DocumentPFE findUniqueOrThrow
   */
  export type DocumentPFEFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPFE
     */
    select?: DocumentPFESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentPFEInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPFE to fetch.
     */
    where: DocumentPFEWhereUniqueInput
  }


  /**
   * DocumentPFE base type for findFirst actions
   */
  export type DocumentPFEFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPFE
     */
    select?: DocumentPFESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentPFEInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPFE to fetch.
     */
    where?: DocumentPFEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPFES to fetch.
     */
    orderBy?: Enumerable<DocumentPFEOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentPFES.
     */
    cursor?: DocumentPFEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPFES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPFES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentPFES.
     */
    distinct?: Enumerable<DocumentPFEScalarFieldEnum>
  }

  /**
   * DocumentPFE findFirst
   */
  export interface DocumentPFEFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentPFEFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DocumentPFE findFirstOrThrow
   */
  export type DocumentPFEFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPFE
     */
    select?: DocumentPFESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentPFEInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPFE to fetch.
     */
    where?: DocumentPFEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPFES to fetch.
     */
    orderBy?: Enumerable<DocumentPFEOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentPFES.
     */
    cursor?: DocumentPFEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPFES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPFES.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentPFES.
     */
    distinct?: Enumerable<DocumentPFEScalarFieldEnum>
  }


  /**
   * DocumentPFE findMany
   */
  export type DocumentPFEFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPFE
     */
    select?: DocumentPFESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentPFEInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPFES to fetch.
     */
    where?: DocumentPFEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPFES to fetch.
     */
    orderBy?: Enumerable<DocumentPFEOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentPFES.
     */
    cursor?: DocumentPFEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPFES from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPFES.
     */
    skip?: number
    distinct?: Enumerable<DocumentPFEScalarFieldEnum>
  }


  /**
   * DocumentPFE create
   */
  export type DocumentPFECreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPFE
     */
    select?: DocumentPFESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentPFEInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentPFE.
     */
    data: XOR<DocumentPFECreateInput, DocumentPFEUncheckedCreateInput>
  }


  /**
   * DocumentPFE createMany
   */
  export type DocumentPFECreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentPFES.
     */
    data: Enumerable<DocumentPFECreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DocumentPFE update
   */
  export type DocumentPFEUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPFE
     */
    select?: DocumentPFESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentPFEInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentPFE.
     */
    data: XOR<DocumentPFEUpdateInput, DocumentPFEUncheckedUpdateInput>
    /**
     * Choose, which DocumentPFE to update.
     */
    where: DocumentPFEWhereUniqueInput
  }


  /**
   * DocumentPFE updateMany
   */
  export type DocumentPFEUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentPFES.
     */
    data: XOR<DocumentPFEUpdateManyMutationInput, DocumentPFEUncheckedUpdateManyInput>
    /**
     * Filter which DocumentPFES to update
     */
    where?: DocumentPFEWhereInput
  }


  /**
   * DocumentPFE upsert
   */
  export type DocumentPFEUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPFE
     */
    select?: DocumentPFESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentPFEInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentPFE to update in case it exists.
     */
    where: DocumentPFEWhereUniqueInput
    /**
     * In case the DocumentPFE found by the `where` argument doesn't exist, create a new DocumentPFE with this data.
     */
    create: XOR<DocumentPFECreateInput, DocumentPFEUncheckedCreateInput>
    /**
     * In case the DocumentPFE was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentPFEUpdateInput, DocumentPFEUncheckedUpdateInput>
  }


  /**
   * DocumentPFE delete
   */
  export type DocumentPFEDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPFE
     */
    select?: DocumentPFESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentPFEInclude<ExtArgs> | null
    /**
     * Filter which DocumentPFE to delete.
     */
    where: DocumentPFEWhereUniqueInput
  }


  /**
   * DocumentPFE deleteMany
   */
  export type DocumentPFEDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentPFES to delete
     */
    where?: DocumentPFEWhereInput
  }


  /**
   * DocumentPFE without action
   */
  export type DocumentPFEArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPFE
     */
    select?: DocumentPFESelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentPFEInclude<ExtArgs> | null
  }



  /**
   * Model Commentaire
   */


  export type AggregateCommentaire = {
    _count: CommentaireCountAggregateOutputType | null
    _min: CommentaireMinAggregateOutputType | null
    _max: CommentaireMaxAggregateOutputType | null
  }

  export type CommentaireMinAggregateOutputType = {
    id: string | null
    contenu: string | null
    documentId: string | null
    userId: string | null
    parentId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    isEdited: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentaireMaxAggregateOutputType = {
    id: string | null
    contenu: string | null
    documentId: string | null
    userId: string | null
    parentId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    isEdited: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentaireCountAggregateOutputType = {
    id: number
    contenu: number
    documentId: number
    userId: number
    parentId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    isEdited: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentaireMinAggregateInputType = {
    id?: true
    contenu?: true
    documentId?: true
    userId?: true
    parentId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    isEdited?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentaireMaxAggregateInputType = {
    id?: true
    contenu?: true
    documentId?: true
    userId?: true
    parentId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    isEdited?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentaireCountAggregateInputType = {
    id?: true
    contenu?: true
    documentId?: true
    userId?: true
    parentId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    isEdited?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentaireAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commentaire to aggregate.
     */
    where?: CommentaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commentaires to fetch.
     */
    orderBy?: Enumerable<CommentaireOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commentaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commentaires
    **/
    _count?: true | CommentaireCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentaireMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentaireMaxAggregateInputType
  }

  export type GetCommentaireAggregateType<T extends CommentaireAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentaire]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentaire[P]>
      : GetScalarType<T[P], AggregateCommentaire[P]>
  }




  export type CommentaireGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentaireWhereInput
    orderBy?: Enumerable<CommentaireOrderByWithAggregationInput>
    by: CommentaireScalarFieldEnum[]
    having?: CommentaireScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentaireCountAggregateInputType | true
    _min?: CommentaireMinAggregateInputType
    _max?: CommentaireMaxAggregateInputType
  }


  export type CommentaireGroupByOutputType = {
    id: string
    contenu: string
    documentId: string
    userId: string
    parentId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    isEdited: boolean
    createdAt: Date
    updatedAt: Date
    _count: CommentaireCountAggregateOutputType | null
    _min: CommentaireMinAggregateOutputType | null
    _max: CommentaireMaxAggregateOutputType | null
  }

  type GetCommentaireGroupByPayload<T extends CommentaireGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommentaireGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentaireGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentaireGroupByOutputType[P]>
            : GetScalarType<T[P], CommentaireGroupByOutputType[P]>
        }
      >
    >


  export type CommentaireSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contenu?: boolean
    documentId?: boolean
    userId?: boolean
    parentId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isEdited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    parent?: boolean | CommentaireArgs<ExtArgs>
    replies?: boolean | Commentaire$repliesArgs<ExtArgs>
    _count?: boolean | CommentaireCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["commentaire"]>

  export type CommentaireSelectScalar = {
    id?: boolean
    contenu?: boolean
    documentId?: boolean
    userId?: boolean
    parentId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    isEdited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentaireInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    parent?: boolean | CommentaireArgs<ExtArgs>
    replies?: boolean | Commentaire$repliesArgs<ExtArgs>
    _count?: boolean | CommentaireCountOutputTypeArgs<ExtArgs>
  }


  type CommentaireGetPayload<S extends boolean | null | undefined | CommentaireArgs> = $Types.GetResult<CommentairePayload, S>

  type CommentaireCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CommentaireFindManyArgs, 'select' | 'include'> & {
      select?: CommentaireCountAggregateInputType | true
    }

  export interface CommentaireDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Commentaire'], meta: { name: 'Commentaire' } }
    /**
     * Find zero or one Commentaire that matches the filter.
     * @param {CommentaireFindUniqueArgs} args - Arguments to find a Commentaire
     * @example
     * // Get one Commentaire
     * const commentaire = await prisma.commentaire.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentaireFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentaireFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Commentaire'> extends True ? Prisma__CommentaireClient<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CommentaireClient<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Commentaire that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentaireFindUniqueOrThrowArgs} args - Arguments to find a Commentaire
     * @example
     * // Get one Commentaire
     * const commentaire = await prisma.commentaire.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentaireFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentaireFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentaireClient<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Commentaire that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireFindFirstArgs} args - Arguments to find a Commentaire
     * @example
     * // Get one Commentaire
     * const commentaire = await prisma.commentaire.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentaireFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentaireFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Commentaire'> extends True ? Prisma__CommentaireClient<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CommentaireClient<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Commentaire that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireFindFirstOrThrowArgs} args - Arguments to find a Commentaire
     * @example
     * // Get one Commentaire
     * const commentaire = await prisma.commentaire.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentaireFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentaireFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentaireClient<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Commentaires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commentaires
     * const commentaires = await prisma.commentaire.findMany()
     * 
     * // Get first 10 Commentaires
     * const commentaires = await prisma.commentaire.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentaireWithIdOnly = await prisma.commentaire.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentaireFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentaireFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Commentaire.
     * @param {CommentaireCreateArgs} args - Arguments to create a Commentaire.
     * @example
     * // Create one Commentaire
     * const Commentaire = await prisma.commentaire.create({
     *   data: {
     *     // ... data to create a Commentaire
     *   }
     * })
     * 
    **/
    create<T extends CommentaireCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentaireCreateArgs<ExtArgs>>
    ): Prisma__CommentaireClient<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Commentaires.
     *     @param {CommentaireCreateManyArgs} args - Arguments to create many Commentaires.
     *     @example
     *     // Create many Commentaires
     *     const commentaire = await prisma.commentaire.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentaireCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentaireCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Commentaire.
     * @param {CommentaireDeleteArgs} args - Arguments to delete one Commentaire.
     * @example
     * // Delete one Commentaire
     * const Commentaire = await prisma.commentaire.delete({
     *   where: {
     *     // ... filter to delete one Commentaire
     *   }
     * })
     * 
    **/
    delete<T extends CommentaireDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentaireDeleteArgs<ExtArgs>>
    ): Prisma__CommentaireClient<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Commentaire.
     * @param {CommentaireUpdateArgs} args - Arguments to update one Commentaire.
     * @example
     * // Update one Commentaire
     * const commentaire = await prisma.commentaire.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentaireUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentaireUpdateArgs<ExtArgs>>
    ): Prisma__CommentaireClient<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Commentaires.
     * @param {CommentaireDeleteManyArgs} args - Arguments to filter Commentaires to delete.
     * @example
     * // Delete a few Commentaires
     * const { count } = await prisma.commentaire.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentaireDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentaireDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commentaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commentaires
     * const commentaire = await prisma.commentaire.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentaireUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentaireUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Commentaire.
     * @param {CommentaireUpsertArgs} args - Arguments to update or create a Commentaire.
     * @example
     * // Update or create a Commentaire
     * const commentaire = await prisma.commentaire.upsert({
     *   create: {
     *     // ... data to create a Commentaire
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commentaire we want to update
     *   }
     * })
    **/
    upsert<T extends CommentaireUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentaireUpsertArgs<ExtArgs>>
    ): Prisma__CommentaireClient<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Commentaires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireCountArgs} args - Arguments to filter Commentaires to count.
     * @example
     * // Count the number of Commentaires
     * const count = await prisma.commentaire.count({
     *   where: {
     *     // ... the filter for the Commentaires we want to count
     *   }
     * })
    **/
    count<T extends CommentaireCountArgs>(
      args?: Subset<T, CommentaireCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentaireCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commentaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentaireAggregateArgs>(args: Subset<T, CommentaireAggregateArgs>): Prisma.PrismaPromise<GetCommentaireAggregateType<T>>

    /**
     * Group by Commentaire.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentaireGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentaireGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentaireGroupByArgs['orderBy'] }
        : { orderBy?: CommentaireGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentaireGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentaireGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Commentaire.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentaireClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    document<T extends DocumentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentArgs<ExtArgs>>): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    parent<T extends CommentaireArgs<ExtArgs> = {}>(args?: Subset<T, CommentaireArgs<ExtArgs>>): Prisma__CommentaireClient<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    replies<T extends Commentaire$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Commentaire$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CommentairePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Commentaire base type for findUnique actions
   */
  export type CommentaireFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaire to fetch.
     */
    where: CommentaireWhereUniqueInput
  }

  /**
   * Commentaire findUnique
   */
  export interface CommentaireFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CommentaireFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Commentaire findUniqueOrThrow
   */
  export type CommentaireFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaire to fetch.
     */
    where: CommentaireWhereUniqueInput
  }


  /**
   * Commentaire base type for findFirst actions
   */
  export type CommentaireFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaire to fetch.
     */
    where?: CommentaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commentaires to fetch.
     */
    orderBy?: Enumerable<CommentaireOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commentaires.
     */
    cursor?: CommentaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commentaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commentaires.
     */
    distinct?: Enumerable<CommentaireScalarFieldEnum>
  }

  /**
   * Commentaire findFirst
   */
  export interface CommentaireFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CommentaireFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Commentaire findFirstOrThrow
   */
  export type CommentaireFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaire to fetch.
     */
    where?: CommentaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commentaires to fetch.
     */
    orderBy?: Enumerable<CommentaireOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commentaires.
     */
    cursor?: CommentaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commentaires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commentaires.
     */
    distinct?: Enumerable<CommentaireScalarFieldEnum>
  }


  /**
   * Commentaire findMany
   */
  export type CommentaireFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter, which Commentaires to fetch.
     */
    where?: CommentaireWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commentaires to fetch.
     */
    orderBy?: Enumerable<CommentaireOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commentaires.
     */
    cursor?: CommentaireWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commentaires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commentaires.
     */
    skip?: number
    distinct?: Enumerable<CommentaireScalarFieldEnum>
  }


  /**
   * Commentaire create
   */
  export type CommentaireCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * The data needed to create a Commentaire.
     */
    data: XOR<CommentaireCreateInput, CommentaireUncheckedCreateInput>
  }


  /**
   * Commentaire createMany
   */
  export type CommentaireCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commentaires.
     */
    data: Enumerable<CommentaireCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Commentaire update
   */
  export type CommentaireUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * The data needed to update a Commentaire.
     */
    data: XOR<CommentaireUpdateInput, CommentaireUncheckedUpdateInput>
    /**
     * Choose, which Commentaire to update.
     */
    where: CommentaireWhereUniqueInput
  }


  /**
   * Commentaire updateMany
   */
  export type CommentaireUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commentaires.
     */
    data: XOR<CommentaireUpdateManyMutationInput, CommentaireUncheckedUpdateManyInput>
    /**
     * Filter which Commentaires to update
     */
    where?: CommentaireWhereInput
  }


  /**
   * Commentaire upsert
   */
  export type CommentaireUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * The filter to search for the Commentaire to update in case it exists.
     */
    where: CommentaireWhereUniqueInput
    /**
     * In case the Commentaire found by the `where` argument doesn't exist, create a new Commentaire with this data.
     */
    create: XOR<CommentaireCreateInput, CommentaireUncheckedCreateInput>
    /**
     * In case the Commentaire was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentaireUpdateInput, CommentaireUncheckedUpdateInput>
  }


  /**
   * Commentaire delete
   */
  export type CommentaireDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    /**
     * Filter which Commentaire to delete.
     */
    where: CommentaireWhereUniqueInput
  }


  /**
   * Commentaire deleteMany
   */
  export type CommentaireDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commentaires to delete
     */
    where?: CommentaireWhereInput
  }


  /**
   * Commentaire.replies
   */
  export type Commentaire$repliesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
    where?: CommentaireWhereInput
    orderBy?: Enumerable<CommentaireOrderByWithRelationInput>
    cursor?: CommentaireWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentaireScalarFieldEnum>
  }


  /**
   * Commentaire without action
   */
  export type CommentaireArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commentaire
     */
    select?: CommentaireSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentaireInclude<ExtArgs> | null
  }



  /**
   * Model AuditLog
   */


  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: AuditAction | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: AuditAction | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    resourceId: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: Enumerable<AuditLogOrderByWithAggregationInput>
    by: AuditLogScalarFieldEnum[]
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }


  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: AuditAction
    resource: string | null
    resourceId: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogArgs> = $Types.GetResult<AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuditLogFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AuditLog'> extends True ? Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuditLogFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AuditLog'> extends True ? Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AuditLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
    **/
    create<T extends AuditLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many AuditLogs.
     *     @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     *     @example
     *     // Create many AuditLogs
     *     const auditLog = await prisma.auditLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AuditLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
    **/
    delete<T extends AuditLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuditLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuditLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuditLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
    **/
    upsert<T extends AuditLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>
    ): Prisma__AuditLogClient<$Types.GetResult<AuditLogPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AuditLog base type for findUnique actions
   */
  export type AuditLogFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUnique
   */
  export interface AuditLogFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AuditLogFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }


  /**
   * AuditLog base type for findFirst actions
   */
  export type AuditLogFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: Enumerable<AuditLogScalarFieldEnum>
  }

  /**
   * AuditLog findFirst
   */
  export interface AuditLogFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AuditLogFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: Enumerable<AuditLogScalarFieldEnum>
  }


  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: Enumerable<AuditLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: Enumerable<AuditLogScalarFieldEnum>
  }


  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }


  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: Enumerable<AuditLogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }


  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }


  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }


  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }


  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }


  /**
   * AuditLog without action
   */
  export type AuditLogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuditLogInclude<ExtArgs> | null
  }



  /**
   * Model DocumentMatiere
   */


  export type AggregateDocumentMatiere = {
    _count: DocumentMatiereCountAggregateOutputType | null
    _min: DocumentMatiereMinAggregateOutputType | null
    _max: DocumentMatiereMaxAggregateOutputType | null
  }

  export type DocumentMatiereMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    matiereId: string | null
    createdAt: Date | null
  }

  export type DocumentMatiereMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    matiereId: string | null
    createdAt: Date | null
  }

  export type DocumentMatiereCountAggregateOutputType = {
    id: number
    documentId: number
    matiereId: number
    createdAt: number
    _all: number
  }


  export type DocumentMatiereMinAggregateInputType = {
    id?: true
    documentId?: true
    matiereId?: true
    createdAt?: true
  }

  export type DocumentMatiereMaxAggregateInputType = {
    id?: true
    documentId?: true
    matiereId?: true
    createdAt?: true
  }

  export type DocumentMatiereCountAggregateInputType = {
    id?: true
    documentId?: true
    matiereId?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentMatiereAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentMatiere to aggregate.
     */
    where?: DocumentMatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentMatieres to fetch.
     */
    orderBy?: Enumerable<DocumentMatiereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentMatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentMatieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentMatieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentMatieres
    **/
    _count?: true | DocumentMatiereCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMatiereMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMatiereMaxAggregateInputType
  }

  export type GetDocumentMatiereAggregateType<T extends DocumentMatiereAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentMatiere]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentMatiere[P]>
      : GetScalarType<T[P], AggregateDocumentMatiere[P]>
  }




  export type DocumentMatiereGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentMatiereWhereInput
    orderBy?: Enumerable<DocumentMatiereOrderByWithAggregationInput>
    by: DocumentMatiereScalarFieldEnum[]
    having?: DocumentMatiereScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentMatiereCountAggregateInputType | true
    _min?: DocumentMatiereMinAggregateInputType
    _max?: DocumentMatiereMaxAggregateInputType
  }


  export type DocumentMatiereGroupByOutputType = {
    id: string
    documentId: string
    matiereId: string
    createdAt: Date
    _count: DocumentMatiereCountAggregateOutputType | null
    _min: DocumentMatiereMinAggregateOutputType | null
    _max: DocumentMatiereMaxAggregateOutputType | null
  }

  type GetDocumentMatiereGroupByPayload<T extends DocumentMatiereGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DocumentMatiereGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentMatiereGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentMatiereGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentMatiereGroupByOutputType[P]>
        }
      >
    >


  export type DocumentMatiereSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    matiereId?: boolean
    createdAt?: boolean
    document?: boolean | DocumentArgs<ExtArgs>
    matiere?: boolean | MatiereArgs<ExtArgs>
  }, ExtArgs["result"]["documentMatiere"]>

  export type DocumentMatiereSelectScalar = {
    id?: boolean
    documentId?: boolean
    matiereId?: boolean
    createdAt?: boolean
  }

  export type DocumentMatiereInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentArgs<ExtArgs>
    matiere?: boolean | MatiereArgs<ExtArgs>
  }


  type DocumentMatiereGetPayload<S extends boolean | null | undefined | DocumentMatiereArgs> = $Types.GetResult<DocumentMatierePayload, S>

  type DocumentMatiereCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DocumentMatiereFindManyArgs, 'select' | 'include'> & {
      select?: DocumentMatiereCountAggregateInputType | true
    }

  export interface DocumentMatiereDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentMatiere'], meta: { name: 'DocumentMatiere' } }
    /**
     * Find zero or one DocumentMatiere that matches the filter.
     * @param {DocumentMatiereFindUniqueArgs} args - Arguments to find a DocumentMatiere
     * @example
     * // Get one DocumentMatiere
     * const documentMatiere = await prisma.documentMatiere.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentMatiereFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentMatiereFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DocumentMatiere'> extends True ? Prisma__DocumentMatiereClient<$Types.GetResult<DocumentMatierePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DocumentMatiereClient<$Types.GetResult<DocumentMatierePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one DocumentMatiere that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentMatiereFindUniqueOrThrowArgs} args - Arguments to find a DocumentMatiere
     * @example
     * // Get one DocumentMatiere
     * const documentMatiere = await prisma.documentMatiere.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentMatiereFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentMatiereFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentMatiereClient<$Types.GetResult<DocumentMatierePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first DocumentMatiere that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentMatiereFindFirstArgs} args - Arguments to find a DocumentMatiere
     * @example
     * // Get one DocumentMatiere
     * const documentMatiere = await prisma.documentMatiere.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentMatiereFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentMatiereFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DocumentMatiere'> extends True ? Prisma__DocumentMatiereClient<$Types.GetResult<DocumentMatierePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DocumentMatiereClient<$Types.GetResult<DocumentMatierePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first DocumentMatiere that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentMatiereFindFirstOrThrowArgs} args - Arguments to find a DocumentMatiere
     * @example
     * // Get one DocumentMatiere
     * const documentMatiere = await prisma.documentMatiere.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentMatiereFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentMatiereFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentMatiereClient<$Types.GetResult<DocumentMatierePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more DocumentMatieres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentMatiereFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentMatieres
     * const documentMatieres = await prisma.documentMatiere.findMany()
     * 
     * // Get first 10 DocumentMatieres
     * const documentMatieres = await prisma.documentMatiere.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentMatiereWithIdOnly = await prisma.documentMatiere.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentMatiereFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentMatiereFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DocumentMatierePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a DocumentMatiere.
     * @param {DocumentMatiereCreateArgs} args - Arguments to create a DocumentMatiere.
     * @example
     * // Create one DocumentMatiere
     * const DocumentMatiere = await prisma.documentMatiere.create({
     *   data: {
     *     // ... data to create a DocumentMatiere
     *   }
     * })
     * 
    **/
    create<T extends DocumentMatiereCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentMatiereCreateArgs<ExtArgs>>
    ): Prisma__DocumentMatiereClient<$Types.GetResult<DocumentMatierePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many DocumentMatieres.
     *     @param {DocumentMatiereCreateManyArgs} args - Arguments to create many DocumentMatieres.
     *     @example
     *     // Create many DocumentMatieres
     *     const documentMatiere = await prisma.documentMatiere.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentMatiereCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentMatiereCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentMatiere.
     * @param {DocumentMatiereDeleteArgs} args - Arguments to delete one DocumentMatiere.
     * @example
     * // Delete one DocumentMatiere
     * const DocumentMatiere = await prisma.documentMatiere.delete({
     *   where: {
     *     // ... filter to delete one DocumentMatiere
     *   }
     * })
     * 
    **/
    delete<T extends DocumentMatiereDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentMatiereDeleteArgs<ExtArgs>>
    ): Prisma__DocumentMatiereClient<$Types.GetResult<DocumentMatierePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one DocumentMatiere.
     * @param {DocumentMatiereUpdateArgs} args - Arguments to update one DocumentMatiere.
     * @example
     * // Update one DocumentMatiere
     * const documentMatiere = await prisma.documentMatiere.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentMatiereUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentMatiereUpdateArgs<ExtArgs>>
    ): Prisma__DocumentMatiereClient<$Types.GetResult<DocumentMatierePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more DocumentMatieres.
     * @param {DocumentMatiereDeleteManyArgs} args - Arguments to filter DocumentMatieres to delete.
     * @example
     * // Delete a few DocumentMatieres
     * const { count } = await prisma.documentMatiere.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentMatiereDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentMatiereDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentMatieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentMatiereUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentMatieres
     * const documentMatiere = await prisma.documentMatiere.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentMatiereUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentMatiereUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentMatiere.
     * @param {DocumentMatiereUpsertArgs} args - Arguments to update or create a DocumentMatiere.
     * @example
     * // Update or create a DocumentMatiere
     * const documentMatiere = await prisma.documentMatiere.upsert({
     *   create: {
     *     // ... data to create a DocumentMatiere
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentMatiere we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentMatiereUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentMatiereUpsertArgs<ExtArgs>>
    ): Prisma__DocumentMatiereClient<$Types.GetResult<DocumentMatierePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of DocumentMatieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentMatiereCountArgs} args - Arguments to filter DocumentMatieres to count.
     * @example
     * // Count the number of DocumentMatieres
     * const count = await prisma.documentMatiere.count({
     *   where: {
     *     // ... the filter for the DocumentMatieres we want to count
     *   }
     * })
    **/
    count<T extends DocumentMatiereCountArgs>(
      args?: Subset<T, DocumentMatiereCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentMatiereCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentMatiere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentMatiereAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentMatiereAggregateArgs>(args: Subset<T, DocumentMatiereAggregateArgs>): Prisma.PrismaPromise<GetDocumentMatiereAggregateType<T>>

    /**
     * Group by DocumentMatiere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentMatiereGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentMatiereGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentMatiereGroupByArgs['orderBy'] }
        : { orderBy?: DocumentMatiereGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentMatiereGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentMatiereGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentMatiere.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentMatiereClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    document<T extends DocumentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentArgs<ExtArgs>>): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    matiere<T extends MatiereArgs<ExtArgs> = {}>(args?: Subset<T, MatiereArgs<ExtArgs>>): Prisma__MatiereClient<$Types.GetResult<MatierePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DocumentMatiere base type for findUnique actions
   */
  export type DocumentMatiereFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMatiere
     */
    select?: DocumentMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentMatiereInclude<ExtArgs> | null
    /**
     * Filter, which DocumentMatiere to fetch.
     */
    where: DocumentMatiereWhereUniqueInput
  }

  /**
   * DocumentMatiere findUnique
   */
  export interface DocumentMatiereFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentMatiereFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DocumentMatiere findUniqueOrThrow
   */
  export type DocumentMatiereFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMatiere
     */
    select?: DocumentMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentMatiereInclude<ExtArgs> | null
    /**
     * Filter, which DocumentMatiere to fetch.
     */
    where: DocumentMatiereWhereUniqueInput
  }


  /**
   * DocumentMatiere base type for findFirst actions
   */
  export type DocumentMatiereFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMatiere
     */
    select?: DocumentMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentMatiereInclude<ExtArgs> | null
    /**
     * Filter, which DocumentMatiere to fetch.
     */
    where?: DocumentMatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentMatieres to fetch.
     */
    orderBy?: Enumerable<DocumentMatiereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentMatieres.
     */
    cursor?: DocumentMatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentMatieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentMatieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentMatieres.
     */
    distinct?: Enumerable<DocumentMatiereScalarFieldEnum>
  }

  /**
   * DocumentMatiere findFirst
   */
  export interface DocumentMatiereFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentMatiereFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DocumentMatiere findFirstOrThrow
   */
  export type DocumentMatiereFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMatiere
     */
    select?: DocumentMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentMatiereInclude<ExtArgs> | null
    /**
     * Filter, which DocumentMatiere to fetch.
     */
    where?: DocumentMatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentMatieres to fetch.
     */
    orderBy?: Enumerable<DocumentMatiereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentMatieres.
     */
    cursor?: DocumentMatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentMatieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentMatieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentMatieres.
     */
    distinct?: Enumerable<DocumentMatiereScalarFieldEnum>
  }


  /**
   * DocumentMatiere findMany
   */
  export type DocumentMatiereFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMatiere
     */
    select?: DocumentMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentMatiereInclude<ExtArgs> | null
    /**
     * Filter, which DocumentMatieres to fetch.
     */
    where?: DocumentMatiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentMatieres to fetch.
     */
    orderBy?: Enumerable<DocumentMatiereOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentMatieres.
     */
    cursor?: DocumentMatiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentMatieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentMatieres.
     */
    skip?: number
    distinct?: Enumerable<DocumentMatiereScalarFieldEnum>
  }


  /**
   * DocumentMatiere create
   */
  export type DocumentMatiereCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMatiere
     */
    select?: DocumentMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentMatiereInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentMatiere.
     */
    data: XOR<DocumentMatiereCreateInput, DocumentMatiereUncheckedCreateInput>
  }


  /**
   * DocumentMatiere createMany
   */
  export type DocumentMatiereCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentMatieres.
     */
    data: Enumerable<DocumentMatiereCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DocumentMatiere update
   */
  export type DocumentMatiereUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMatiere
     */
    select?: DocumentMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentMatiereInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentMatiere.
     */
    data: XOR<DocumentMatiereUpdateInput, DocumentMatiereUncheckedUpdateInput>
    /**
     * Choose, which DocumentMatiere to update.
     */
    where: DocumentMatiereWhereUniqueInput
  }


  /**
   * DocumentMatiere updateMany
   */
  export type DocumentMatiereUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentMatieres.
     */
    data: XOR<DocumentMatiereUpdateManyMutationInput, DocumentMatiereUncheckedUpdateManyInput>
    /**
     * Filter which DocumentMatieres to update
     */
    where?: DocumentMatiereWhereInput
  }


  /**
   * DocumentMatiere upsert
   */
  export type DocumentMatiereUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMatiere
     */
    select?: DocumentMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentMatiereInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentMatiere to update in case it exists.
     */
    where: DocumentMatiereWhereUniqueInput
    /**
     * In case the DocumentMatiere found by the `where` argument doesn't exist, create a new DocumentMatiere with this data.
     */
    create: XOR<DocumentMatiereCreateInput, DocumentMatiereUncheckedCreateInput>
    /**
     * In case the DocumentMatiere was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentMatiereUpdateInput, DocumentMatiereUncheckedUpdateInput>
  }


  /**
   * DocumentMatiere delete
   */
  export type DocumentMatiereDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMatiere
     */
    select?: DocumentMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentMatiereInclude<ExtArgs> | null
    /**
     * Filter which DocumentMatiere to delete.
     */
    where: DocumentMatiereWhereUniqueInput
  }


  /**
   * DocumentMatiere deleteMany
   */
  export type DocumentMatiereDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentMatieres to delete
     */
    where?: DocumentMatiereWhereInput
  }


  /**
   * DocumentMatiere without action
   */
  export type DocumentMatiereArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentMatiere
     */
    select?: DocumentMatiereSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentMatiereInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    prenom: 'prenom',
    nom: 'nom',
    role: 'role',
    isActive: 'isActive',
    filiereId: 'filiereId',
    niveauId: 'niveauId',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const NiveauScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    type: 'type',
    ordre: 'ordre'
  };

  export type NiveauScalarFieldEnum = (typeof NiveauScalarFieldEnum)[keyof typeof NiveauScalarFieldEnum]


  export const FiliereScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    code: 'code',
    niveauId: 'niveauId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt'
  };

  export type FiliereScalarFieldEnum = (typeof FiliereScalarFieldEnum)[keyof typeof FiliereScalarFieldEnum]


  export const SemestreScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    niveauId: 'niveauId',
    ordre: 'ordre'
  };

  export type SemestreScalarFieldEnum = (typeof SemestreScalarFieldEnum)[keyof typeof SemestreScalarFieldEnum]


  export const MatiereScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    code: 'code',
    filiereId: 'filiereId',
    semestreId: 'semestreId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt'
  };

  export type MatiereScalarFieldEnum = (typeof MatiereScalarFieldEnum)[keyof typeof MatiereScalarFieldEnum]


  export const ProfesseurMatiereScalarFieldEnum: {
    id: 'id',
    professeurId: 'professeurId',
    matiereId: 'matiereId',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type ProfesseurMatiereScalarFieldEnum = (typeof ProfesseurMatiereScalarFieldEnum)[keyof typeof ProfesseurMatiereScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    titre: 'titre',
    description: 'description',
    cheminFichier: 'cheminFichier',
    nomFichier: 'nomFichier',
    tailleFichier: 'tailleFichier',
    typeMime: 'typeMime',
    categorie: 'categorie',
    matiereId: 'matiereId',
    telchargePar: 'telchargePar',
    correctionId: 'correctionId',
    downloadCount: 'downloadCount',
    viewCount: 'viewCount',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DocumentPFEScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    anneeDiplome: 'anneeDiplome',
    filiereDiplome: 'filiereDiplome',
    titreProjet: 'titreProjet',
    resume: 'resume',
    motsCles: 'motsCles',
    createdAt: 'createdAt'
  };

  export type DocumentPFEScalarFieldEnum = (typeof DocumentPFEScalarFieldEnum)[keyof typeof DocumentPFEScalarFieldEnum]


  export const CommentaireScalarFieldEnum: {
    id: 'id',
    contenu: 'contenu',
    documentId: 'documentId',
    userId: 'userId',
    parentId: 'parentId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    isEdited: 'isEdited',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentaireScalarFieldEnum = (typeof CommentaireScalarFieldEnum)[keyof typeof CommentaireScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const DocumentMatiereScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    matiereId: 'matiereId',
    createdAt: 'createdAt'
  };

  export type DocumentMatiereScalarFieldEnum = (typeof DocumentMatiereScalarFieldEnum)[keyof typeof DocumentMatiereScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    prenom?: StringFilter | string
    nom?: StringFilter | string
    role?: EnumUserRoleFilter | UserRole
    isActive?: BoolFilter | boolean
    filiereId?: StringNullableFilter | string | null
    niveauId?: StringNullableFilter | string | null
    resetToken?: StringNullableFilter | string | null
    resetTokenExpiry?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    filiere?: XOR<FiliereRelationFilter, FiliereWhereInput> | null
    niveau?: XOR<NiveauRelationFilter, NiveauWhereInput> | null
    documents?: DocumentListRelationFilter
    deletedDocuments?: DocumentListRelationFilter
    commentaires?: CommentaireListRelationFilter
    professeurMatieres?: ProfesseurMatiereListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    filiereId?: SortOrderInput | SortOrder
    niveauId?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    filiere?: FiliereOrderByWithRelationInput
    niveau?: NiveauOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    deletedDocuments?: DocumentOrderByRelationAggregateInput
    commentaires?: CommentaireOrderByRelationAggregateInput
    professeurMatieres?: ProfesseurMatiereOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    filiereId?: SortOrderInput | SortOrder
    niveauId?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    prenom?: StringWithAggregatesFilter | string
    nom?: StringWithAggregatesFilter | string
    role?: EnumUserRoleWithAggregatesFilter | UserRole
    isActive?: BoolWithAggregatesFilter | boolean
    filiereId?: StringNullableWithAggregatesFilter | string | null
    niveauId?: StringNullableWithAggregatesFilter | string | null
    resetToken?: StringNullableWithAggregatesFilter | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type NiveauWhereInput = {
    AND?: Enumerable<NiveauWhereInput>
    OR?: Enumerable<NiveauWhereInput>
    NOT?: Enumerable<NiveauWhereInput>
    id?: StringFilter | string
    nom?: StringFilter | string
    type?: EnumNiveauTypeFilter | NiveauType
    ordre?: IntFilter | number
    filieres?: FiliereListRelationFilter
    semestres?: SemestreListRelationFilter
    users?: UserListRelationFilter
  }

  export type NiveauOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    ordre?: SortOrder
    filieres?: FiliereOrderByRelationAggregateInput
    semestres?: SemestreOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type NiveauWhereUniqueInput = {
    id?: string
    nom?: string
    ordre?: number
  }

  export type NiveauOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    ordre?: SortOrder
    _count?: NiveauCountOrderByAggregateInput
    _avg?: NiveauAvgOrderByAggregateInput
    _max?: NiveauMaxOrderByAggregateInput
    _min?: NiveauMinOrderByAggregateInput
    _sum?: NiveauSumOrderByAggregateInput
  }

  export type NiveauScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NiveauScalarWhereWithAggregatesInput>
    OR?: Enumerable<NiveauScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NiveauScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nom?: StringWithAggregatesFilter | string
    type?: EnumNiveauTypeWithAggregatesFilter | NiveauType
    ordre?: IntWithAggregatesFilter | number
  }

  export type FiliereWhereInput = {
    AND?: Enumerable<FiliereWhereInput>
    OR?: Enumerable<FiliereWhereInput>
    NOT?: Enumerable<FiliereWhereInput>
    id?: StringFilter | string
    nom?: StringFilter | string
    code?: StringFilter | string
    niveauId?: StringFilter | string
    isDeleted?: BoolFilter | boolean
    deletedAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    niveau?: XOR<NiveauRelationFilter, NiveauWhereInput>
    matieres?: MatiereListRelationFilter
    users?: UserListRelationFilter
  }

  export type FiliereOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    niveauId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    niveau?: NiveauOrderByWithRelationInput
    matieres?: MatiereOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type FiliereWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type FiliereOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    niveauId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FiliereCountOrderByAggregateInput
    _max?: FiliereMaxOrderByAggregateInput
    _min?: FiliereMinOrderByAggregateInput
  }

  export type FiliereScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FiliereScalarWhereWithAggregatesInput>
    OR?: Enumerable<FiliereScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FiliereScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nom?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    niveauId?: StringWithAggregatesFilter | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SemestreWhereInput = {
    AND?: Enumerable<SemestreWhereInput>
    OR?: Enumerable<SemestreWhereInput>
    NOT?: Enumerable<SemestreWhereInput>
    id?: StringFilter | string
    nom?: StringFilter | string
    niveauId?: StringFilter | string
    ordre?: IntFilter | number
    niveau?: XOR<NiveauRelationFilter, NiveauWhereInput>
    matieres?: MatiereListRelationFilter
  }

  export type SemestreOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    niveauId?: SortOrder
    ordre?: SortOrder
    niveau?: NiveauOrderByWithRelationInput
    matieres?: MatiereOrderByRelationAggregateInput
  }

  export type SemestreWhereUniqueInput = {
    id?: string
    niveauId_ordre?: SemestreNiveauIdOrdreCompoundUniqueInput
  }

  export type SemestreOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    niveauId?: SortOrder
    ordre?: SortOrder
    _count?: SemestreCountOrderByAggregateInput
    _avg?: SemestreAvgOrderByAggregateInput
    _max?: SemestreMaxOrderByAggregateInput
    _min?: SemestreMinOrderByAggregateInput
    _sum?: SemestreSumOrderByAggregateInput
  }

  export type SemestreScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SemestreScalarWhereWithAggregatesInput>
    OR?: Enumerable<SemestreScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SemestreScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nom?: StringWithAggregatesFilter | string
    niveauId?: StringWithAggregatesFilter | string
    ordre?: IntWithAggregatesFilter | number
  }

  export type MatiereWhereInput = {
    AND?: Enumerable<MatiereWhereInput>
    OR?: Enumerable<MatiereWhereInput>
    NOT?: Enumerable<MatiereWhereInput>
    id?: StringFilter | string
    nom?: StringFilter | string
    code?: StringFilter | string
    filiereId?: StringFilter | string
    semestreId?: StringFilter | string
    isDeleted?: BoolFilter | boolean
    deletedAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    filiere?: XOR<FiliereRelationFilter, FiliereWhereInput>
    semestre?: XOR<SemestreRelationFilter, SemestreWhereInput>
    documents?: DocumentListRelationFilter
    documentMatieres?: DocumentMatiereListRelationFilter
    professeurMatieres?: ProfesseurMatiereListRelationFilter
  }

  export type MatiereOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    filiereId?: SortOrder
    semestreId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    filiere?: FiliereOrderByWithRelationInput
    semestre?: SemestreOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
    documentMatieres?: DocumentMatiereOrderByRelationAggregateInput
    professeurMatieres?: ProfesseurMatiereOrderByRelationAggregateInput
  }

  export type MatiereWhereUniqueInput = {
    id?: string
    code_filiereId?: MatiereCodeFiliereIdCompoundUniqueInput
  }

  export type MatiereOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    filiereId?: SortOrder
    semestreId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MatiereCountOrderByAggregateInput
    _max?: MatiereMaxOrderByAggregateInput
    _min?: MatiereMinOrderByAggregateInput
  }

  export type MatiereScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MatiereScalarWhereWithAggregatesInput>
    OR?: Enumerable<MatiereScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MatiereScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nom?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    filiereId?: StringWithAggregatesFilter | string
    semestreId?: StringWithAggregatesFilter | string
    isDeleted?: BoolWithAggregatesFilter | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ProfesseurMatiereWhereInput = {
    AND?: Enumerable<ProfesseurMatiereWhereInput>
    OR?: Enumerable<ProfesseurMatiereWhereInput>
    NOT?: Enumerable<ProfesseurMatiereWhereInput>
    id?: StringFilter | string
    professeurId?: StringFilter | string
    matiereId?: StringFilter | string
    role?: EnumProfesseurRoleFilter | ProfesseurRole
    createdAt?: DateTimeFilter | Date | string
    professeur?: XOR<UserRelationFilter, UserWhereInput>
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput>
  }

  export type ProfesseurMatiereOrderByWithRelationInput = {
    id?: SortOrder
    professeurId?: SortOrder
    matiereId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    professeur?: UserOrderByWithRelationInput
    matiere?: MatiereOrderByWithRelationInput
  }

  export type ProfesseurMatiereWhereUniqueInput = {
    id?: string
    matiereId_role?: ProfesseurMatiereMatiereIdRoleCompoundUniqueInput
  }

  export type ProfesseurMatiereOrderByWithAggregationInput = {
    id?: SortOrder
    professeurId?: SortOrder
    matiereId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: ProfesseurMatiereCountOrderByAggregateInput
    _max?: ProfesseurMatiereMaxOrderByAggregateInput
    _min?: ProfesseurMatiereMinOrderByAggregateInput
  }

  export type ProfesseurMatiereScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProfesseurMatiereScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProfesseurMatiereScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProfesseurMatiereScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    professeurId?: StringWithAggregatesFilter | string
    matiereId?: StringWithAggregatesFilter | string
    role?: EnumProfesseurRoleWithAggregatesFilter | ProfesseurRole
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DocumentWhereInput = {
    AND?: Enumerable<DocumentWhereInput>
    OR?: Enumerable<DocumentWhereInput>
    NOT?: Enumerable<DocumentWhereInput>
    id?: StringFilter | string
    titre?: StringFilter | string
    description?: StringNullableFilter | string | null
    cheminFichier?: StringFilter | string
    nomFichier?: StringFilter | string
    tailleFichier?: BigIntFilter | bigint | number
    typeMime?: StringFilter | string
    categorie?: EnumDocumentCategorieFilter | DocumentCategorie
    matiereId?: StringNullableFilter | string | null
    telchargePar?: StringFilter | string
    correctionId?: StringNullableFilter | string | null
    downloadCount?: IntFilter | number
    viewCount?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput> | null
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    deleter?: XOR<UserRelationFilter, UserWhereInput> | null
    commentaires?: CommentaireListRelationFilter
    documentPFE?: XOR<DocumentPFERelationFilter, DocumentPFEWhereInput> | null
    documentMatieres?: DocumentMatiereListRelationFilter
    correctionPour?: XOR<DocumentRelationFilter, DocumentWhereInput> | null
    correction?: XOR<DocumentRelationFilter, DocumentWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    titre?: SortOrder
    description?: SortOrderInput | SortOrder
    cheminFichier?: SortOrder
    nomFichier?: SortOrder
    tailleFichier?: SortOrder
    typeMime?: SortOrder
    categorie?: SortOrder
    matiereId?: SortOrderInput | SortOrder
    telchargePar?: SortOrder
    correctionId?: SortOrderInput | SortOrder
    downloadCount?: SortOrder
    viewCount?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    matiere?: MatiereOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
    deleter?: UserOrderByWithRelationInput
    commentaires?: CommentaireOrderByRelationAggregateInput
    documentPFE?: DocumentPFEOrderByWithRelationInput
    documentMatieres?: DocumentMatiereOrderByRelationAggregateInput
    correctionPour?: DocumentOrderByWithRelationInput
    correction?: DocumentOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = {
    id?: string
    correctionId?: string
  }

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    titre?: SortOrder
    description?: SortOrderInput | SortOrder
    cheminFichier?: SortOrder
    nomFichier?: SortOrder
    tailleFichier?: SortOrder
    typeMime?: SortOrder
    categorie?: SortOrder
    matiereId?: SortOrderInput | SortOrder
    telchargePar?: SortOrder
    correctionId?: SortOrderInput | SortOrder
    downloadCount?: SortOrder
    viewCount?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    titre?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    cheminFichier?: StringWithAggregatesFilter | string
    nomFichier?: StringWithAggregatesFilter | string
    tailleFichier?: BigIntWithAggregatesFilter | bigint | number
    typeMime?: StringWithAggregatesFilter | string
    categorie?: EnumDocumentCategorieWithAggregatesFilter | DocumentCategorie
    matiereId?: StringNullableWithAggregatesFilter | string | null
    telchargePar?: StringWithAggregatesFilter | string
    correctionId?: StringNullableWithAggregatesFilter | string | null
    downloadCount?: IntWithAggregatesFilter | number
    viewCount?: IntWithAggregatesFilter | number
    isDeleted?: BoolWithAggregatesFilter | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DocumentPFEWhereInput = {
    AND?: Enumerable<DocumentPFEWhereInput>
    OR?: Enumerable<DocumentPFEWhereInput>
    NOT?: Enumerable<DocumentPFEWhereInput>
    id?: StringFilter | string
    documentId?: StringFilter | string
    anneeDiplome?: IntFilter | number
    filiereDiplome?: StringFilter | string
    titreProjet?: StringFilter | string
    resume?: StringNullableFilter | string | null
    motsCles?: StringNullableListFilter
    createdAt?: DateTimeFilter | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
  }

  export type DocumentPFEOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    anneeDiplome?: SortOrder
    filiereDiplome?: SortOrder
    titreProjet?: SortOrder
    resume?: SortOrderInput | SortOrder
    motsCles?: SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
  }

  export type DocumentPFEWhereUniqueInput = {
    id?: string
    documentId?: string
  }

  export type DocumentPFEOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    anneeDiplome?: SortOrder
    filiereDiplome?: SortOrder
    titreProjet?: SortOrder
    resume?: SortOrderInput | SortOrder
    motsCles?: SortOrder
    createdAt?: SortOrder
    _count?: DocumentPFECountOrderByAggregateInput
    _avg?: DocumentPFEAvgOrderByAggregateInput
    _max?: DocumentPFEMaxOrderByAggregateInput
    _min?: DocumentPFEMinOrderByAggregateInput
    _sum?: DocumentPFESumOrderByAggregateInput
  }

  export type DocumentPFEScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentPFEScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentPFEScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentPFEScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    documentId?: StringWithAggregatesFilter | string
    anneeDiplome?: IntWithAggregatesFilter | number
    filiereDiplome?: StringWithAggregatesFilter | string
    titreProjet?: StringWithAggregatesFilter | string
    resume?: StringNullableWithAggregatesFilter | string | null
    motsCles?: StringNullableListFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CommentaireWhereInput = {
    AND?: Enumerable<CommentaireWhereInput>
    OR?: Enumerable<CommentaireWhereInput>
    NOT?: Enumerable<CommentaireWhereInput>
    id?: StringFilter | string
    contenu?: StringFilter | string
    documentId?: StringFilter | string
    userId?: StringFilter | string
    parentId?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isEdited?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<CommentaireRelationFilter, CommentaireWhereInput> | null
    replies?: CommentaireListRelationFilter
  }

  export type CommentaireOrderByWithRelationInput = {
    id?: SortOrder
    contenu?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    parent?: CommentaireOrderByWithRelationInput
    replies?: CommentaireOrderByRelationAggregateInput
  }

  export type CommentaireWhereUniqueInput = {
    id?: string
  }

  export type CommentaireOrderByWithAggregationInput = {
    id?: SortOrder
    contenu?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentaireCountOrderByAggregateInput
    _max?: CommentaireMaxOrderByAggregateInput
    _min?: CommentaireMinOrderByAggregateInput
  }

  export type CommentaireScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentaireScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentaireScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentaireScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    contenu?: StringWithAggregatesFilter | string
    documentId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    parentId?: StringNullableWithAggregatesFilter | string | null
    isDeleted?: BoolWithAggregatesFilter | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter | string | null
    isEdited?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: Enumerable<AuditLogWhereInput>
    OR?: Enumerable<AuditLogWhereInput>
    NOT?: Enumerable<AuditLogWhereInput>
    id?: StringFilter | string
    userId?: StringNullableFilter | string | null
    action?: EnumAuditActionFilter | AuditAction
    resource?: StringNullableFilter | string | null
    resourceId?: StringNullableFilter | string | null
    details?: JsonNullableFilter
    ipAddress?: StringNullableFilter | string | null
    userAgent?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = {
    id?: string
  }

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AuditLogScalarWhereWithAggregatesInput>
    OR?: Enumerable<AuditLogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AuditLogScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringNullableWithAggregatesFilter | string | null
    action?: EnumAuditActionWithAggregatesFilter | AuditAction
    resource?: StringNullableWithAggregatesFilter | string | null
    resourceId?: StringNullableWithAggregatesFilter | string | null
    details?: JsonNullableWithAggregatesFilter
    ipAddress?: StringNullableWithAggregatesFilter | string | null
    userAgent?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DocumentMatiereWhereInput = {
    AND?: Enumerable<DocumentMatiereWhereInput>
    OR?: Enumerable<DocumentMatiereWhereInput>
    NOT?: Enumerable<DocumentMatiereWhereInput>
    id?: StringFilter | string
    documentId?: StringFilter | string
    matiereId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    matiere?: XOR<MatiereRelationFilter, MatiereWhereInput>
  }

  export type DocumentMatiereOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    matiereId?: SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    matiere?: MatiereOrderByWithRelationInput
  }

  export type DocumentMatiereWhereUniqueInput = {
    id?: string
    documentId_matiereId?: DocumentMatiereDocumentIdMatiereIdCompoundUniqueInput
  }

  export type DocumentMatiereOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    matiereId?: SortOrder
    createdAt?: SortOrder
    _count?: DocumentMatiereCountOrderByAggregateInput
    _max?: DocumentMatiereMaxOrderByAggregateInput
    _min?: DocumentMatiereMinOrderByAggregateInput
  }

  export type DocumentMatiereScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentMatiereScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentMatiereScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentMatiereScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    documentId?: StringWithAggregatesFilter | string
    matiereId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    filiere?: FiliereCreateNestedOneWithoutUsersInput
    niveau?: NiveauCreateNestedOneWithoutUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentCreateNestedManyWithoutDeleterInput
    commentaires?: CommentaireCreateNestedManyWithoutUserInput
    professeurMatieres?: ProfesseurMatiereCreateNestedManyWithoutProfesseurInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    filiereId?: string | null
    niveauId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentUncheckedCreateNestedManyWithoutDeleterInput
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutUserInput
    professeurMatieres?: ProfesseurMatiereUncheckedCreateNestedManyWithoutProfesseurInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filiere?: FiliereUpdateOneWithoutUsersNestedInput
    niveau?: NiveauUpdateOneWithoutUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUpdateManyWithoutDeleterNestedInput
    commentaires?: CommentaireUpdateManyWithoutUserNestedInput
    professeurMatieres?: ProfesseurMatiereUpdateManyWithoutProfesseurNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    filiereId?: NullableStringFieldUpdateOperationsInput | string | null
    niveauId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUncheckedUpdateManyWithoutDeleterNestedInput
    commentaires?: CommentaireUncheckedUpdateManyWithoutUserNestedInput
    professeurMatieres?: ProfesseurMatiereUncheckedUpdateManyWithoutProfesseurNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    filiereId?: string | null
    niveauId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    filiereId?: NullableStringFieldUpdateOperationsInput | string | null
    niveauId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NiveauCreateInput = {
    id?: string
    nom: string
    type: NiveauType
    ordre: number
    filieres?: FiliereCreateNestedManyWithoutNiveauInput
    semestres?: SemestreCreateNestedManyWithoutNiveauInput
    users?: UserCreateNestedManyWithoutNiveauInput
  }

  export type NiveauUncheckedCreateInput = {
    id?: string
    nom: string
    type: NiveauType
    ordre: number
    filieres?: FiliereUncheckedCreateNestedManyWithoutNiveauInput
    semestres?: SemestreUncheckedCreateNestedManyWithoutNiveauInput
    users?: UserUncheckedCreateNestedManyWithoutNiveauInput
  }

  export type NiveauUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumNiveauTypeFieldUpdateOperationsInput | NiveauType
    ordre?: IntFieldUpdateOperationsInput | number
    filieres?: FiliereUpdateManyWithoutNiveauNestedInput
    semestres?: SemestreUpdateManyWithoutNiveauNestedInput
    users?: UserUpdateManyWithoutNiveauNestedInput
  }

  export type NiveauUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumNiveauTypeFieldUpdateOperationsInput | NiveauType
    ordre?: IntFieldUpdateOperationsInput | number
    filieres?: FiliereUncheckedUpdateManyWithoutNiveauNestedInput
    semestres?: SemestreUncheckedUpdateManyWithoutNiveauNestedInput
    users?: UserUncheckedUpdateManyWithoutNiveauNestedInput
  }

  export type NiveauCreateManyInput = {
    id?: string
    nom: string
    type: NiveauType
    ordre: number
  }

  export type NiveauUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumNiveauTypeFieldUpdateOperationsInput | NiveauType
    ordre?: IntFieldUpdateOperationsInput | number
  }

  export type NiveauUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumNiveauTypeFieldUpdateOperationsInput | NiveauType
    ordre?: IntFieldUpdateOperationsInput | number
  }

  export type FiliereCreateInput = {
    id?: string
    nom: string
    code: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    niveau: NiveauCreateNestedOneWithoutFilieresInput
    matieres?: MatiereCreateNestedManyWithoutFiliereInput
    users?: UserCreateNestedManyWithoutFiliereInput
  }

  export type FiliereUncheckedCreateInput = {
    id?: string
    nom: string
    code: string
    niveauId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    matieres?: MatiereUncheckedCreateNestedManyWithoutFiliereInput
    users?: UserUncheckedCreateNestedManyWithoutFiliereInput
  }

  export type FiliereUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    niveau?: NiveauUpdateOneRequiredWithoutFilieresNestedInput
    matieres?: MatiereUpdateManyWithoutFiliereNestedInput
    users?: UserUpdateManyWithoutFiliereNestedInput
  }

  export type FiliereUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveauId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matieres?: MatiereUncheckedUpdateManyWithoutFiliereNestedInput
    users?: UserUncheckedUpdateManyWithoutFiliereNestedInput
  }

  export type FiliereCreateManyInput = {
    id?: string
    nom: string
    code: string
    niveauId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type FiliereUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiliereUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveauId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SemestreCreateInput = {
    id?: string
    nom: string
    ordre: number
    niveau: NiveauCreateNestedOneWithoutSemestresInput
    matieres?: MatiereCreateNestedManyWithoutSemestreInput
  }

  export type SemestreUncheckedCreateInput = {
    id?: string
    nom: string
    niveauId: string
    ordre: number
    matieres?: MatiereUncheckedCreateNestedManyWithoutSemestreInput
  }

  export type SemestreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    niveau?: NiveauUpdateOneRequiredWithoutSemestresNestedInput
    matieres?: MatiereUpdateManyWithoutSemestreNestedInput
  }

  export type SemestreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    niveauId?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    matieres?: MatiereUncheckedUpdateManyWithoutSemestreNestedInput
  }

  export type SemestreCreateManyInput = {
    id?: string
    nom: string
    niveauId: string
    ordre: number
  }

  export type SemestreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
  }

  export type SemestreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    niveauId?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
  }

  export type MatiereCreateInput = {
    id?: string
    nom: string
    code: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    filiere: FiliereCreateNestedOneWithoutMatieresInput
    semestre: SemestreCreateNestedOneWithoutMatieresInput
    documents?: DocumentCreateNestedManyWithoutMatiereInput
    documentMatieres?: DocumentMatiereCreateNestedManyWithoutMatiereInput
    professeurMatieres?: ProfesseurMatiereCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateInput = {
    id?: string
    nom: string
    code: string
    filiereId: string
    semestreId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutMatiereInput
    documentMatieres?: DocumentMatiereUncheckedCreateNestedManyWithoutMatiereInput
    professeurMatieres?: ProfesseurMatiereUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filiere?: FiliereUpdateOneRequiredWithoutMatieresNestedInput
    semestre?: SemestreUpdateOneRequiredWithoutMatieresNestedInput
    documents?: DocumentUpdateManyWithoutMatiereNestedInput
    documentMatieres?: DocumentMatiereUpdateManyWithoutMatiereNestedInput
    professeurMatieres?: ProfesseurMatiereUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    filiereId?: StringFieldUpdateOperationsInput | string
    semestreId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutMatiereNestedInput
    documentMatieres?: DocumentMatiereUncheckedUpdateManyWithoutMatiereNestedInput
    professeurMatieres?: ProfesseurMatiereUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereCreateManyInput = {
    id?: string
    nom: string
    code: string
    filiereId: string
    semestreId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MatiereUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatiereUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    filiereId?: StringFieldUpdateOperationsInput | string
    semestreId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfesseurMatiereCreateInput = {
    id?: string
    role: ProfesseurRole
    createdAt?: Date | string
    professeur: UserCreateNestedOneWithoutProfesseurMatieresInput
    matiere: MatiereCreateNestedOneWithoutProfesseurMatieresInput
  }

  export type ProfesseurMatiereUncheckedCreateInput = {
    id?: string
    professeurId: string
    matiereId: string
    role: ProfesseurRole
    createdAt?: Date | string
  }

  export type ProfesseurMatiereUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProfesseurRoleFieldUpdateOperationsInput | ProfesseurRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    professeur?: UserUpdateOneRequiredWithoutProfesseurMatieresNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutProfesseurMatieresNestedInput
  }

  export type ProfesseurMatiereUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    professeurId?: StringFieldUpdateOperationsInput | string
    matiereId?: StringFieldUpdateOperationsInput | string
    role?: EnumProfesseurRoleFieldUpdateOperationsInput | ProfesseurRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfesseurMatiereCreateManyInput = {
    id?: string
    professeurId: string
    matiereId: string
    role: ProfesseurRole
    createdAt?: Date | string
  }

  export type ProfesseurMatiereUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProfesseurRoleFieldUpdateOperationsInput | ProfesseurRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfesseurMatiereUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    professeurId?: StringFieldUpdateOperationsInput | string
    matiereId?: StringFieldUpdateOperationsInput | string
    role?: EnumProfesseurRoleFieldUpdateOperationsInput | ProfesseurRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere?: MatiereCreateNestedOneWithoutDocumentsInput
    uploader: UserCreateNestedOneWithoutDocumentsInput
    deleter?: UserCreateNestedOneWithoutDeletedDocumentsInput
    commentaires?: CommentaireCreateNestedManyWithoutDocumentInput
    documentPFE?: DocumentPFECreateNestedOneWithoutDocumentInput
    documentMatieres?: DocumentMatiereCreateNestedManyWithoutDocumentInput
    correctionPour?: DocumentCreateNestedOneWithoutCorrectionInput
    correction?: DocumentCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    matiereId?: string | null
    telchargePar: string
    correctionId?: string | null
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutDocumentInput
    documentPFE?: DocumentPFEUncheckedCreateNestedOneWithoutDocumentInput
    documentMatieres?: DocumentMatiereUncheckedCreateNestedManyWithoutDocumentInput
    correction?: DocumentUncheckedCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutDocumentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    deleter?: UserUpdateOneWithoutDeletedDocumentsNestedInput
    commentaires?: CommentaireUpdateManyWithoutDocumentNestedInput
    documentPFE?: DocumentPFEUpdateOneWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUpdateManyWithoutDocumentNestedInput
    correctionPour?: DocumentUpdateOneWithoutCorrectionNestedInput
    correction?: DocumentUpdateOneWithoutCorrectionPourNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    matiereId?: NullableStringFieldUpdateOperationsInput | string | null
    telchargePar?: StringFieldUpdateOperationsInput | string
    correctionId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: CommentaireUncheckedUpdateManyWithoutDocumentNestedInput
    documentPFE?: DocumentPFEUncheckedUpdateOneWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUncheckedUpdateManyWithoutDocumentNestedInput
    correction?: DocumentUncheckedUpdateOneWithoutCorrectionPourNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    matiereId?: string | null
    telchargePar: string
    correctionId?: string | null
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    matiereId?: NullableStringFieldUpdateOperationsInput | string | null
    telchargePar?: StringFieldUpdateOperationsInput | string
    correctionId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPFECreateInput = {
    id?: string
    anneeDiplome: number
    filiereDiplome: string
    titreProjet: string
    resume?: string | null
    motsCles?: DocumentPFECreatemotsClesInput | Enumerable<string>
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutDocumentPFEInput
  }

  export type DocumentPFEUncheckedCreateInput = {
    id?: string
    documentId: string
    anneeDiplome: number
    filiereDiplome: string
    titreProjet: string
    resume?: string | null
    motsCles?: DocumentPFECreatemotsClesInput | Enumerable<string>
    createdAt?: Date | string
  }

  export type DocumentPFEUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anneeDiplome?: IntFieldUpdateOperationsInput | number
    filiereDiplome?: StringFieldUpdateOperationsInput | string
    titreProjet?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    motsCles?: DocumentPFEUpdatemotsClesInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutDocumentPFENestedInput
  }

  export type DocumentPFEUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    anneeDiplome?: IntFieldUpdateOperationsInput | number
    filiereDiplome?: StringFieldUpdateOperationsInput | string
    titreProjet?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    motsCles?: DocumentPFEUpdatemotsClesInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPFECreateManyInput = {
    id?: string
    documentId: string
    anneeDiplome: number
    filiereDiplome: string
    titreProjet: string
    resume?: string | null
    motsCles?: DocumentPFECreatemotsClesInput | Enumerable<string>
    createdAt?: Date | string
  }

  export type DocumentPFEUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    anneeDiplome?: IntFieldUpdateOperationsInput | number
    filiereDiplome?: StringFieldUpdateOperationsInput | string
    titreProjet?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    motsCles?: DocumentPFEUpdatemotsClesInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPFEUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    anneeDiplome?: IntFieldUpdateOperationsInput | number
    filiereDiplome?: StringFieldUpdateOperationsInput | string
    titreProjet?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    motsCles?: DocumentPFEUpdatemotsClesInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentaireCreateInput = {
    id?: string
    contenu: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentCreateNestedOneWithoutCommentairesInput
    user: UserCreateNestedOneWithoutCommentairesInput
    parent?: CommentaireCreateNestedOneWithoutRepliesInput
    replies?: CommentaireCreateNestedManyWithoutParentInput
  }

  export type CommentaireUncheckedCreateInput = {
    id?: string
    contenu: string
    documentId: string
    userId: string
    parentId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentaireUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentaireUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutCommentairesNestedInput
    user?: UserUpdateOneRequiredWithoutCommentairesNestedInput
    parent?: CommentaireUpdateOneWithoutRepliesNestedInput
    replies?: CommentaireUpdateManyWithoutParentNestedInput
  }

  export type CommentaireUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentaireUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentaireCreateManyInput = {
    id?: string
    contenu: string
    documentId: string
    userId: string
    parentId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentaireUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentaireUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: AuditAction
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: AuditAction
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: AuditAction
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentMatiereCreateInput = {
    id?: string
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutDocumentMatieresInput
    matiere: MatiereCreateNestedOneWithoutDocumentMatieresInput
  }

  export type DocumentMatiereUncheckedCreateInput = {
    id?: string
    documentId: string
    matiereId: string
    createdAt?: Date | string
  }

  export type DocumentMatiereUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutDocumentMatieresNestedInput
    matiere?: MatiereUpdateOneRequiredWithoutDocumentMatieresNestedInput
  }

  export type DocumentMatiereUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    matiereId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentMatiereCreateManyInput = {
    id?: string
    documentId: string
    matiereId: string
    createdAt?: Date | string
  }

  export type DocumentMatiereUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentMatiereUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    matiereId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type EnumUserRoleFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleFilter | UserRole
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type FiliereRelationFilter = {
    is?: FiliereWhereInput | null
    isNot?: FiliereWhereInput | null
  }

  export type NiveauRelationFilter = {
    is?: NiveauWhereInput | null
    isNot?: NiveauWhereInput | null
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type CommentaireListRelationFilter = {
    every?: CommentaireWhereInput
    some?: CommentaireWhereInput
    none?: CommentaireWhereInput
  }

  export type ProfesseurMatiereListRelationFilter = {
    every?: ProfesseurMatiereWhereInput
    some?: ProfesseurMatiereWhereInput
    none?: ProfesseurMatiereWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentaireOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfesseurMatiereOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    filiereId?: SortOrder
    niveauId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    filiereId?: SortOrder
    niveauId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    prenom?: SortOrder
    nom?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    filiereId?: SortOrder
    niveauId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type EnumUserRoleWithAggregatesFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleWithAggregatesFilter | UserRole
    _count?: NestedIntFilter
    _min?: NestedEnumUserRoleFilter
    _max?: NestedEnumUserRoleFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type EnumNiveauTypeFilter = {
    equals?: NiveauType
    in?: Enumerable<NiveauType>
    notIn?: Enumerable<NiveauType>
    not?: NestedEnumNiveauTypeFilter | NiveauType
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type FiliereListRelationFilter = {
    every?: FiliereWhereInput
    some?: FiliereWhereInput
    none?: FiliereWhereInput
  }

  export type SemestreListRelationFilter = {
    every?: SemestreWhereInput
    some?: SemestreWhereInput
    none?: SemestreWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type FiliereOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SemestreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NiveauCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    ordre?: SortOrder
  }

  export type NiveauAvgOrderByAggregateInput = {
    ordre?: SortOrder
  }

  export type NiveauMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    ordre?: SortOrder
  }

  export type NiveauMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    ordre?: SortOrder
  }

  export type NiveauSumOrderByAggregateInput = {
    ordre?: SortOrder
  }

  export type EnumNiveauTypeWithAggregatesFilter = {
    equals?: NiveauType
    in?: Enumerable<NiveauType>
    notIn?: Enumerable<NiveauType>
    not?: NestedEnumNiveauTypeWithAggregatesFilter | NiveauType
    _count?: NestedIntFilter
    _min?: NestedEnumNiveauTypeFilter
    _max?: NestedEnumNiveauTypeFilter
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type MatiereListRelationFilter = {
    every?: MatiereWhereInput
    some?: MatiereWhereInput
    none?: MatiereWhereInput
  }

  export type MatiereOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FiliereCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    niveauId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FiliereMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    niveauId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FiliereMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    niveauId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SemestreNiveauIdOrdreCompoundUniqueInput = {
    niveauId: string
    ordre: number
  }

  export type SemestreCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    niveauId?: SortOrder
    ordre?: SortOrder
  }

  export type SemestreAvgOrderByAggregateInput = {
    ordre?: SortOrder
  }

  export type SemestreMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    niveauId?: SortOrder
    ordre?: SortOrder
  }

  export type SemestreMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    niveauId?: SortOrder
    ordre?: SortOrder
  }

  export type SemestreSumOrderByAggregateInput = {
    ordre?: SortOrder
  }

  export type SemestreRelationFilter = {
    is?: SemestreWhereInput | null
    isNot?: SemestreWhereInput | null
  }

  export type DocumentMatiereListRelationFilter = {
    every?: DocumentMatiereWhereInput
    some?: DocumentMatiereWhereInput
    none?: DocumentMatiereWhereInput
  }

  export type DocumentMatiereOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatiereCodeFiliereIdCompoundUniqueInput = {
    code: string
    filiereId: string
  }

  export type MatiereCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    filiereId?: SortOrder
    semestreId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MatiereMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    filiereId?: SortOrder
    semestreId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MatiereMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    filiereId?: SortOrder
    semestreId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumProfesseurRoleFilter = {
    equals?: ProfesseurRole
    in?: Enumerable<ProfesseurRole>
    notIn?: Enumerable<ProfesseurRole>
    not?: NestedEnumProfesseurRoleFilter | ProfesseurRole
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MatiereRelationFilter = {
    is?: MatiereWhereInput | null
    isNot?: MatiereWhereInput | null
  }

  export type ProfesseurMatiereMatiereIdRoleCompoundUniqueInput = {
    matiereId: string
    role: ProfesseurRole
  }

  export type ProfesseurMatiereCountOrderByAggregateInput = {
    id?: SortOrder
    professeurId?: SortOrder
    matiereId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfesseurMatiereMaxOrderByAggregateInput = {
    id?: SortOrder
    professeurId?: SortOrder
    matiereId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfesseurMatiereMinOrderByAggregateInput = {
    id?: SortOrder
    professeurId?: SortOrder
    matiereId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumProfesseurRoleWithAggregatesFilter = {
    equals?: ProfesseurRole
    in?: Enumerable<ProfesseurRole>
    notIn?: Enumerable<ProfesseurRole>
    not?: NestedEnumProfesseurRoleWithAggregatesFilter | ProfesseurRole
    _count?: NestedIntFilter
    _min?: NestedEnumProfesseurRoleFilter
    _max?: NestedEnumProfesseurRoleFilter
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type EnumDocumentCategorieFilter = {
    equals?: DocumentCategorie
    in?: Enumerable<DocumentCategorie>
    notIn?: Enumerable<DocumentCategorie>
    not?: NestedEnumDocumentCategorieFilter | DocumentCategorie
  }

  export type DocumentPFERelationFilter = {
    is?: DocumentPFEWhereInput | null
    isNot?: DocumentPFEWhereInput | null
  }

  export type DocumentRelationFilter = {
    is?: DocumentWhereInput | null
    isNot?: DocumentWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    cheminFichier?: SortOrder
    nomFichier?: SortOrder
    tailleFichier?: SortOrder
    typeMime?: SortOrder
    categorie?: SortOrder
    matiereId?: SortOrder
    telchargePar?: SortOrder
    correctionId?: SortOrder
    downloadCount?: SortOrder
    viewCount?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    tailleFichier?: SortOrder
    downloadCount?: SortOrder
    viewCount?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    cheminFichier?: SortOrder
    nomFichier?: SortOrder
    tailleFichier?: SortOrder
    typeMime?: SortOrder
    categorie?: SortOrder
    matiereId?: SortOrder
    telchargePar?: SortOrder
    correctionId?: SortOrder
    downloadCount?: SortOrder
    viewCount?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    description?: SortOrder
    cheminFichier?: SortOrder
    nomFichier?: SortOrder
    tailleFichier?: SortOrder
    typeMime?: SortOrder
    categorie?: SortOrder
    matiereId?: SortOrder
    telchargePar?: SortOrder
    correctionId?: SortOrder
    downloadCount?: SortOrder
    viewCount?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    tailleFichier?: SortOrder
    downloadCount?: SortOrder
    viewCount?: SortOrder
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type EnumDocumentCategorieWithAggregatesFilter = {
    equals?: DocumentCategorie
    in?: Enumerable<DocumentCategorie>
    notIn?: Enumerable<DocumentCategorie>
    not?: NestedEnumDocumentCategorieWithAggregatesFilter | DocumentCategorie
    _count?: NestedIntFilter
    _min?: NestedEnumDocumentCategorieFilter
    _max?: NestedEnumDocumentCategorieFilter
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type DocumentPFECountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    anneeDiplome?: SortOrder
    filiereDiplome?: SortOrder
    titreProjet?: SortOrder
    resume?: SortOrder
    motsCles?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentPFEAvgOrderByAggregateInput = {
    anneeDiplome?: SortOrder
  }

  export type DocumentPFEMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    anneeDiplome?: SortOrder
    filiereDiplome?: SortOrder
    titreProjet?: SortOrder
    resume?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentPFEMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    anneeDiplome?: SortOrder
    filiereDiplome?: SortOrder
    titreProjet?: SortOrder
    resume?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentPFESumOrderByAggregateInput = {
    anneeDiplome?: SortOrder
  }

  export type CommentaireRelationFilter = {
    is?: CommentaireWhereInput | null
    isNot?: CommentaireWhereInput | null
  }

  export type CommentaireCountOrderByAggregateInput = {
    id?: SortOrder
    contenu?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentaireMaxOrderByAggregateInput = {
    id?: SortOrder
    contenu?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentaireMinOrderByAggregateInput = {
    id?: SortOrder
    contenu?: SortOrder
    documentId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    isEdited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAuditActionFilter = {
    equals?: AuditAction
    in?: Enumerable<AuditAction>
    notIn?: Enumerable<AuditAction>
    not?: NestedEnumAuditActionFilter | AuditAction
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter = {
    equals?: AuditAction
    in?: Enumerable<AuditAction>
    notIn?: Enumerable<AuditAction>
    not?: NestedEnumAuditActionWithAggregatesFilter | AuditAction
    _count?: NestedIntFilter
    _min?: NestedEnumAuditActionFilter
    _max?: NestedEnumAuditActionFilter
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type DocumentMatiereDocumentIdMatiereIdCompoundUniqueInput = {
    documentId: string
    matiereId: string
  }

  export type DocumentMatiereCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    matiereId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMatiereMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    matiereId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMatiereMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    matiereId?: SortOrder
    createdAt?: SortOrder
  }

  export type FiliereCreateNestedOneWithoutUsersInput = {
    create?: XOR<FiliereCreateWithoutUsersInput, FiliereUncheckedCreateWithoutUsersInput>
    connectOrCreate?: FiliereCreateOrConnectWithoutUsersInput
    connect?: FiliereWhereUniqueInput
  }

  export type NiveauCreateNestedOneWithoutUsersInput = {
    create?: XOR<NiveauCreateWithoutUsersInput, NiveauUncheckedCreateWithoutUsersInput>
    connectOrCreate?: NiveauCreateOrConnectWithoutUsersInput
    connect?: NiveauWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutUploaderInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutUploaderInput>, Enumerable<DocumentUncheckedCreateWithoutUploaderInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutUploaderInput>
    createMany?: DocumentCreateManyUploaderInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type DocumentCreateNestedManyWithoutDeleterInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutDeleterInput>, Enumerable<DocumentUncheckedCreateWithoutDeleterInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutDeleterInput>
    createMany?: DocumentCreateManyDeleterInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type CommentaireCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommentaireCreateWithoutUserInput>, Enumerable<CommentaireUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentaireCreateOrConnectWithoutUserInput>
    createMany?: CommentaireCreateManyUserInputEnvelope
    connect?: Enumerable<CommentaireWhereUniqueInput>
  }

  export type ProfesseurMatiereCreateNestedManyWithoutProfesseurInput = {
    create?: XOR<Enumerable<ProfesseurMatiereCreateWithoutProfesseurInput>, Enumerable<ProfesseurMatiereUncheckedCreateWithoutProfesseurInput>>
    connectOrCreate?: Enumerable<ProfesseurMatiereCreateOrConnectWithoutProfesseurInput>
    createMany?: ProfesseurMatiereCreateManyProfesseurInputEnvelope
    connect?: Enumerable<ProfesseurMatiereWhereUniqueInput>
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutUserInput>, Enumerable<AuditLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutUserInput>
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutUploaderInput>, Enumerable<DocumentUncheckedCreateWithoutUploaderInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutUploaderInput>
    createMany?: DocumentCreateManyUploaderInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutDeleterInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutDeleterInput>, Enumerable<DocumentUncheckedCreateWithoutDeleterInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutDeleterInput>
    createMany?: DocumentCreateManyDeleterInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type CommentaireUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommentaireCreateWithoutUserInput>, Enumerable<CommentaireUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentaireCreateOrConnectWithoutUserInput>
    createMany?: CommentaireCreateManyUserInputEnvelope
    connect?: Enumerable<CommentaireWhereUniqueInput>
  }

  export type ProfesseurMatiereUncheckedCreateNestedManyWithoutProfesseurInput = {
    create?: XOR<Enumerable<ProfesseurMatiereCreateWithoutProfesseurInput>, Enumerable<ProfesseurMatiereUncheckedCreateWithoutProfesseurInput>>
    connectOrCreate?: Enumerable<ProfesseurMatiereCreateOrConnectWithoutProfesseurInput>
    createMany?: ProfesseurMatiereCreateManyProfesseurInputEnvelope
    connect?: Enumerable<ProfesseurMatiereWhereUniqueInput>
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutUserInput>, Enumerable<AuditLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutUserInput>
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: Enumerable<AuditLogWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FiliereUpdateOneWithoutUsersNestedInput = {
    create?: XOR<FiliereCreateWithoutUsersInput, FiliereUncheckedCreateWithoutUsersInput>
    connectOrCreate?: FiliereCreateOrConnectWithoutUsersInput
    upsert?: FiliereUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: FiliereWhereUniqueInput
    update?: XOR<FiliereUpdateWithoutUsersInput, FiliereUncheckedUpdateWithoutUsersInput>
  }

  export type NiveauUpdateOneWithoutUsersNestedInput = {
    create?: XOR<NiveauCreateWithoutUsersInput, NiveauUncheckedCreateWithoutUsersInput>
    connectOrCreate?: NiveauCreateOrConnectWithoutUsersInput
    upsert?: NiveauUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: NiveauWhereUniqueInput
    update?: XOR<NiveauUpdateWithoutUsersInput, NiveauUncheckedUpdateWithoutUsersInput>
  }

  export type DocumentUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutUploaderInput>, Enumerable<DocumentUncheckedCreateWithoutUploaderInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutUploaderInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutUploaderInput>
    createMany?: DocumentCreateManyUploaderInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutUploaderInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutUploaderInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type DocumentUpdateManyWithoutDeleterNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutDeleterInput>, Enumerable<DocumentUncheckedCreateWithoutDeleterInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutDeleterInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutDeleterInput>
    createMany?: DocumentCreateManyDeleterInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutDeleterInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutDeleterInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type CommentaireUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CommentaireCreateWithoutUserInput>, Enumerable<CommentaireUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentaireCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommentaireUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommentaireCreateManyUserInputEnvelope
    set?: Enumerable<CommentaireWhereUniqueInput>
    disconnect?: Enumerable<CommentaireWhereUniqueInput>
    delete?: Enumerable<CommentaireWhereUniqueInput>
    connect?: Enumerable<CommentaireWhereUniqueInput>
    update?: Enumerable<CommentaireUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommentaireUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommentaireScalarWhereInput>
  }

  export type ProfesseurMatiereUpdateManyWithoutProfesseurNestedInput = {
    create?: XOR<Enumerable<ProfesseurMatiereCreateWithoutProfesseurInput>, Enumerable<ProfesseurMatiereUncheckedCreateWithoutProfesseurInput>>
    connectOrCreate?: Enumerable<ProfesseurMatiereCreateOrConnectWithoutProfesseurInput>
    upsert?: Enumerable<ProfesseurMatiereUpsertWithWhereUniqueWithoutProfesseurInput>
    createMany?: ProfesseurMatiereCreateManyProfesseurInputEnvelope
    set?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    disconnect?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    delete?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    connect?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    update?: Enumerable<ProfesseurMatiereUpdateWithWhereUniqueWithoutProfesseurInput>
    updateMany?: Enumerable<ProfesseurMatiereUpdateManyWithWhereWithoutProfesseurInput>
    deleteMany?: Enumerable<ProfesseurMatiereScalarWhereInput>
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutUserInput>, Enumerable<AuditLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutUploaderInput>, Enumerable<DocumentUncheckedCreateWithoutUploaderInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutUploaderInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutUploaderInput>
    createMany?: DocumentCreateManyUploaderInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutUploaderInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutUploaderInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutDeleterNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutDeleterInput>, Enumerable<DocumentUncheckedCreateWithoutDeleterInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutDeleterInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutDeleterInput>
    createMany?: DocumentCreateManyDeleterInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutDeleterInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutDeleterInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type CommentaireUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CommentaireCreateWithoutUserInput>, Enumerable<CommentaireUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentaireCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommentaireUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommentaireCreateManyUserInputEnvelope
    set?: Enumerable<CommentaireWhereUniqueInput>
    disconnect?: Enumerable<CommentaireWhereUniqueInput>
    delete?: Enumerable<CommentaireWhereUniqueInput>
    connect?: Enumerable<CommentaireWhereUniqueInput>
    update?: Enumerable<CommentaireUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommentaireUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommentaireScalarWhereInput>
  }

  export type ProfesseurMatiereUncheckedUpdateManyWithoutProfesseurNestedInput = {
    create?: XOR<Enumerable<ProfesseurMatiereCreateWithoutProfesseurInput>, Enumerable<ProfesseurMatiereUncheckedCreateWithoutProfesseurInput>>
    connectOrCreate?: Enumerable<ProfesseurMatiereCreateOrConnectWithoutProfesseurInput>
    upsert?: Enumerable<ProfesseurMatiereUpsertWithWhereUniqueWithoutProfesseurInput>
    createMany?: ProfesseurMatiereCreateManyProfesseurInputEnvelope
    set?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    disconnect?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    delete?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    connect?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    update?: Enumerable<ProfesseurMatiereUpdateWithWhereUniqueWithoutProfesseurInput>
    updateMany?: Enumerable<ProfesseurMatiereUpdateManyWithWhereWithoutProfesseurInput>
    deleteMany?: Enumerable<ProfesseurMatiereScalarWhereInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AuditLogCreateWithoutUserInput>, Enumerable<AuditLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AuditLogCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AuditLogUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: Enumerable<AuditLogWhereUniqueInput>
    disconnect?: Enumerable<AuditLogWhereUniqueInput>
    delete?: Enumerable<AuditLogWhereUniqueInput>
    connect?: Enumerable<AuditLogWhereUniqueInput>
    update?: Enumerable<AuditLogUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AuditLogUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AuditLogScalarWhereInput>
  }

  export type FiliereCreateNestedManyWithoutNiveauInput = {
    create?: XOR<Enumerable<FiliereCreateWithoutNiveauInput>, Enumerable<FiliereUncheckedCreateWithoutNiveauInput>>
    connectOrCreate?: Enumerable<FiliereCreateOrConnectWithoutNiveauInput>
    createMany?: FiliereCreateManyNiveauInputEnvelope
    connect?: Enumerable<FiliereWhereUniqueInput>
  }

  export type SemestreCreateNestedManyWithoutNiveauInput = {
    create?: XOR<Enumerable<SemestreCreateWithoutNiveauInput>, Enumerable<SemestreUncheckedCreateWithoutNiveauInput>>
    connectOrCreate?: Enumerable<SemestreCreateOrConnectWithoutNiveauInput>
    createMany?: SemestreCreateManyNiveauInputEnvelope
    connect?: Enumerable<SemestreWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutNiveauInput = {
    create?: XOR<Enumerable<UserCreateWithoutNiveauInput>, Enumerable<UserUncheckedCreateWithoutNiveauInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutNiveauInput>
    createMany?: UserCreateManyNiveauInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type FiliereUncheckedCreateNestedManyWithoutNiveauInput = {
    create?: XOR<Enumerable<FiliereCreateWithoutNiveauInput>, Enumerable<FiliereUncheckedCreateWithoutNiveauInput>>
    connectOrCreate?: Enumerable<FiliereCreateOrConnectWithoutNiveauInput>
    createMany?: FiliereCreateManyNiveauInputEnvelope
    connect?: Enumerable<FiliereWhereUniqueInput>
  }

  export type SemestreUncheckedCreateNestedManyWithoutNiveauInput = {
    create?: XOR<Enumerable<SemestreCreateWithoutNiveauInput>, Enumerable<SemestreUncheckedCreateWithoutNiveauInput>>
    connectOrCreate?: Enumerable<SemestreCreateOrConnectWithoutNiveauInput>
    createMany?: SemestreCreateManyNiveauInputEnvelope
    connect?: Enumerable<SemestreWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutNiveauInput = {
    create?: XOR<Enumerable<UserCreateWithoutNiveauInput>, Enumerable<UserUncheckedCreateWithoutNiveauInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutNiveauInput>
    createMany?: UserCreateManyNiveauInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type EnumNiveauTypeFieldUpdateOperationsInput = {
    set?: NiveauType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FiliereUpdateManyWithoutNiveauNestedInput = {
    create?: XOR<Enumerable<FiliereCreateWithoutNiveauInput>, Enumerable<FiliereUncheckedCreateWithoutNiveauInput>>
    connectOrCreate?: Enumerable<FiliereCreateOrConnectWithoutNiveauInput>
    upsert?: Enumerable<FiliereUpsertWithWhereUniqueWithoutNiveauInput>
    createMany?: FiliereCreateManyNiveauInputEnvelope
    set?: Enumerable<FiliereWhereUniqueInput>
    disconnect?: Enumerable<FiliereWhereUniqueInput>
    delete?: Enumerable<FiliereWhereUniqueInput>
    connect?: Enumerable<FiliereWhereUniqueInput>
    update?: Enumerable<FiliereUpdateWithWhereUniqueWithoutNiveauInput>
    updateMany?: Enumerable<FiliereUpdateManyWithWhereWithoutNiveauInput>
    deleteMany?: Enumerable<FiliereScalarWhereInput>
  }

  export type SemestreUpdateManyWithoutNiveauNestedInput = {
    create?: XOR<Enumerable<SemestreCreateWithoutNiveauInput>, Enumerable<SemestreUncheckedCreateWithoutNiveauInput>>
    connectOrCreate?: Enumerable<SemestreCreateOrConnectWithoutNiveauInput>
    upsert?: Enumerable<SemestreUpsertWithWhereUniqueWithoutNiveauInput>
    createMany?: SemestreCreateManyNiveauInputEnvelope
    set?: Enumerable<SemestreWhereUniqueInput>
    disconnect?: Enumerable<SemestreWhereUniqueInput>
    delete?: Enumerable<SemestreWhereUniqueInput>
    connect?: Enumerable<SemestreWhereUniqueInput>
    update?: Enumerable<SemestreUpdateWithWhereUniqueWithoutNiveauInput>
    updateMany?: Enumerable<SemestreUpdateManyWithWhereWithoutNiveauInput>
    deleteMany?: Enumerable<SemestreScalarWhereInput>
  }

  export type UserUpdateManyWithoutNiveauNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutNiveauInput>, Enumerable<UserUncheckedCreateWithoutNiveauInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutNiveauInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutNiveauInput>
    createMany?: UserCreateManyNiveauInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutNiveauInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutNiveauInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type FiliereUncheckedUpdateManyWithoutNiveauNestedInput = {
    create?: XOR<Enumerable<FiliereCreateWithoutNiveauInput>, Enumerable<FiliereUncheckedCreateWithoutNiveauInput>>
    connectOrCreate?: Enumerable<FiliereCreateOrConnectWithoutNiveauInput>
    upsert?: Enumerable<FiliereUpsertWithWhereUniqueWithoutNiveauInput>
    createMany?: FiliereCreateManyNiveauInputEnvelope
    set?: Enumerable<FiliereWhereUniqueInput>
    disconnect?: Enumerable<FiliereWhereUniqueInput>
    delete?: Enumerable<FiliereWhereUniqueInput>
    connect?: Enumerable<FiliereWhereUniqueInput>
    update?: Enumerable<FiliereUpdateWithWhereUniqueWithoutNiveauInput>
    updateMany?: Enumerable<FiliereUpdateManyWithWhereWithoutNiveauInput>
    deleteMany?: Enumerable<FiliereScalarWhereInput>
  }

  export type SemestreUncheckedUpdateManyWithoutNiveauNestedInput = {
    create?: XOR<Enumerable<SemestreCreateWithoutNiveauInput>, Enumerable<SemestreUncheckedCreateWithoutNiveauInput>>
    connectOrCreate?: Enumerable<SemestreCreateOrConnectWithoutNiveauInput>
    upsert?: Enumerable<SemestreUpsertWithWhereUniqueWithoutNiveauInput>
    createMany?: SemestreCreateManyNiveauInputEnvelope
    set?: Enumerable<SemestreWhereUniqueInput>
    disconnect?: Enumerable<SemestreWhereUniqueInput>
    delete?: Enumerable<SemestreWhereUniqueInput>
    connect?: Enumerable<SemestreWhereUniqueInput>
    update?: Enumerable<SemestreUpdateWithWhereUniqueWithoutNiveauInput>
    updateMany?: Enumerable<SemestreUpdateManyWithWhereWithoutNiveauInput>
    deleteMany?: Enumerable<SemestreScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutNiveauNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutNiveauInput>, Enumerable<UserUncheckedCreateWithoutNiveauInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutNiveauInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutNiveauInput>
    createMany?: UserCreateManyNiveauInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutNiveauInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutNiveauInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type NiveauCreateNestedOneWithoutFilieresInput = {
    create?: XOR<NiveauCreateWithoutFilieresInput, NiveauUncheckedCreateWithoutFilieresInput>
    connectOrCreate?: NiveauCreateOrConnectWithoutFilieresInput
    connect?: NiveauWhereUniqueInput
  }

  export type MatiereCreateNestedManyWithoutFiliereInput = {
    create?: XOR<Enumerable<MatiereCreateWithoutFiliereInput>, Enumerable<MatiereUncheckedCreateWithoutFiliereInput>>
    connectOrCreate?: Enumerable<MatiereCreateOrConnectWithoutFiliereInput>
    createMany?: MatiereCreateManyFiliereInputEnvelope
    connect?: Enumerable<MatiereWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutFiliereInput = {
    create?: XOR<Enumerable<UserCreateWithoutFiliereInput>, Enumerable<UserUncheckedCreateWithoutFiliereInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFiliereInput>
    createMany?: UserCreateManyFiliereInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type MatiereUncheckedCreateNestedManyWithoutFiliereInput = {
    create?: XOR<Enumerable<MatiereCreateWithoutFiliereInput>, Enumerable<MatiereUncheckedCreateWithoutFiliereInput>>
    connectOrCreate?: Enumerable<MatiereCreateOrConnectWithoutFiliereInput>
    createMany?: MatiereCreateManyFiliereInputEnvelope
    connect?: Enumerable<MatiereWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutFiliereInput = {
    create?: XOR<Enumerable<UserCreateWithoutFiliereInput>, Enumerable<UserUncheckedCreateWithoutFiliereInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFiliereInput>
    createMany?: UserCreateManyFiliereInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type NiveauUpdateOneRequiredWithoutFilieresNestedInput = {
    create?: XOR<NiveauCreateWithoutFilieresInput, NiveauUncheckedCreateWithoutFilieresInput>
    connectOrCreate?: NiveauCreateOrConnectWithoutFilieresInput
    upsert?: NiveauUpsertWithoutFilieresInput
    connect?: NiveauWhereUniqueInput
    update?: XOR<NiveauUpdateWithoutFilieresInput, NiveauUncheckedUpdateWithoutFilieresInput>
  }

  export type MatiereUpdateManyWithoutFiliereNestedInput = {
    create?: XOR<Enumerable<MatiereCreateWithoutFiliereInput>, Enumerable<MatiereUncheckedCreateWithoutFiliereInput>>
    connectOrCreate?: Enumerable<MatiereCreateOrConnectWithoutFiliereInput>
    upsert?: Enumerable<MatiereUpsertWithWhereUniqueWithoutFiliereInput>
    createMany?: MatiereCreateManyFiliereInputEnvelope
    set?: Enumerable<MatiereWhereUniqueInput>
    disconnect?: Enumerable<MatiereWhereUniqueInput>
    delete?: Enumerable<MatiereWhereUniqueInput>
    connect?: Enumerable<MatiereWhereUniqueInput>
    update?: Enumerable<MatiereUpdateWithWhereUniqueWithoutFiliereInput>
    updateMany?: Enumerable<MatiereUpdateManyWithWhereWithoutFiliereInput>
    deleteMany?: Enumerable<MatiereScalarWhereInput>
  }

  export type UserUpdateManyWithoutFiliereNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutFiliereInput>, Enumerable<UserUncheckedCreateWithoutFiliereInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFiliereInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutFiliereInput>
    createMany?: UserCreateManyFiliereInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutFiliereInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutFiliereInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type MatiereUncheckedUpdateManyWithoutFiliereNestedInput = {
    create?: XOR<Enumerable<MatiereCreateWithoutFiliereInput>, Enumerable<MatiereUncheckedCreateWithoutFiliereInput>>
    connectOrCreate?: Enumerable<MatiereCreateOrConnectWithoutFiliereInput>
    upsert?: Enumerable<MatiereUpsertWithWhereUniqueWithoutFiliereInput>
    createMany?: MatiereCreateManyFiliereInputEnvelope
    set?: Enumerable<MatiereWhereUniqueInput>
    disconnect?: Enumerable<MatiereWhereUniqueInput>
    delete?: Enumerable<MatiereWhereUniqueInput>
    connect?: Enumerable<MatiereWhereUniqueInput>
    update?: Enumerable<MatiereUpdateWithWhereUniqueWithoutFiliereInput>
    updateMany?: Enumerable<MatiereUpdateManyWithWhereWithoutFiliereInput>
    deleteMany?: Enumerable<MatiereScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutFiliereNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutFiliereInput>, Enumerable<UserUncheckedCreateWithoutFiliereInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFiliereInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutFiliereInput>
    createMany?: UserCreateManyFiliereInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutFiliereInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutFiliereInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type NiveauCreateNestedOneWithoutSemestresInput = {
    create?: XOR<NiveauCreateWithoutSemestresInput, NiveauUncheckedCreateWithoutSemestresInput>
    connectOrCreate?: NiveauCreateOrConnectWithoutSemestresInput
    connect?: NiveauWhereUniqueInput
  }

  export type MatiereCreateNestedManyWithoutSemestreInput = {
    create?: XOR<Enumerable<MatiereCreateWithoutSemestreInput>, Enumerable<MatiereUncheckedCreateWithoutSemestreInput>>
    connectOrCreate?: Enumerable<MatiereCreateOrConnectWithoutSemestreInput>
    createMany?: MatiereCreateManySemestreInputEnvelope
    connect?: Enumerable<MatiereWhereUniqueInput>
  }

  export type MatiereUncheckedCreateNestedManyWithoutSemestreInput = {
    create?: XOR<Enumerable<MatiereCreateWithoutSemestreInput>, Enumerable<MatiereUncheckedCreateWithoutSemestreInput>>
    connectOrCreate?: Enumerable<MatiereCreateOrConnectWithoutSemestreInput>
    createMany?: MatiereCreateManySemestreInputEnvelope
    connect?: Enumerable<MatiereWhereUniqueInput>
  }

  export type NiveauUpdateOneRequiredWithoutSemestresNestedInput = {
    create?: XOR<NiveauCreateWithoutSemestresInput, NiveauUncheckedCreateWithoutSemestresInput>
    connectOrCreate?: NiveauCreateOrConnectWithoutSemestresInput
    upsert?: NiveauUpsertWithoutSemestresInput
    connect?: NiveauWhereUniqueInput
    update?: XOR<NiveauUpdateWithoutSemestresInput, NiveauUncheckedUpdateWithoutSemestresInput>
  }

  export type MatiereUpdateManyWithoutSemestreNestedInput = {
    create?: XOR<Enumerable<MatiereCreateWithoutSemestreInput>, Enumerable<MatiereUncheckedCreateWithoutSemestreInput>>
    connectOrCreate?: Enumerable<MatiereCreateOrConnectWithoutSemestreInput>
    upsert?: Enumerable<MatiereUpsertWithWhereUniqueWithoutSemestreInput>
    createMany?: MatiereCreateManySemestreInputEnvelope
    set?: Enumerable<MatiereWhereUniqueInput>
    disconnect?: Enumerable<MatiereWhereUniqueInput>
    delete?: Enumerable<MatiereWhereUniqueInput>
    connect?: Enumerable<MatiereWhereUniqueInput>
    update?: Enumerable<MatiereUpdateWithWhereUniqueWithoutSemestreInput>
    updateMany?: Enumerable<MatiereUpdateManyWithWhereWithoutSemestreInput>
    deleteMany?: Enumerable<MatiereScalarWhereInput>
  }

  export type MatiereUncheckedUpdateManyWithoutSemestreNestedInput = {
    create?: XOR<Enumerable<MatiereCreateWithoutSemestreInput>, Enumerable<MatiereUncheckedCreateWithoutSemestreInput>>
    connectOrCreate?: Enumerable<MatiereCreateOrConnectWithoutSemestreInput>
    upsert?: Enumerable<MatiereUpsertWithWhereUniqueWithoutSemestreInput>
    createMany?: MatiereCreateManySemestreInputEnvelope
    set?: Enumerable<MatiereWhereUniqueInput>
    disconnect?: Enumerable<MatiereWhereUniqueInput>
    delete?: Enumerable<MatiereWhereUniqueInput>
    connect?: Enumerable<MatiereWhereUniqueInput>
    update?: Enumerable<MatiereUpdateWithWhereUniqueWithoutSemestreInput>
    updateMany?: Enumerable<MatiereUpdateManyWithWhereWithoutSemestreInput>
    deleteMany?: Enumerable<MatiereScalarWhereInput>
  }

  export type FiliereCreateNestedOneWithoutMatieresInput = {
    create?: XOR<FiliereCreateWithoutMatieresInput, FiliereUncheckedCreateWithoutMatieresInput>
    connectOrCreate?: FiliereCreateOrConnectWithoutMatieresInput
    connect?: FiliereWhereUniqueInput
  }

  export type SemestreCreateNestedOneWithoutMatieresInput = {
    create?: XOR<SemestreCreateWithoutMatieresInput, SemestreUncheckedCreateWithoutMatieresInput>
    connectOrCreate?: SemestreCreateOrConnectWithoutMatieresInput
    connect?: SemestreWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutMatiereInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutMatiereInput>, Enumerable<DocumentUncheckedCreateWithoutMatiereInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutMatiereInput>
    createMany?: DocumentCreateManyMatiereInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type DocumentMatiereCreateNestedManyWithoutMatiereInput = {
    create?: XOR<Enumerable<DocumentMatiereCreateWithoutMatiereInput>, Enumerable<DocumentMatiereUncheckedCreateWithoutMatiereInput>>
    connectOrCreate?: Enumerable<DocumentMatiereCreateOrConnectWithoutMatiereInput>
    createMany?: DocumentMatiereCreateManyMatiereInputEnvelope
    connect?: Enumerable<DocumentMatiereWhereUniqueInput>
  }

  export type ProfesseurMatiereCreateNestedManyWithoutMatiereInput = {
    create?: XOR<Enumerable<ProfesseurMatiereCreateWithoutMatiereInput>, Enumerable<ProfesseurMatiereUncheckedCreateWithoutMatiereInput>>
    connectOrCreate?: Enumerable<ProfesseurMatiereCreateOrConnectWithoutMatiereInput>
    createMany?: ProfesseurMatiereCreateManyMatiereInputEnvelope
    connect?: Enumerable<ProfesseurMatiereWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedManyWithoutMatiereInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutMatiereInput>, Enumerable<DocumentUncheckedCreateWithoutMatiereInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutMatiereInput>
    createMany?: DocumentCreateManyMatiereInputEnvelope
    connect?: Enumerable<DocumentWhereUniqueInput>
  }

  export type DocumentMatiereUncheckedCreateNestedManyWithoutMatiereInput = {
    create?: XOR<Enumerable<DocumentMatiereCreateWithoutMatiereInput>, Enumerable<DocumentMatiereUncheckedCreateWithoutMatiereInput>>
    connectOrCreate?: Enumerable<DocumentMatiereCreateOrConnectWithoutMatiereInput>
    createMany?: DocumentMatiereCreateManyMatiereInputEnvelope
    connect?: Enumerable<DocumentMatiereWhereUniqueInput>
  }

  export type ProfesseurMatiereUncheckedCreateNestedManyWithoutMatiereInput = {
    create?: XOR<Enumerable<ProfesseurMatiereCreateWithoutMatiereInput>, Enumerable<ProfesseurMatiereUncheckedCreateWithoutMatiereInput>>
    connectOrCreate?: Enumerable<ProfesseurMatiereCreateOrConnectWithoutMatiereInput>
    createMany?: ProfesseurMatiereCreateManyMatiereInputEnvelope
    connect?: Enumerable<ProfesseurMatiereWhereUniqueInput>
  }

  export type FiliereUpdateOneRequiredWithoutMatieresNestedInput = {
    create?: XOR<FiliereCreateWithoutMatieresInput, FiliereUncheckedCreateWithoutMatieresInput>
    connectOrCreate?: FiliereCreateOrConnectWithoutMatieresInput
    upsert?: FiliereUpsertWithoutMatieresInput
    connect?: FiliereWhereUniqueInput
    update?: XOR<FiliereUpdateWithoutMatieresInput, FiliereUncheckedUpdateWithoutMatieresInput>
  }

  export type SemestreUpdateOneRequiredWithoutMatieresNestedInput = {
    create?: XOR<SemestreCreateWithoutMatieresInput, SemestreUncheckedCreateWithoutMatieresInput>
    connectOrCreate?: SemestreCreateOrConnectWithoutMatieresInput
    upsert?: SemestreUpsertWithoutMatieresInput
    connect?: SemestreWhereUniqueInput
    update?: XOR<SemestreUpdateWithoutMatieresInput, SemestreUncheckedUpdateWithoutMatieresInput>
  }

  export type DocumentUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutMatiereInput>, Enumerable<DocumentUncheckedCreateWithoutMatiereInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutMatiereInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutMatiereInput>
    createMany?: DocumentCreateManyMatiereInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutMatiereInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutMatiereInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type DocumentMatiereUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<Enumerable<DocumentMatiereCreateWithoutMatiereInput>, Enumerable<DocumentMatiereUncheckedCreateWithoutMatiereInput>>
    connectOrCreate?: Enumerable<DocumentMatiereCreateOrConnectWithoutMatiereInput>
    upsert?: Enumerable<DocumentMatiereUpsertWithWhereUniqueWithoutMatiereInput>
    createMany?: DocumentMatiereCreateManyMatiereInputEnvelope
    set?: Enumerable<DocumentMatiereWhereUniqueInput>
    disconnect?: Enumerable<DocumentMatiereWhereUniqueInput>
    delete?: Enumerable<DocumentMatiereWhereUniqueInput>
    connect?: Enumerable<DocumentMatiereWhereUniqueInput>
    update?: Enumerable<DocumentMatiereUpdateWithWhereUniqueWithoutMatiereInput>
    updateMany?: Enumerable<DocumentMatiereUpdateManyWithWhereWithoutMatiereInput>
    deleteMany?: Enumerable<DocumentMatiereScalarWhereInput>
  }

  export type ProfesseurMatiereUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<Enumerable<ProfesseurMatiereCreateWithoutMatiereInput>, Enumerable<ProfesseurMatiereUncheckedCreateWithoutMatiereInput>>
    connectOrCreate?: Enumerable<ProfesseurMatiereCreateOrConnectWithoutMatiereInput>
    upsert?: Enumerable<ProfesseurMatiereUpsertWithWhereUniqueWithoutMatiereInput>
    createMany?: ProfesseurMatiereCreateManyMatiereInputEnvelope
    set?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    disconnect?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    delete?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    connect?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    update?: Enumerable<ProfesseurMatiereUpdateWithWhereUniqueWithoutMatiereInput>
    updateMany?: Enumerable<ProfesseurMatiereUpdateManyWithWhereWithoutMatiereInput>
    deleteMany?: Enumerable<ProfesseurMatiereScalarWhereInput>
  }

  export type DocumentUncheckedUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<Enumerable<DocumentCreateWithoutMatiereInput>, Enumerable<DocumentUncheckedCreateWithoutMatiereInput>>
    connectOrCreate?: Enumerable<DocumentCreateOrConnectWithoutMatiereInput>
    upsert?: Enumerable<DocumentUpsertWithWhereUniqueWithoutMatiereInput>
    createMany?: DocumentCreateManyMatiereInputEnvelope
    set?: Enumerable<DocumentWhereUniqueInput>
    disconnect?: Enumerable<DocumentWhereUniqueInput>
    delete?: Enumerable<DocumentWhereUniqueInput>
    connect?: Enumerable<DocumentWhereUniqueInput>
    update?: Enumerable<DocumentUpdateWithWhereUniqueWithoutMatiereInput>
    updateMany?: Enumerable<DocumentUpdateManyWithWhereWithoutMatiereInput>
    deleteMany?: Enumerable<DocumentScalarWhereInput>
  }

  export type DocumentMatiereUncheckedUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<Enumerable<DocumentMatiereCreateWithoutMatiereInput>, Enumerable<DocumentMatiereUncheckedCreateWithoutMatiereInput>>
    connectOrCreate?: Enumerable<DocumentMatiereCreateOrConnectWithoutMatiereInput>
    upsert?: Enumerable<DocumentMatiereUpsertWithWhereUniqueWithoutMatiereInput>
    createMany?: DocumentMatiereCreateManyMatiereInputEnvelope
    set?: Enumerable<DocumentMatiereWhereUniqueInput>
    disconnect?: Enumerable<DocumentMatiereWhereUniqueInput>
    delete?: Enumerable<DocumentMatiereWhereUniqueInput>
    connect?: Enumerable<DocumentMatiereWhereUniqueInput>
    update?: Enumerable<DocumentMatiereUpdateWithWhereUniqueWithoutMatiereInput>
    updateMany?: Enumerable<DocumentMatiereUpdateManyWithWhereWithoutMatiereInput>
    deleteMany?: Enumerable<DocumentMatiereScalarWhereInput>
  }

  export type ProfesseurMatiereUncheckedUpdateManyWithoutMatiereNestedInput = {
    create?: XOR<Enumerable<ProfesseurMatiereCreateWithoutMatiereInput>, Enumerable<ProfesseurMatiereUncheckedCreateWithoutMatiereInput>>
    connectOrCreate?: Enumerable<ProfesseurMatiereCreateOrConnectWithoutMatiereInput>
    upsert?: Enumerable<ProfesseurMatiereUpsertWithWhereUniqueWithoutMatiereInput>
    createMany?: ProfesseurMatiereCreateManyMatiereInputEnvelope
    set?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    disconnect?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    delete?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    connect?: Enumerable<ProfesseurMatiereWhereUniqueInput>
    update?: Enumerable<ProfesseurMatiereUpdateWithWhereUniqueWithoutMatiereInput>
    updateMany?: Enumerable<ProfesseurMatiereUpdateManyWithWhereWithoutMatiereInput>
    deleteMany?: Enumerable<ProfesseurMatiereScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutProfesseurMatieresInput = {
    create?: XOR<UserCreateWithoutProfesseurMatieresInput, UserUncheckedCreateWithoutProfesseurMatieresInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfesseurMatieresInput
    connect?: UserWhereUniqueInput
  }

  export type MatiereCreateNestedOneWithoutProfesseurMatieresInput = {
    create?: XOR<MatiereCreateWithoutProfesseurMatieresInput, MatiereUncheckedCreateWithoutProfesseurMatieresInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutProfesseurMatieresInput
    connect?: MatiereWhereUniqueInput
  }

  export type EnumProfesseurRoleFieldUpdateOperationsInput = {
    set?: ProfesseurRole
  }

  export type UserUpdateOneRequiredWithoutProfesseurMatieresNestedInput = {
    create?: XOR<UserCreateWithoutProfesseurMatieresInput, UserUncheckedCreateWithoutProfesseurMatieresInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfesseurMatieresInput
    upsert?: UserUpsertWithoutProfesseurMatieresInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutProfesseurMatieresInput, UserUncheckedUpdateWithoutProfesseurMatieresInput>
  }

  export type MatiereUpdateOneRequiredWithoutProfesseurMatieresNestedInput = {
    create?: XOR<MatiereCreateWithoutProfesseurMatieresInput, MatiereUncheckedCreateWithoutProfesseurMatieresInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutProfesseurMatieresInput
    upsert?: MatiereUpsertWithoutProfesseurMatieresInput
    connect?: MatiereWhereUniqueInput
    update?: XOR<MatiereUpdateWithoutProfesseurMatieresInput, MatiereUncheckedUpdateWithoutProfesseurMatieresInput>
  }

  export type MatiereCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<MatiereCreateWithoutDocumentsInput, MatiereUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutDocumentsInput
    connect?: MatiereWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeletedDocumentsInput = {
    create?: XOR<UserCreateWithoutDeletedDocumentsInput, UserUncheckedCreateWithoutDeletedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletedDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentaireCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<CommentaireCreateWithoutDocumentInput>, Enumerable<CommentaireUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<CommentaireCreateOrConnectWithoutDocumentInput>
    createMany?: CommentaireCreateManyDocumentInputEnvelope
    connect?: Enumerable<CommentaireWhereUniqueInput>
  }

  export type DocumentPFECreateNestedOneWithoutDocumentInput = {
    create?: XOR<DocumentPFECreateWithoutDocumentInput, DocumentPFEUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: DocumentPFECreateOrConnectWithoutDocumentInput
    connect?: DocumentPFEWhereUniqueInput
  }

  export type DocumentMatiereCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<DocumentMatiereCreateWithoutDocumentInput>, Enumerable<DocumentMatiereUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<DocumentMatiereCreateOrConnectWithoutDocumentInput>
    createMany?: DocumentMatiereCreateManyDocumentInputEnvelope
    connect?: Enumerable<DocumentMatiereWhereUniqueInput>
  }

  export type DocumentCreateNestedOneWithoutCorrectionInput = {
    create?: XOR<DocumentCreateWithoutCorrectionInput, DocumentUncheckedCreateWithoutCorrectionInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutCorrectionInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutCorrectionPourInput = {
    create?: XOR<DocumentCreateWithoutCorrectionPourInput, DocumentUncheckedCreateWithoutCorrectionPourInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutCorrectionPourInput
    connect?: DocumentWhereUniqueInput
  }

  export type CommentaireUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<CommentaireCreateWithoutDocumentInput>, Enumerable<CommentaireUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<CommentaireCreateOrConnectWithoutDocumentInput>
    createMany?: CommentaireCreateManyDocumentInputEnvelope
    connect?: Enumerable<CommentaireWhereUniqueInput>
  }

  export type DocumentPFEUncheckedCreateNestedOneWithoutDocumentInput = {
    create?: XOR<DocumentPFECreateWithoutDocumentInput, DocumentPFEUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: DocumentPFECreateOrConnectWithoutDocumentInput
    connect?: DocumentPFEWhereUniqueInput
  }

  export type DocumentMatiereUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<DocumentMatiereCreateWithoutDocumentInput>, Enumerable<DocumentMatiereUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<DocumentMatiereCreateOrConnectWithoutDocumentInput>
    createMany?: DocumentMatiereCreateManyDocumentInputEnvelope
    connect?: Enumerable<DocumentMatiereWhereUniqueInput>
  }

  export type DocumentUncheckedCreateNestedOneWithoutCorrectionPourInput = {
    create?: XOR<DocumentCreateWithoutCorrectionPourInput, DocumentUncheckedCreateWithoutCorrectionPourInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutCorrectionPourInput
    connect?: DocumentWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumDocumentCategorieFieldUpdateOperationsInput = {
    set?: DocumentCategorie
  }

  export type MatiereUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<MatiereCreateWithoutDocumentsInput, MatiereUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutDocumentsInput
    upsert?: MatiereUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: MatiereWhereUniqueInput
    update?: XOR<MatiereUpdateWithoutDocumentsInput, MatiereUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneWithoutDeletedDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDeletedDocumentsInput, UserUncheckedCreateWithoutDeletedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeletedDocumentsInput
    upsert?: UserUpsertWithoutDeletedDocumentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDeletedDocumentsInput, UserUncheckedUpdateWithoutDeletedDocumentsInput>
  }

  export type CommentaireUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<CommentaireCreateWithoutDocumentInput>, Enumerable<CommentaireUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<CommentaireCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<CommentaireUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: CommentaireCreateManyDocumentInputEnvelope
    set?: Enumerable<CommentaireWhereUniqueInput>
    disconnect?: Enumerable<CommentaireWhereUniqueInput>
    delete?: Enumerable<CommentaireWhereUniqueInput>
    connect?: Enumerable<CommentaireWhereUniqueInput>
    update?: Enumerable<CommentaireUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<CommentaireUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<CommentaireScalarWhereInput>
  }

  export type DocumentPFEUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<DocumentPFECreateWithoutDocumentInput, DocumentPFEUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: DocumentPFECreateOrConnectWithoutDocumentInput
    upsert?: DocumentPFEUpsertWithoutDocumentInput
    disconnect?: boolean
    delete?: boolean
    connect?: DocumentPFEWhereUniqueInput
    update?: XOR<DocumentPFEUpdateWithoutDocumentInput, DocumentPFEUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentMatiereUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<DocumentMatiereCreateWithoutDocumentInput>, Enumerable<DocumentMatiereUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<DocumentMatiereCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<DocumentMatiereUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: DocumentMatiereCreateManyDocumentInputEnvelope
    set?: Enumerable<DocumentMatiereWhereUniqueInput>
    disconnect?: Enumerable<DocumentMatiereWhereUniqueInput>
    delete?: Enumerable<DocumentMatiereWhereUniqueInput>
    connect?: Enumerable<DocumentMatiereWhereUniqueInput>
    update?: Enumerable<DocumentMatiereUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<DocumentMatiereUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<DocumentMatiereScalarWhereInput>
  }

  export type DocumentUpdateOneWithoutCorrectionNestedInput = {
    create?: XOR<DocumentCreateWithoutCorrectionInput, DocumentUncheckedCreateWithoutCorrectionInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutCorrectionInput
    upsert?: DocumentUpsertWithoutCorrectionInput
    disconnect?: boolean
    delete?: boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutCorrectionInput, DocumentUncheckedUpdateWithoutCorrectionInput>
  }

  export type DocumentUpdateOneWithoutCorrectionPourNestedInput = {
    create?: XOR<DocumentCreateWithoutCorrectionPourInput, DocumentUncheckedCreateWithoutCorrectionPourInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutCorrectionPourInput
    upsert?: DocumentUpsertWithoutCorrectionPourInput
    disconnect?: boolean
    delete?: boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutCorrectionPourInput, DocumentUncheckedUpdateWithoutCorrectionPourInput>
  }

  export type CommentaireUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<CommentaireCreateWithoutDocumentInput>, Enumerable<CommentaireUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<CommentaireCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<CommentaireUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: CommentaireCreateManyDocumentInputEnvelope
    set?: Enumerable<CommentaireWhereUniqueInput>
    disconnect?: Enumerable<CommentaireWhereUniqueInput>
    delete?: Enumerable<CommentaireWhereUniqueInput>
    connect?: Enumerable<CommentaireWhereUniqueInput>
    update?: Enumerable<CommentaireUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<CommentaireUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<CommentaireScalarWhereInput>
  }

  export type DocumentPFEUncheckedUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<DocumentPFECreateWithoutDocumentInput, DocumentPFEUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: DocumentPFECreateOrConnectWithoutDocumentInput
    upsert?: DocumentPFEUpsertWithoutDocumentInput
    disconnect?: boolean
    delete?: boolean
    connect?: DocumentPFEWhereUniqueInput
    update?: XOR<DocumentPFEUpdateWithoutDocumentInput, DocumentPFEUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentMatiereUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<DocumentMatiereCreateWithoutDocumentInput>, Enumerable<DocumentMatiereUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<DocumentMatiereCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<DocumentMatiereUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: DocumentMatiereCreateManyDocumentInputEnvelope
    set?: Enumerable<DocumentMatiereWhereUniqueInput>
    disconnect?: Enumerable<DocumentMatiereWhereUniqueInput>
    delete?: Enumerable<DocumentMatiereWhereUniqueInput>
    connect?: Enumerable<DocumentMatiereWhereUniqueInput>
    update?: Enumerable<DocumentMatiereUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<DocumentMatiereUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<DocumentMatiereScalarWhereInput>
  }

  export type DocumentUncheckedUpdateOneWithoutCorrectionPourNestedInput = {
    create?: XOR<DocumentCreateWithoutCorrectionPourInput, DocumentUncheckedCreateWithoutCorrectionPourInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutCorrectionPourInput
    upsert?: DocumentUpsertWithoutCorrectionPourInput
    disconnect?: boolean
    delete?: boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutCorrectionPourInput, DocumentUncheckedUpdateWithoutCorrectionPourInput>
  }

  export type DocumentPFECreatemotsClesInput = {
    set: Enumerable<string>
  }

  export type DocumentCreateNestedOneWithoutDocumentPFEInput = {
    create?: XOR<DocumentCreateWithoutDocumentPFEInput, DocumentUncheckedCreateWithoutDocumentPFEInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutDocumentPFEInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentPFEUpdatemotsClesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type DocumentUpdateOneRequiredWithoutDocumentPFENestedInput = {
    create?: XOR<DocumentCreateWithoutDocumentPFEInput, DocumentUncheckedCreateWithoutDocumentPFEInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutDocumentPFEInput
    upsert?: DocumentUpsertWithoutDocumentPFEInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutDocumentPFEInput, DocumentUncheckedUpdateWithoutDocumentPFEInput>
  }

  export type DocumentCreateNestedOneWithoutCommentairesInput = {
    create?: XOR<DocumentCreateWithoutCommentairesInput, DocumentUncheckedCreateWithoutCommentairesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutCommentairesInput
    connect?: DocumentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentairesInput = {
    create?: XOR<UserCreateWithoutCommentairesInput, UserUncheckedCreateWithoutCommentairesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentairesInput
    connect?: UserWhereUniqueInput
  }

  export type CommentaireCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentaireCreateWithoutRepliesInput, CommentaireUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentaireCreateOrConnectWithoutRepliesInput
    connect?: CommentaireWhereUniqueInput
  }

  export type CommentaireCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<CommentaireCreateWithoutParentInput>, Enumerable<CommentaireUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CommentaireCreateOrConnectWithoutParentInput>
    createMany?: CommentaireCreateManyParentInputEnvelope
    connect?: Enumerable<CommentaireWhereUniqueInput>
  }

  export type CommentaireUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<CommentaireCreateWithoutParentInput>, Enumerable<CommentaireUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CommentaireCreateOrConnectWithoutParentInput>
    createMany?: CommentaireCreateManyParentInputEnvelope
    connect?: Enumerable<CommentaireWhereUniqueInput>
  }

  export type DocumentUpdateOneRequiredWithoutCommentairesNestedInput = {
    create?: XOR<DocumentCreateWithoutCommentairesInput, DocumentUncheckedCreateWithoutCommentairesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutCommentairesInput
    upsert?: DocumentUpsertWithoutCommentairesInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutCommentairesInput, DocumentUncheckedUpdateWithoutCommentairesInput>
  }

  export type UserUpdateOneRequiredWithoutCommentairesNestedInput = {
    create?: XOR<UserCreateWithoutCommentairesInput, UserUncheckedCreateWithoutCommentairesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentairesInput
    upsert?: UserUpsertWithoutCommentairesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommentairesInput, UserUncheckedUpdateWithoutCommentairesInput>
  }

  export type CommentaireUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentaireCreateWithoutRepliesInput, CommentaireUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentaireCreateOrConnectWithoutRepliesInput
    upsert?: CommentaireUpsertWithoutRepliesInput
    disconnect?: boolean
    delete?: boolean
    connect?: CommentaireWhereUniqueInput
    update?: XOR<CommentaireUpdateWithoutRepliesInput, CommentaireUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentaireUpdateManyWithoutParentNestedInput = {
    create?: XOR<Enumerable<CommentaireCreateWithoutParentInput>, Enumerable<CommentaireUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CommentaireCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<CommentaireUpsertWithWhereUniqueWithoutParentInput>
    createMany?: CommentaireCreateManyParentInputEnvelope
    set?: Enumerable<CommentaireWhereUniqueInput>
    disconnect?: Enumerable<CommentaireWhereUniqueInput>
    delete?: Enumerable<CommentaireWhereUniqueInput>
    connect?: Enumerable<CommentaireWhereUniqueInput>
    update?: Enumerable<CommentaireUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<CommentaireUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<CommentaireScalarWhereInput>
  }

  export type CommentaireUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<Enumerable<CommentaireCreateWithoutParentInput>, Enumerable<CommentaireUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<CommentaireCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<CommentaireUpsertWithWhereUniqueWithoutParentInput>
    createMany?: CommentaireCreateManyParentInputEnvelope
    set?: Enumerable<CommentaireWhereUniqueInput>
    disconnect?: Enumerable<CommentaireWhereUniqueInput>
    delete?: Enumerable<CommentaireWhereUniqueInput>
    connect?: Enumerable<CommentaireWhereUniqueInput>
    update?: Enumerable<CommentaireUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<CommentaireUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<CommentaireScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: AuditAction
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type DocumentCreateNestedOneWithoutDocumentMatieresInput = {
    create?: XOR<DocumentCreateWithoutDocumentMatieresInput, DocumentUncheckedCreateWithoutDocumentMatieresInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutDocumentMatieresInput
    connect?: DocumentWhereUniqueInput
  }

  export type MatiereCreateNestedOneWithoutDocumentMatieresInput = {
    create?: XOR<MatiereCreateWithoutDocumentMatieresInput, MatiereUncheckedCreateWithoutDocumentMatieresInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutDocumentMatieresInput
    connect?: MatiereWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutDocumentMatieresNestedInput = {
    create?: XOR<DocumentCreateWithoutDocumentMatieresInput, DocumentUncheckedCreateWithoutDocumentMatieresInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutDocumentMatieresInput
    upsert?: DocumentUpsertWithoutDocumentMatieresInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutDocumentMatieresInput, DocumentUncheckedUpdateWithoutDocumentMatieresInput>
  }

  export type MatiereUpdateOneRequiredWithoutDocumentMatieresNestedInput = {
    create?: XOR<MatiereCreateWithoutDocumentMatieresInput, MatiereUncheckedCreateWithoutDocumentMatieresInput>
    connectOrCreate?: MatiereCreateOrConnectWithoutDocumentMatieresInput
    upsert?: MatiereUpsertWithoutDocumentMatieresInput
    connect?: MatiereWhereUniqueInput
    update?: XOR<MatiereUpdateWithoutDocumentMatieresInput, MatiereUncheckedUpdateWithoutDocumentMatieresInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedEnumUserRoleFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleFilter | UserRole
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleWithAggregatesFilter | UserRole
    _count?: NestedIntFilter
    _min?: NestedEnumUserRoleFilter
    _max?: NestedEnumUserRoleFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumNiveauTypeFilter = {
    equals?: NiveauType
    in?: Enumerable<NiveauType>
    notIn?: Enumerable<NiveauType>
    not?: NestedEnumNiveauTypeFilter | NiveauType
  }

  export type NestedEnumNiveauTypeWithAggregatesFilter = {
    equals?: NiveauType
    in?: Enumerable<NiveauType>
    notIn?: Enumerable<NiveauType>
    not?: NestedEnumNiveauTypeWithAggregatesFilter | NiveauType
    _count?: NestedIntFilter
    _min?: NestedEnumNiveauTypeFilter
    _max?: NestedEnumNiveauTypeFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumProfesseurRoleFilter = {
    equals?: ProfesseurRole
    in?: Enumerable<ProfesseurRole>
    notIn?: Enumerable<ProfesseurRole>
    not?: NestedEnumProfesseurRoleFilter | ProfesseurRole
  }

  export type NestedEnumProfesseurRoleWithAggregatesFilter = {
    equals?: ProfesseurRole
    in?: Enumerable<ProfesseurRole>
    notIn?: Enumerable<ProfesseurRole>
    not?: NestedEnumProfesseurRoleWithAggregatesFilter | ProfesseurRole
    _count?: NestedIntFilter
    _min?: NestedEnumProfesseurRoleFilter
    _max?: NestedEnumProfesseurRoleFilter
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedEnumDocumentCategorieFilter = {
    equals?: DocumentCategorie
    in?: Enumerable<DocumentCategorie>
    notIn?: Enumerable<DocumentCategorie>
    not?: NestedEnumDocumentCategorieFilter | DocumentCategorie
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type NestedEnumDocumentCategorieWithAggregatesFilter = {
    equals?: DocumentCategorie
    in?: Enumerable<DocumentCategorie>
    notIn?: Enumerable<DocumentCategorie>
    not?: NestedEnumDocumentCategorieWithAggregatesFilter | DocumentCategorie
    _count?: NestedIntFilter
    _min?: NestedEnumDocumentCategorieFilter
    _max?: NestedEnumDocumentCategorieFilter
  }

  export type NestedEnumAuditActionFilter = {
    equals?: AuditAction
    in?: Enumerable<AuditAction>
    notIn?: Enumerable<AuditAction>
    not?: NestedEnumAuditActionFilter | AuditAction
  }

  export type NestedEnumAuditActionWithAggregatesFilter = {
    equals?: AuditAction
    in?: Enumerable<AuditAction>
    notIn?: Enumerable<AuditAction>
    not?: NestedEnumAuditActionWithAggregatesFilter | AuditAction
    _count?: NestedIntFilter
    _min?: NestedEnumAuditActionFilter
    _max?: NestedEnumAuditActionFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type FiliereCreateWithoutUsersInput = {
    id?: string
    nom: string
    code: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    niveau: NiveauCreateNestedOneWithoutFilieresInput
    matieres?: MatiereCreateNestedManyWithoutFiliereInput
  }

  export type FiliereUncheckedCreateWithoutUsersInput = {
    id?: string
    nom: string
    code: string
    niveauId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    matieres?: MatiereUncheckedCreateNestedManyWithoutFiliereInput
  }

  export type FiliereCreateOrConnectWithoutUsersInput = {
    where: FiliereWhereUniqueInput
    create: XOR<FiliereCreateWithoutUsersInput, FiliereUncheckedCreateWithoutUsersInput>
  }

  export type NiveauCreateWithoutUsersInput = {
    id?: string
    nom: string
    type: NiveauType
    ordre: number
    filieres?: FiliereCreateNestedManyWithoutNiveauInput
    semestres?: SemestreCreateNestedManyWithoutNiveauInput
  }

  export type NiveauUncheckedCreateWithoutUsersInput = {
    id?: string
    nom: string
    type: NiveauType
    ordre: number
    filieres?: FiliereUncheckedCreateNestedManyWithoutNiveauInput
    semestres?: SemestreUncheckedCreateNestedManyWithoutNiveauInput
  }

  export type NiveauCreateOrConnectWithoutUsersInput = {
    where: NiveauWhereUniqueInput
    create: XOR<NiveauCreateWithoutUsersInput, NiveauUncheckedCreateWithoutUsersInput>
  }

  export type DocumentCreateWithoutUploaderInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere?: MatiereCreateNestedOneWithoutDocumentsInput
    deleter?: UserCreateNestedOneWithoutDeletedDocumentsInput
    commentaires?: CommentaireCreateNestedManyWithoutDocumentInput
    documentPFE?: DocumentPFECreateNestedOneWithoutDocumentInput
    documentMatieres?: DocumentMatiereCreateNestedManyWithoutDocumentInput
    correctionPour?: DocumentCreateNestedOneWithoutCorrectionInput
    correction?: DocumentCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentUncheckedCreateWithoutUploaderInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    matiereId?: string | null
    correctionId?: string | null
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutDocumentInput
    documentPFE?: DocumentPFEUncheckedCreateNestedOneWithoutDocumentInput
    documentMatieres?: DocumentMatiereUncheckedCreateNestedManyWithoutDocumentInput
    correction?: DocumentUncheckedCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentCreateOrConnectWithoutUploaderInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput>
  }

  export type DocumentCreateManyUploaderInputEnvelope = {
    data: Enumerable<DocumentCreateManyUploaderInput>
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutDeleterInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere?: MatiereCreateNestedOneWithoutDocumentsInput
    uploader: UserCreateNestedOneWithoutDocumentsInput
    commentaires?: CommentaireCreateNestedManyWithoutDocumentInput
    documentPFE?: DocumentPFECreateNestedOneWithoutDocumentInput
    documentMatieres?: DocumentMatiereCreateNestedManyWithoutDocumentInput
    correctionPour?: DocumentCreateNestedOneWithoutCorrectionInput
    correction?: DocumentCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentUncheckedCreateWithoutDeleterInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    matiereId?: string | null
    telchargePar: string
    correctionId?: string | null
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutDocumentInput
    documentPFE?: DocumentPFEUncheckedCreateNestedOneWithoutDocumentInput
    documentMatieres?: DocumentMatiereUncheckedCreateNestedManyWithoutDocumentInput
    correction?: DocumentUncheckedCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentCreateOrConnectWithoutDeleterInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutDeleterInput, DocumentUncheckedCreateWithoutDeleterInput>
  }

  export type DocumentCreateManyDeleterInputEnvelope = {
    data: Enumerable<DocumentCreateManyDeleterInput>
    skipDuplicates?: boolean
  }

  export type CommentaireCreateWithoutUserInput = {
    id?: string
    contenu: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentCreateNestedOneWithoutCommentairesInput
    parent?: CommentaireCreateNestedOneWithoutRepliesInput
    replies?: CommentaireCreateNestedManyWithoutParentInput
  }

  export type CommentaireUncheckedCreateWithoutUserInput = {
    id?: string
    contenu: string
    documentId: string
    parentId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentaireUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentaireCreateOrConnectWithoutUserInput = {
    where: CommentaireWhereUniqueInput
    create: XOR<CommentaireCreateWithoutUserInput, CommentaireUncheckedCreateWithoutUserInput>
  }

  export type CommentaireCreateManyUserInputEnvelope = {
    data: Enumerable<CommentaireCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ProfesseurMatiereCreateWithoutProfesseurInput = {
    id?: string
    role: ProfesseurRole
    createdAt?: Date | string
    matiere: MatiereCreateNestedOneWithoutProfesseurMatieresInput
  }

  export type ProfesseurMatiereUncheckedCreateWithoutProfesseurInput = {
    id?: string
    matiereId: string
    role: ProfesseurRole
    createdAt?: Date | string
  }

  export type ProfesseurMatiereCreateOrConnectWithoutProfesseurInput = {
    where: ProfesseurMatiereWhereUniqueInput
    create: XOR<ProfesseurMatiereCreateWithoutProfesseurInput, ProfesseurMatiereUncheckedCreateWithoutProfesseurInput>
  }

  export type ProfesseurMatiereCreateManyProfesseurInputEnvelope = {
    data: Enumerable<ProfesseurMatiereCreateManyProfesseurInput>
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: AuditAction
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: AuditAction
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: Enumerable<AuditLogCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FiliereUpsertWithoutUsersInput = {
    update: XOR<FiliereUpdateWithoutUsersInput, FiliereUncheckedUpdateWithoutUsersInput>
    create: XOR<FiliereCreateWithoutUsersInput, FiliereUncheckedCreateWithoutUsersInput>
  }

  export type FiliereUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    niveau?: NiveauUpdateOneRequiredWithoutFilieresNestedInput
    matieres?: MatiereUpdateManyWithoutFiliereNestedInput
  }

  export type FiliereUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveauId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matieres?: MatiereUncheckedUpdateManyWithoutFiliereNestedInput
  }

  export type NiveauUpsertWithoutUsersInput = {
    update: XOR<NiveauUpdateWithoutUsersInput, NiveauUncheckedUpdateWithoutUsersInput>
    create: XOR<NiveauCreateWithoutUsersInput, NiveauUncheckedCreateWithoutUsersInput>
  }

  export type NiveauUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumNiveauTypeFieldUpdateOperationsInput | NiveauType
    ordre?: IntFieldUpdateOperationsInput | number
    filieres?: FiliereUpdateManyWithoutNiveauNestedInput
    semestres?: SemestreUpdateManyWithoutNiveauNestedInput
  }

  export type NiveauUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumNiveauTypeFieldUpdateOperationsInput | NiveauType
    ordre?: IntFieldUpdateOperationsInput | number
    filieres?: FiliereUncheckedUpdateManyWithoutNiveauNestedInput
    semestres?: SemestreUncheckedUpdateManyWithoutNiveauNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutUploaderInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUploaderInput, DocumentUncheckedUpdateWithoutUploaderInput>
    create: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUploaderInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUploaderInput, DocumentUncheckedUpdateWithoutUploaderInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUploaderInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: Enumerable<DocumentScalarWhereInput>
    OR?: Enumerable<DocumentScalarWhereInput>
    NOT?: Enumerable<DocumentScalarWhereInput>
    id?: StringFilter | string
    titre?: StringFilter | string
    description?: StringNullableFilter | string | null
    cheminFichier?: StringFilter | string
    nomFichier?: StringFilter | string
    tailleFichier?: BigIntFilter | bigint | number
    typeMime?: StringFilter | string
    categorie?: EnumDocumentCategorieFilter | DocumentCategorie
    matiereId?: StringNullableFilter | string | null
    telchargePar?: StringFilter | string
    correctionId?: StringNullableFilter | string | null
    downloadCount?: IntFilter | number
    viewCount?: IntFilter | number
    isDeleted?: BoolFilter | boolean
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutDeleterInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutDeleterInput, DocumentUncheckedUpdateWithoutDeleterInput>
    create: XOR<DocumentCreateWithoutDeleterInput, DocumentUncheckedCreateWithoutDeleterInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutDeleterInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutDeleterInput, DocumentUncheckedUpdateWithoutDeleterInput>
  }

  export type DocumentUpdateManyWithWhereWithoutDeleterInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDeletedDocumentsInput>
  }

  export type CommentaireUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentaireWhereUniqueInput
    update: XOR<CommentaireUpdateWithoutUserInput, CommentaireUncheckedUpdateWithoutUserInput>
    create: XOR<CommentaireCreateWithoutUserInput, CommentaireUncheckedCreateWithoutUserInput>
  }

  export type CommentaireUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentaireWhereUniqueInput
    data: XOR<CommentaireUpdateWithoutUserInput, CommentaireUncheckedUpdateWithoutUserInput>
  }

  export type CommentaireUpdateManyWithWhereWithoutUserInput = {
    where: CommentaireScalarWhereInput
    data: XOR<CommentaireUpdateManyMutationInput, CommentaireUncheckedUpdateManyWithoutCommentairesInput>
  }

  export type CommentaireScalarWhereInput = {
    AND?: Enumerable<CommentaireScalarWhereInput>
    OR?: Enumerable<CommentaireScalarWhereInput>
    NOT?: Enumerable<CommentaireScalarWhereInput>
    id?: StringFilter | string
    contenu?: StringFilter | string
    documentId?: StringFilter | string
    userId?: StringFilter | string
    parentId?: StringNullableFilter | string | null
    isDeleted?: BoolFilter | boolean
    deletedAt?: DateTimeNullableFilter | Date | string | null
    deletedBy?: StringNullableFilter | string | null
    isEdited?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ProfesseurMatiereUpsertWithWhereUniqueWithoutProfesseurInput = {
    where: ProfesseurMatiereWhereUniqueInput
    update: XOR<ProfesseurMatiereUpdateWithoutProfesseurInput, ProfesseurMatiereUncheckedUpdateWithoutProfesseurInput>
    create: XOR<ProfesseurMatiereCreateWithoutProfesseurInput, ProfesseurMatiereUncheckedCreateWithoutProfesseurInput>
  }

  export type ProfesseurMatiereUpdateWithWhereUniqueWithoutProfesseurInput = {
    where: ProfesseurMatiereWhereUniqueInput
    data: XOR<ProfesseurMatiereUpdateWithoutProfesseurInput, ProfesseurMatiereUncheckedUpdateWithoutProfesseurInput>
  }

  export type ProfesseurMatiereUpdateManyWithWhereWithoutProfesseurInput = {
    where: ProfesseurMatiereScalarWhereInput
    data: XOR<ProfesseurMatiereUpdateManyMutationInput, ProfesseurMatiereUncheckedUpdateManyWithoutProfesseurMatieresInput>
  }

  export type ProfesseurMatiereScalarWhereInput = {
    AND?: Enumerable<ProfesseurMatiereScalarWhereInput>
    OR?: Enumerable<ProfesseurMatiereScalarWhereInput>
    NOT?: Enumerable<ProfesseurMatiereScalarWhereInput>
    id?: StringFilter | string
    professeurId?: StringFilter | string
    matiereId?: StringFilter | string
    role?: EnumProfesseurRoleFilter | ProfesseurRole
    createdAt?: DateTimeFilter | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutAuditLogsInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: Enumerable<AuditLogScalarWhereInput>
    OR?: Enumerable<AuditLogScalarWhereInput>
    NOT?: Enumerable<AuditLogScalarWhereInput>
    id?: StringFilter | string
    userId?: StringNullableFilter | string | null
    action?: EnumAuditActionFilter | AuditAction
    resource?: StringNullableFilter | string | null
    resourceId?: StringNullableFilter | string | null
    details?: JsonNullableFilter
    ipAddress?: StringNullableFilter | string | null
    userAgent?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type FiliereCreateWithoutNiveauInput = {
    id?: string
    nom: string
    code: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    matieres?: MatiereCreateNestedManyWithoutFiliereInput
    users?: UserCreateNestedManyWithoutFiliereInput
  }

  export type FiliereUncheckedCreateWithoutNiveauInput = {
    id?: string
    nom: string
    code: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    matieres?: MatiereUncheckedCreateNestedManyWithoutFiliereInput
    users?: UserUncheckedCreateNestedManyWithoutFiliereInput
  }

  export type FiliereCreateOrConnectWithoutNiveauInput = {
    where: FiliereWhereUniqueInput
    create: XOR<FiliereCreateWithoutNiveauInput, FiliereUncheckedCreateWithoutNiveauInput>
  }

  export type FiliereCreateManyNiveauInputEnvelope = {
    data: Enumerable<FiliereCreateManyNiveauInput>
    skipDuplicates?: boolean
  }

  export type SemestreCreateWithoutNiveauInput = {
    id?: string
    nom: string
    ordre: number
    matieres?: MatiereCreateNestedManyWithoutSemestreInput
  }

  export type SemestreUncheckedCreateWithoutNiveauInput = {
    id?: string
    nom: string
    ordre: number
    matieres?: MatiereUncheckedCreateNestedManyWithoutSemestreInput
  }

  export type SemestreCreateOrConnectWithoutNiveauInput = {
    where: SemestreWhereUniqueInput
    create: XOR<SemestreCreateWithoutNiveauInput, SemestreUncheckedCreateWithoutNiveauInput>
  }

  export type SemestreCreateManyNiveauInputEnvelope = {
    data: Enumerable<SemestreCreateManyNiveauInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutNiveauInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    filiere?: FiliereCreateNestedOneWithoutUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentCreateNestedManyWithoutDeleterInput
    commentaires?: CommentaireCreateNestedManyWithoutUserInput
    professeurMatieres?: ProfesseurMatiereCreateNestedManyWithoutProfesseurInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNiveauInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    filiereId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentUncheckedCreateNestedManyWithoutDeleterInput
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutUserInput
    professeurMatieres?: ProfesseurMatiereUncheckedCreateNestedManyWithoutProfesseurInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNiveauInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNiveauInput, UserUncheckedCreateWithoutNiveauInput>
  }

  export type UserCreateManyNiveauInputEnvelope = {
    data: Enumerable<UserCreateManyNiveauInput>
    skipDuplicates?: boolean
  }

  export type FiliereUpsertWithWhereUniqueWithoutNiveauInput = {
    where: FiliereWhereUniqueInput
    update: XOR<FiliereUpdateWithoutNiveauInput, FiliereUncheckedUpdateWithoutNiveauInput>
    create: XOR<FiliereCreateWithoutNiveauInput, FiliereUncheckedCreateWithoutNiveauInput>
  }

  export type FiliereUpdateWithWhereUniqueWithoutNiveauInput = {
    where: FiliereWhereUniqueInput
    data: XOR<FiliereUpdateWithoutNiveauInput, FiliereUncheckedUpdateWithoutNiveauInput>
  }

  export type FiliereUpdateManyWithWhereWithoutNiveauInput = {
    where: FiliereScalarWhereInput
    data: XOR<FiliereUpdateManyMutationInput, FiliereUncheckedUpdateManyWithoutFilieresInput>
  }

  export type FiliereScalarWhereInput = {
    AND?: Enumerable<FiliereScalarWhereInput>
    OR?: Enumerable<FiliereScalarWhereInput>
    NOT?: Enumerable<FiliereScalarWhereInput>
    id?: StringFilter | string
    nom?: StringFilter | string
    code?: StringFilter | string
    niveauId?: StringFilter | string
    isDeleted?: BoolFilter | boolean
    deletedAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type SemestreUpsertWithWhereUniqueWithoutNiveauInput = {
    where: SemestreWhereUniqueInput
    update: XOR<SemestreUpdateWithoutNiveauInput, SemestreUncheckedUpdateWithoutNiveauInput>
    create: XOR<SemestreCreateWithoutNiveauInput, SemestreUncheckedCreateWithoutNiveauInput>
  }

  export type SemestreUpdateWithWhereUniqueWithoutNiveauInput = {
    where: SemestreWhereUniqueInput
    data: XOR<SemestreUpdateWithoutNiveauInput, SemestreUncheckedUpdateWithoutNiveauInput>
  }

  export type SemestreUpdateManyWithWhereWithoutNiveauInput = {
    where: SemestreScalarWhereInput
    data: XOR<SemestreUpdateManyMutationInput, SemestreUncheckedUpdateManyWithoutSemestresInput>
  }

  export type SemestreScalarWhereInput = {
    AND?: Enumerable<SemestreScalarWhereInput>
    OR?: Enumerable<SemestreScalarWhereInput>
    NOT?: Enumerable<SemestreScalarWhereInput>
    id?: StringFilter | string
    nom?: StringFilter | string
    niveauId?: StringFilter | string
    ordre?: IntFilter | number
  }

  export type UserUpsertWithWhereUniqueWithoutNiveauInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutNiveauInput, UserUncheckedUpdateWithoutNiveauInput>
    create: XOR<UserCreateWithoutNiveauInput, UserUncheckedCreateWithoutNiveauInput>
  }

  export type UserUpdateWithWhereUniqueWithoutNiveauInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutNiveauInput, UserUncheckedUpdateWithoutNiveauInput>
  }

  export type UserUpdateManyWithWhereWithoutNiveauInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    prenom?: StringFilter | string
    nom?: StringFilter | string
    role?: EnumUserRoleFilter | UserRole
    isActive?: BoolFilter | boolean
    filiereId?: StringNullableFilter | string | null
    niveauId?: StringNullableFilter | string | null
    resetToken?: StringNullableFilter | string | null
    resetTokenExpiry?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type NiveauCreateWithoutFilieresInput = {
    id?: string
    nom: string
    type: NiveauType
    ordre: number
    semestres?: SemestreCreateNestedManyWithoutNiveauInput
    users?: UserCreateNestedManyWithoutNiveauInput
  }

  export type NiveauUncheckedCreateWithoutFilieresInput = {
    id?: string
    nom: string
    type: NiveauType
    ordre: number
    semestres?: SemestreUncheckedCreateNestedManyWithoutNiveauInput
    users?: UserUncheckedCreateNestedManyWithoutNiveauInput
  }

  export type NiveauCreateOrConnectWithoutFilieresInput = {
    where: NiveauWhereUniqueInput
    create: XOR<NiveauCreateWithoutFilieresInput, NiveauUncheckedCreateWithoutFilieresInput>
  }

  export type MatiereCreateWithoutFiliereInput = {
    id?: string
    nom: string
    code: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    semestre: SemestreCreateNestedOneWithoutMatieresInput
    documents?: DocumentCreateNestedManyWithoutMatiereInput
    documentMatieres?: DocumentMatiereCreateNestedManyWithoutMatiereInput
    professeurMatieres?: ProfesseurMatiereCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateWithoutFiliereInput = {
    id?: string
    nom: string
    code: string
    semestreId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutMatiereInput
    documentMatieres?: DocumentMatiereUncheckedCreateNestedManyWithoutMatiereInput
    professeurMatieres?: ProfesseurMatiereUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereCreateOrConnectWithoutFiliereInput = {
    where: MatiereWhereUniqueInput
    create: XOR<MatiereCreateWithoutFiliereInput, MatiereUncheckedCreateWithoutFiliereInput>
  }

  export type MatiereCreateManyFiliereInputEnvelope = {
    data: Enumerable<MatiereCreateManyFiliereInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutFiliereInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    niveau?: NiveauCreateNestedOneWithoutUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentCreateNestedManyWithoutDeleterInput
    commentaires?: CommentaireCreateNestedManyWithoutUserInput
    professeurMatieres?: ProfesseurMatiereCreateNestedManyWithoutProfesseurInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFiliereInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    niveauId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentUncheckedCreateNestedManyWithoutDeleterInput
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutUserInput
    professeurMatieres?: ProfesseurMatiereUncheckedCreateNestedManyWithoutProfesseurInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFiliereInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFiliereInput, UserUncheckedCreateWithoutFiliereInput>
  }

  export type UserCreateManyFiliereInputEnvelope = {
    data: Enumerable<UserCreateManyFiliereInput>
    skipDuplicates?: boolean
  }

  export type NiveauUpsertWithoutFilieresInput = {
    update: XOR<NiveauUpdateWithoutFilieresInput, NiveauUncheckedUpdateWithoutFilieresInput>
    create: XOR<NiveauCreateWithoutFilieresInput, NiveauUncheckedCreateWithoutFilieresInput>
  }

  export type NiveauUpdateWithoutFilieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumNiveauTypeFieldUpdateOperationsInput | NiveauType
    ordre?: IntFieldUpdateOperationsInput | number
    semestres?: SemestreUpdateManyWithoutNiveauNestedInput
    users?: UserUpdateManyWithoutNiveauNestedInput
  }

  export type NiveauUncheckedUpdateWithoutFilieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumNiveauTypeFieldUpdateOperationsInput | NiveauType
    ordre?: IntFieldUpdateOperationsInput | number
    semestres?: SemestreUncheckedUpdateManyWithoutNiveauNestedInput
    users?: UserUncheckedUpdateManyWithoutNiveauNestedInput
  }

  export type MatiereUpsertWithWhereUniqueWithoutFiliereInput = {
    where: MatiereWhereUniqueInput
    update: XOR<MatiereUpdateWithoutFiliereInput, MatiereUncheckedUpdateWithoutFiliereInput>
    create: XOR<MatiereCreateWithoutFiliereInput, MatiereUncheckedCreateWithoutFiliereInput>
  }

  export type MatiereUpdateWithWhereUniqueWithoutFiliereInput = {
    where: MatiereWhereUniqueInput
    data: XOR<MatiereUpdateWithoutFiliereInput, MatiereUncheckedUpdateWithoutFiliereInput>
  }

  export type MatiereUpdateManyWithWhereWithoutFiliereInput = {
    where: MatiereScalarWhereInput
    data: XOR<MatiereUpdateManyMutationInput, MatiereUncheckedUpdateManyWithoutMatieresInput>
  }

  export type MatiereScalarWhereInput = {
    AND?: Enumerable<MatiereScalarWhereInput>
    OR?: Enumerable<MatiereScalarWhereInput>
    NOT?: Enumerable<MatiereScalarWhereInput>
    id?: StringFilter | string
    nom?: StringFilter | string
    code?: StringFilter | string
    filiereId?: StringFilter | string
    semestreId?: StringFilter | string
    isDeleted?: BoolFilter | boolean
    deletedAt?: DateTimeNullableFilter | Date | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutFiliereInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutFiliereInput, UserUncheckedUpdateWithoutFiliereInput>
    create: XOR<UserCreateWithoutFiliereInput, UserUncheckedCreateWithoutFiliereInput>
  }

  export type UserUpdateWithWhereUniqueWithoutFiliereInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutFiliereInput, UserUncheckedUpdateWithoutFiliereInput>
  }

  export type UserUpdateManyWithWhereWithoutFiliereInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type NiveauCreateWithoutSemestresInput = {
    id?: string
    nom: string
    type: NiveauType
    ordre: number
    filieres?: FiliereCreateNestedManyWithoutNiveauInput
    users?: UserCreateNestedManyWithoutNiveauInput
  }

  export type NiveauUncheckedCreateWithoutSemestresInput = {
    id?: string
    nom: string
    type: NiveauType
    ordre: number
    filieres?: FiliereUncheckedCreateNestedManyWithoutNiveauInput
    users?: UserUncheckedCreateNestedManyWithoutNiveauInput
  }

  export type NiveauCreateOrConnectWithoutSemestresInput = {
    where: NiveauWhereUniqueInput
    create: XOR<NiveauCreateWithoutSemestresInput, NiveauUncheckedCreateWithoutSemestresInput>
  }

  export type MatiereCreateWithoutSemestreInput = {
    id?: string
    nom: string
    code: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    filiere: FiliereCreateNestedOneWithoutMatieresInput
    documents?: DocumentCreateNestedManyWithoutMatiereInput
    documentMatieres?: DocumentMatiereCreateNestedManyWithoutMatiereInput
    professeurMatieres?: ProfesseurMatiereCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateWithoutSemestreInput = {
    id?: string
    nom: string
    code: string
    filiereId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutMatiereInput
    documentMatieres?: DocumentMatiereUncheckedCreateNestedManyWithoutMatiereInput
    professeurMatieres?: ProfesseurMatiereUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereCreateOrConnectWithoutSemestreInput = {
    where: MatiereWhereUniqueInput
    create: XOR<MatiereCreateWithoutSemestreInput, MatiereUncheckedCreateWithoutSemestreInput>
  }

  export type MatiereCreateManySemestreInputEnvelope = {
    data: Enumerable<MatiereCreateManySemestreInput>
    skipDuplicates?: boolean
  }

  export type NiveauUpsertWithoutSemestresInput = {
    update: XOR<NiveauUpdateWithoutSemestresInput, NiveauUncheckedUpdateWithoutSemestresInput>
    create: XOR<NiveauCreateWithoutSemestresInput, NiveauUncheckedCreateWithoutSemestresInput>
  }

  export type NiveauUpdateWithoutSemestresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumNiveauTypeFieldUpdateOperationsInput | NiveauType
    ordre?: IntFieldUpdateOperationsInput | number
    filieres?: FiliereUpdateManyWithoutNiveauNestedInput
    users?: UserUpdateManyWithoutNiveauNestedInput
  }

  export type NiveauUncheckedUpdateWithoutSemestresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: EnumNiveauTypeFieldUpdateOperationsInput | NiveauType
    ordre?: IntFieldUpdateOperationsInput | number
    filieres?: FiliereUncheckedUpdateManyWithoutNiveauNestedInput
    users?: UserUncheckedUpdateManyWithoutNiveauNestedInput
  }

  export type MatiereUpsertWithWhereUniqueWithoutSemestreInput = {
    where: MatiereWhereUniqueInput
    update: XOR<MatiereUpdateWithoutSemestreInput, MatiereUncheckedUpdateWithoutSemestreInput>
    create: XOR<MatiereCreateWithoutSemestreInput, MatiereUncheckedCreateWithoutSemestreInput>
  }

  export type MatiereUpdateWithWhereUniqueWithoutSemestreInput = {
    where: MatiereWhereUniqueInput
    data: XOR<MatiereUpdateWithoutSemestreInput, MatiereUncheckedUpdateWithoutSemestreInput>
  }

  export type MatiereUpdateManyWithWhereWithoutSemestreInput = {
    where: MatiereScalarWhereInput
    data: XOR<MatiereUpdateManyMutationInput, MatiereUncheckedUpdateManyWithoutMatieresInput>
  }

  export type FiliereCreateWithoutMatieresInput = {
    id?: string
    nom: string
    code: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    niveau: NiveauCreateNestedOneWithoutFilieresInput
    users?: UserCreateNestedManyWithoutFiliereInput
  }

  export type FiliereUncheckedCreateWithoutMatieresInput = {
    id?: string
    nom: string
    code: string
    niveauId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutFiliereInput
  }

  export type FiliereCreateOrConnectWithoutMatieresInput = {
    where: FiliereWhereUniqueInput
    create: XOR<FiliereCreateWithoutMatieresInput, FiliereUncheckedCreateWithoutMatieresInput>
  }

  export type SemestreCreateWithoutMatieresInput = {
    id?: string
    nom: string
    ordre: number
    niveau: NiveauCreateNestedOneWithoutSemestresInput
  }

  export type SemestreUncheckedCreateWithoutMatieresInput = {
    id?: string
    nom: string
    niveauId: string
    ordre: number
  }

  export type SemestreCreateOrConnectWithoutMatieresInput = {
    where: SemestreWhereUniqueInput
    create: XOR<SemestreCreateWithoutMatieresInput, SemestreUncheckedCreateWithoutMatieresInput>
  }

  export type DocumentCreateWithoutMatiereInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uploader: UserCreateNestedOneWithoutDocumentsInput
    deleter?: UserCreateNestedOneWithoutDeletedDocumentsInput
    commentaires?: CommentaireCreateNestedManyWithoutDocumentInput
    documentPFE?: DocumentPFECreateNestedOneWithoutDocumentInput
    documentMatieres?: DocumentMatiereCreateNestedManyWithoutDocumentInput
    correctionPour?: DocumentCreateNestedOneWithoutCorrectionInput
    correction?: DocumentCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentUncheckedCreateWithoutMatiereInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    telchargePar: string
    correctionId?: string | null
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutDocumentInput
    documentPFE?: DocumentPFEUncheckedCreateNestedOneWithoutDocumentInput
    documentMatieres?: DocumentMatiereUncheckedCreateNestedManyWithoutDocumentInput
    correction?: DocumentUncheckedCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentCreateOrConnectWithoutMatiereInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutMatiereInput, DocumentUncheckedCreateWithoutMatiereInput>
  }

  export type DocumentCreateManyMatiereInputEnvelope = {
    data: Enumerable<DocumentCreateManyMatiereInput>
    skipDuplicates?: boolean
  }

  export type DocumentMatiereCreateWithoutMatiereInput = {
    id?: string
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutDocumentMatieresInput
  }

  export type DocumentMatiereUncheckedCreateWithoutMatiereInput = {
    id?: string
    documentId: string
    createdAt?: Date | string
  }

  export type DocumentMatiereCreateOrConnectWithoutMatiereInput = {
    where: DocumentMatiereWhereUniqueInput
    create: XOR<DocumentMatiereCreateWithoutMatiereInput, DocumentMatiereUncheckedCreateWithoutMatiereInput>
  }

  export type DocumentMatiereCreateManyMatiereInputEnvelope = {
    data: Enumerable<DocumentMatiereCreateManyMatiereInput>
    skipDuplicates?: boolean
  }

  export type ProfesseurMatiereCreateWithoutMatiereInput = {
    id?: string
    role: ProfesseurRole
    createdAt?: Date | string
    professeur: UserCreateNestedOneWithoutProfesseurMatieresInput
  }

  export type ProfesseurMatiereUncheckedCreateWithoutMatiereInput = {
    id?: string
    professeurId: string
    role: ProfesseurRole
    createdAt?: Date | string
  }

  export type ProfesseurMatiereCreateOrConnectWithoutMatiereInput = {
    where: ProfesseurMatiereWhereUniqueInput
    create: XOR<ProfesseurMatiereCreateWithoutMatiereInput, ProfesseurMatiereUncheckedCreateWithoutMatiereInput>
  }

  export type ProfesseurMatiereCreateManyMatiereInputEnvelope = {
    data: Enumerable<ProfesseurMatiereCreateManyMatiereInput>
    skipDuplicates?: boolean
  }

  export type FiliereUpsertWithoutMatieresInput = {
    update: XOR<FiliereUpdateWithoutMatieresInput, FiliereUncheckedUpdateWithoutMatieresInput>
    create: XOR<FiliereCreateWithoutMatieresInput, FiliereUncheckedCreateWithoutMatieresInput>
  }

  export type FiliereUpdateWithoutMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    niveau?: NiveauUpdateOneRequiredWithoutFilieresNestedInput
    users?: UserUpdateManyWithoutFiliereNestedInput
  }

  export type FiliereUncheckedUpdateWithoutMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    niveauId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutFiliereNestedInput
  }

  export type SemestreUpsertWithoutMatieresInput = {
    update: XOR<SemestreUpdateWithoutMatieresInput, SemestreUncheckedUpdateWithoutMatieresInput>
    create: XOR<SemestreCreateWithoutMatieresInput, SemestreUncheckedCreateWithoutMatieresInput>
  }

  export type SemestreUpdateWithoutMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    niveau?: NiveauUpdateOneRequiredWithoutSemestresNestedInput
  }

  export type SemestreUncheckedUpdateWithoutMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    niveauId?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
  }

  export type DocumentUpsertWithWhereUniqueWithoutMatiereInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutMatiereInput, DocumentUncheckedUpdateWithoutMatiereInput>
    create: XOR<DocumentCreateWithoutMatiereInput, DocumentUncheckedCreateWithoutMatiereInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutMatiereInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutMatiereInput, DocumentUncheckedUpdateWithoutMatiereInput>
  }

  export type DocumentUpdateManyWithWhereWithoutMatiereInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type DocumentMatiereUpsertWithWhereUniqueWithoutMatiereInput = {
    where: DocumentMatiereWhereUniqueInput
    update: XOR<DocumentMatiereUpdateWithoutMatiereInput, DocumentMatiereUncheckedUpdateWithoutMatiereInput>
    create: XOR<DocumentMatiereCreateWithoutMatiereInput, DocumentMatiereUncheckedCreateWithoutMatiereInput>
  }

  export type DocumentMatiereUpdateWithWhereUniqueWithoutMatiereInput = {
    where: DocumentMatiereWhereUniqueInput
    data: XOR<DocumentMatiereUpdateWithoutMatiereInput, DocumentMatiereUncheckedUpdateWithoutMatiereInput>
  }

  export type DocumentMatiereUpdateManyWithWhereWithoutMatiereInput = {
    where: DocumentMatiereScalarWhereInput
    data: XOR<DocumentMatiereUpdateManyMutationInput, DocumentMatiereUncheckedUpdateManyWithoutDocumentMatieresInput>
  }

  export type DocumentMatiereScalarWhereInput = {
    AND?: Enumerable<DocumentMatiereScalarWhereInput>
    OR?: Enumerable<DocumentMatiereScalarWhereInput>
    NOT?: Enumerable<DocumentMatiereScalarWhereInput>
    id?: StringFilter | string
    documentId?: StringFilter | string
    matiereId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type ProfesseurMatiereUpsertWithWhereUniqueWithoutMatiereInput = {
    where: ProfesseurMatiereWhereUniqueInput
    update: XOR<ProfesseurMatiereUpdateWithoutMatiereInput, ProfesseurMatiereUncheckedUpdateWithoutMatiereInput>
    create: XOR<ProfesseurMatiereCreateWithoutMatiereInput, ProfesseurMatiereUncheckedCreateWithoutMatiereInput>
  }

  export type ProfesseurMatiereUpdateWithWhereUniqueWithoutMatiereInput = {
    where: ProfesseurMatiereWhereUniqueInput
    data: XOR<ProfesseurMatiereUpdateWithoutMatiereInput, ProfesseurMatiereUncheckedUpdateWithoutMatiereInput>
  }

  export type ProfesseurMatiereUpdateManyWithWhereWithoutMatiereInput = {
    where: ProfesseurMatiereScalarWhereInput
    data: XOR<ProfesseurMatiereUpdateManyMutationInput, ProfesseurMatiereUncheckedUpdateManyWithoutProfesseurMatieresInput>
  }

  export type UserCreateWithoutProfesseurMatieresInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    filiere?: FiliereCreateNestedOneWithoutUsersInput
    niveau?: NiveauCreateNestedOneWithoutUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentCreateNestedManyWithoutDeleterInput
    commentaires?: CommentaireCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfesseurMatieresInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    filiereId?: string | null
    niveauId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentUncheckedCreateNestedManyWithoutDeleterInput
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfesseurMatieresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfesseurMatieresInput, UserUncheckedCreateWithoutProfesseurMatieresInput>
  }

  export type MatiereCreateWithoutProfesseurMatieresInput = {
    id?: string
    nom: string
    code: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    filiere: FiliereCreateNestedOneWithoutMatieresInput
    semestre: SemestreCreateNestedOneWithoutMatieresInput
    documents?: DocumentCreateNestedManyWithoutMatiereInput
    documentMatieres?: DocumentMatiereCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateWithoutProfesseurMatieresInput = {
    id?: string
    nom: string
    code: string
    filiereId: string
    semestreId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutMatiereInput
    documentMatieres?: DocumentMatiereUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereCreateOrConnectWithoutProfesseurMatieresInput = {
    where: MatiereWhereUniqueInput
    create: XOR<MatiereCreateWithoutProfesseurMatieresInput, MatiereUncheckedCreateWithoutProfesseurMatieresInput>
  }

  export type UserUpsertWithoutProfesseurMatieresInput = {
    update: XOR<UserUpdateWithoutProfesseurMatieresInput, UserUncheckedUpdateWithoutProfesseurMatieresInput>
    create: XOR<UserCreateWithoutProfesseurMatieresInput, UserUncheckedCreateWithoutProfesseurMatieresInput>
  }

  export type UserUpdateWithoutProfesseurMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filiere?: FiliereUpdateOneWithoutUsersNestedInput
    niveau?: NiveauUpdateOneWithoutUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUpdateManyWithoutDeleterNestedInput
    commentaires?: CommentaireUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfesseurMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    filiereId?: NullableStringFieldUpdateOperationsInput | string | null
    niveauId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUncheckedUpdateManyWithoutDeleterNestedInput
    commentaires?: CommentaireUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MatiereUpsertWithoutProfesseurMatieresInput = {
    update: XOR<MatiereUpdateWithoutProfesseurMatieresInput, MatiereUncheckedUpdateWithoutProfesseurMatieresInput>
    create: XOR<MatiereCreateWithoutProfesseurMatieresInput, MatiereUncheckedCreateWithoutProfesseurMatieresInput>
  }

  export type MatiereUpdateWithoutProfesseurMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filiere?: FiliereUpdateOneRequiredWithoutMatieresNestedInput
    semestre?: SemestreUpdateOneRequiredWithoutMatieresNestedInput
    documents?: DocumentUpdateManyWithoutMatiereNestedInput
    documentMatieres?: DocumentMatiereUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateWithoutProfesseurMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    filiereId?: StringFieldUpdateOperationsInput | string
    semestreId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutMatiereNestedInput
    documentMatieres?: DocumentMatiereUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereCreateWithoutDocumentsInput = {
    id?: string
    nom: string
    code: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    filiere: FiliereCreateNestedOneWithoutMatieresInput
    semestre: SemestreCreateNestedOneWithoutMatieresInput
    documentMatieres?: DocumentMatiereCreateNestedManyWithoutMatiereInput
    professeurMatieres?: ProfesseurMatiereCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateWithoutDocumentsInput = {
    id?: string
    nom: string
    code: string
    filiereId: string
    semestreId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    documentMatieres?: DocumentMatiereUncheckedCreateNestedManyWithoutMatiereInput
    professeurMatieres?: ProfesseurMatiereUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereCreateOrConnectWithoutDocumentsInput = {
    where: MatiereWhereUniqueInput
    create: XOR<MatiereCreateWithoutDocumentsInput, MatiereUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutDocumentsInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    filiere?: FiliereCreateNestedOneWithoutUsersInput
    niveau?: NiveauCreateNestedOneWithoutUsersInput
    deletedDocuments?: DocumentCreateNestedManyWithoutDeleterInput
    commentaires?: CommentaireCreateNestedManyWithoutUserInput
    professeurMatieres?: ProfesseurMatiereCreateNestedManyWithoutProfesseurInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    filiereId?: string | null
    niveauId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedDocuments?: DocumentUncheckedCreateNestedManyWithoutDeleterInput
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutUserInput
    professeurMatieres?: ProfesseurMatiereUncheckedCreateNestedManyWithoutProfesseurInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutDeletedDocumentsInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    filiere?: FiliereCreateNestedOneWithoutUsersInput
    niveau?: NiveauCreateNestedOneWithoutUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    commentaires?: CommentaireCreateNestedManyWithoutUserInput
    professeurMatieres?: ProfesseurMatiereCreateNestedManyWithoutProfesseurInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeletedDocumentsInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    filiereId?: string | null
    niveauId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutUserInput
    professeurMatieres?: ProfesseurMatiereUncheckedCreateNestedManyWithoutProfesseurInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeletedDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeletedDocumentsInput, UserUncheckedCreateWithoutDeletedDocumentsInput>
  }

  export type CommentaireCreateWithoutDocumentInput = {
    id?: string
    contenu: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentairesInput
    parent?: CommentaireCreateNestedOneWithoutRepliesInput
    replies?: CommentaireCreateNestedManyWithoutParentInput
  }

  export type CommentaireUncheckedCreateWithoutDocumentInput = {
    id?: string
    contenu: string
    userId: string
    parentId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentaireUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentaireCreateOrConnectWithoutDocumentInput = {
    where: CommentaireWhereUniqueInput
    create: XOR<CommentaireCreateWithoutDocumentInput, CommentaireUncheckedCreateWithoutDocumentInput>
  }

  export type CommentaireCreateManyDocumentInputEnvelope = {
    data: Enumerable<CommentaireCreateManyDocumentInput>
    skipDuplicates?: boolean
  }

  export type DocumentPFECreateWithoutDocumentInput = {
    id?: string
    anneeDiplome: number
    filiereDiplome: string
    titreProjet: string
    resume?: string | null
    motsCles?: DocumentPFECreatemotsClesInput | Enumerable<string>
    createdAt?: Date | string
  }

  export type DocumentPFEUncheckedCreateWithoutDocumentInput = {
    id?: string
    anneeDiplome: number
    filiereDiplome: string
    titreProjet: string
    resume?: string | null
    motsCles?: DocumentPFECreatemotsClesInput | Enumerable<string>
    createdAt?: Date | string
  }

  export type DocumentPFECreateOrConnectWithoutDocumentInput = {
    where: DocumentPFEWhereUniqueInput
    create: XOR<DocumentPFECreateWithoutDocumentInput, DocumentPFEUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentMatiereCreateWithoutDocumentInput = {
    id?: string
    createdAt?: Date | string
    matiere: MatiereCreateNestedOneWithoutDocumentMatieresInput
  }

  export type DocumentMatiereUncheckedCreateWithoutDocumentInput = {
    id?: string
    matiereId: string
    createdAt?: Date | string
  }

  export type DocumentMatiereCreateOrConnectWithoutDocumentInput = {
    where: DocumentMatiereWhereUniqueInput
    create: XOR<DocumentMatiereCreateWithoutDocumentInput, DocumentMatiereUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentMatiereCreateManyDocumentInputEnvelope = {
    data: Enumerable<DocumentMatiereCreateManyDocumentInput>
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutCorrectionInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere?: MatiereCreateNestedOneWithoutDocumentsInput
    uploader: UserCreateNestedOneWithoutDocumentsInput
    deleter?: UserCreateNestedOneWithoutDeletedDocumentsInput
    commentaires?: CommentaireCreateNestedManyWithoutDocumentInput
    documentPFE?: DocumentPFECreateNestedOneWithoutDocumentInput
    documentMatieres?: DocumentMatiereCreateNestedManyWithoutDocumentInput
    correctionPour?: DocumentCreateNestedOneWithoutCorrectionInput
  }

  export type DocumentUncheckedCreateWithoutCorrectionInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    matiereId?: string | null
    telchargePar: string
    correctionId?: string | null
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutDocumentInput
    documentPFE?: DocumentPFEUncheckedCreateNestedOneWithoutDocumentInput
    documentMatieres?: DocumentMatiereUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutCorrectionInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutCorrectionInput, DocumentUncheckedCreateWithoutCorrectionInput>
  }

  export type DocumentCreateWithoutCorrectionPourInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere?: MatiereCreateNestedOneWithoutDocumentsInput
    uploader: UserCreateNestedOneWithoutDocumentsInput
    deleter?: UserCreateNestedOneWithoutDeletedDocumentsInput
    commentaires?: CommentaireCreateNestedManyWithoutDocumentInput
    documentPFE?: DocumentPFECreateNestedOneWithoutDocumentInput
    documentMatieres?: DocumentMatiereCreateNestedManyWithoutDocumentInput
    correction?: DocumentCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentUncheckedCreateWithoutCorrectionPourInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    matiereId?: string | null
    telchargePar: string
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutDocumentInput
    documentPFE?: DocumentPFEUncheckedCreateNestedOneWithoutDocumentInput
    documentMatieres?: DocumentMatiereUncheckedCreateNestedManyWithoutDocumentInput
    correction?: DocumentUncheckedCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentCreateOrConnectWithoutCorrectionPourInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutCorrectionPourInput, DocumentUncheckedCreateWithoutCorrectionPourInput>
  }

  export type MatiereUpsertWithoutDocumentsInput = {
    update: XOR<MatiereUpdateWithoutDocumentsInput, MatiereUncheckedUpdateWithoutDocumentsInput>
    create: XOR<MatiereCreateWithoutDocumentsInput, MatiereUncheckedCreateWithoutDocumentsInput>
  }

  export type MatiereUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filiere?: FiliereUpdateOneRequiredWithoutMatieresNestedInput
    semestre?: SemestreUpdateOneRequiredWithoutMatieresNestedInput
    documentMatieres?: DocumentMatiereUpdateManyWithoutMatiereNestedInput
    professeurMatieres?: ProfesseurMatiereUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    filiereId?: StringFieldUpdateOperationsInput | string
    semestreId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentMatieres?: DocumentMatiereUncheckedUpdateManyWithoutMatiereNestedInput
    professeurMatieres?: ProfesseurMatiereUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filiere?: FiliereUpdateOneWithoutUsersNestedInput
    niveau?: NiveauUpdateOneWithoutUsersNestedInput
    deletedDocuments?: DocumentUpdateManyWithoutDeleterNestedInput
    commentaires?: CommentaireUpdateManyWithoutUserNestedInput
    professeurMatieres?: ProfesseurMatiereUpdateManyWithoutProfesseurNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    filiereId?: NullableStringFieldUpdateOperationsInput | string | null
    niveauId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedDocuments?: DocumentUncheckedUpdateManyWithoutDeleterNestedInput
    commentaires?: CommentaireUncheckedUpdateManyWithoutUserNestedInput
    professeurMatieres?: ProfesseurMatiereUncheckedUpdateManyWithoutProfesseurNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutDeletedDocumentsInput = {
    update: XOR<UserUpdateWithoutDeletedDocumentsInput, UserUncheckedUpdateWithoutDeletedDocumentsInput>
    create: XOR<UserCreateWithoutDeletedDocumentsInput, UserUncheckedCreateWithoutDeletedDocumentsInput>
  }

  export type UserUpdateWithoutDeletedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filiere?: FiliereUpdateOneWithoutUsersNestedInput
    niveau?: NiveauUpdateOneWithoutUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    commentaires?: CommentaireUpdateManyWithoutUserNestedInput
    professeurMatieres?: ProfesseurMatiereUpdateManyWithoutProfesseurNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeletedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    filiereId?: NullableStringFieldUpdateOperationsInput | string | null
    niveauId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    commentaires?: CommentaireUncheckedUpdateManyWithoutUserNestedInput
    professeurMatieres?: ProfesseurMatiereUncheckedUpdateManyWithoutProfesseurNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentaireUpsertWithWhereUniqueWithoutDocumentInput = {
    where: CommentaireWhereUniqueInput
    update: XOR<CommentaireUpdateWithoutDocumentInput, CommentaireUncheckedUpdateWithoutDocumentInput>
    create: XOR<CommentaireCreateWithoutDocumentInput, CommentaireUncheckedCreateWithoutDocumentInput>
  }

  export type CommentaireUpdateWithWhereUniqueWithoutDocumentInput = {
    where: CommentaireWhereUniqueInput
    data: XOR<CommentaireUpdateWithoutDocumentInput, CommentaireUncheckedUpdateWithoutDocumentInput>
  }

  export type CommentaireUpdateManyWithWhereWithoutDocumentInput = {
    where: CommentaireScalarWhereInput
    data: XOR<CommentaireUpdateManyMutationInput, CommentaireUncheckedUpdateManyWithoutCommentairesInput>
  }

  export type DocumentPFEUpsertWithoutDocumentInput = {
    update: XOR<DocumentPFEUpdateWithoutDocumentInput, DocumentPFEUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentPFECreateWithoutDocumentInput, DocumentPFEUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentPFEUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    anneeDiplome?: IntFieldUpdateOperationsInput | number
    filiereDiplome?: StringFieldUpdateOperationsInput | string
    titreProjet?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    motsCles?: DocumentPFEUpdatemotsClesInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPFEUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    anneeDiplome?: IntFieldUpdateOperationsInput | number
    filiereDiplome?: StringFieldUpdateOperationsInput | string
    titreProjet?: StringFieldUpdateOperationsInput | string
    resume?: NullableStringFieldUpdateOperationsInput | string | null
    motsCles?: DocumentPFEUpdatemotsClesInput | Enumerable<string>
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentMatiereUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentMatiereWhereUniqueInput
    update: XOR<DocumentMatiereUpdateWithoutDocumentInput, DocumentMatiereUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentMatiereCreateWithoutDocumentInput, DocumentMatiereUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentMatiereUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentMatiereWhereUniqueInput
    data: XOR<DocumentMatiereUpdateWithoutDocumentInput, DocumentMatiereUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentMatiereUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentMatiereScalarWhereInput
    data: XOR<DocumentMatiereUpdateManyMutationInput, DocumentMatiereUncheckedUpdateManyWithoutDocumentMatieresInput>
  }

  export type DocumentUpsertWithoutCorrectionInput = {
    update: XOR<DocumentUpdateWithoutCorrectionInput, DocumentUncheckedUpdateWithoutCorrectionInput>
    create: XOR<DocumentCreateWithoutCorrectionInput, DocumentUncheckedCreateWithoutCorrectionInput>
  }

  export type DocumentUpdateWithoutCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutDocumentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    deleter?: UserUpdateOneWithoutDeletedDocumentsNestedInput
    commentaires?: CommentaireUpdateManyWithoutDocumentNestedInput
    documentPFE?: DocumentPFEUpdateOneWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUpdateManyWithoutDocumentNestedInput
    correctionPour?: DocumentUpdateOneWithoutCorrectionNestedInput
  }

  export type DocumentUncheckedUpdateWithoutCorrectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    matiereId?: NullableStringFieldUpdateOperationsInput | string | null
    telchargePar?: StringFieldUpdateOperationsInput | string
    correctionId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: CommentaireUncheckedUpdateManyWithoutDocumentNestedInput
    documentPFE?: DocumentPFEUncheckedUpdateOneWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUpsertWithoutCorrectionPourInput = {
    update: XOR<DocumentUpdateWithoutCorrectionPourInput, DocumentUncheckedUpdateWithoutCorrectionPourInput>
    create: XOR<DocumentCreateWithoutCorrectionPourInput, DocumentUncheckedCreateWithoutCorrectionPourInput>
  }

  export type DocumentUpdateWithoutCorrectionPourInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutDocumentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    deleter?: UserUpdateOneWithoutDeletedDocumentsNestedInput
    commentaires?: CommentaireUpdateManyWithoutDocumentNestedInput
    documentPFE?: DocumentPFEUpdateOneWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUpdateManyWithoutDocumentNestedInput
    correction?: DocumentUpdateOneWithoutCorrectionPourNestedInput
  }

  export type DocumentUncheckedUpdateWithoutCorrectionPourInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    matiereId?: NullableStringFieldUpdateOperationsInput | string | null
    telchargePar?: StringFieldUpdateOperationsInput | string
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: CommentaireUncheckedUpdateManyWithoutDocumentNestedInput
    documentPFE?: DocumentPFEUncheckedUpdateOneWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUncheckedUpdateManyWithoutDocumentNestedInput
    correction?: DocumentUncheckedUpdateOneWithoutCorrectionPourNestedInput
  }

  export type DocumentCreateWithoutDocumentPFEInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere?: MatiereCreateNestedOneWithoutDocumentsInput
    uploader: UserCreateNestedOneWithoutDocumentsInput
    deleter?: UserCreateNestedOneWithoutDeletedDocumentsInput
    commentaires?: CommentaireCreateNestedManyWithoutDocumentInput
    documentMatieres?: DocumentMatiereCreateNestedManyWithoutDocumentInput
    correctionPour?: DocumentCreateNestedOneWithoutCorrectionInput
    correction?: DocumentCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentUncheckedCreateWithoutDocumentPFEInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    matiereId?: string | null
    telchargePar: string
    correctionId?: string | null
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutDocumentInput
    documentMatieres?: DocumentMatiereUncheckedCreateNestedManyWithoutDocumentInput
    correction?: DocumentUncheckedCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentCreateOrConnectWithoutDocumentPFEInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutDocumentPFEInput, DocumentUncheckedCreateWithoutDocumentPFEInput>
  }

  export type DocumentUpsertWithoutDocumentPFEInput = {
    update: XOR<DocumentUpdateWithoutDocumentPFEInput, DocumentUncheckedUpdateWithoutDocumentPFEInput>
    create: XOR<DocumentCreateWithoutDocumentPFEInput, DocumentUncheckedCreateWithoutDocumentPFEInput>
  }

  export type DocumentUpdateWithoutDocumentPFEInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutDocumentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    deleter?: UserUpdateOneWithoutDeletedDocumentsNestedInput
    commentaires?: CommentaireUpdateManyWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUpdateManyWithoutDocumentNestedInput
    correctionPour?: DocumentUpdateOneWithoutCorrectionNestedInput
    correction?: DocumentUpdateOneWithoutCorrectionPourNestedInput
  }

  export type DocumentUncheckedUpdateWithoutDocumentPFEInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    matiereId?: NullableStringFieldUpdateOperationsInput | string | null
    telchargePar?: StringFieldUpdateOperationsInput | string
    correctionId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: CommentaireUncheckedUpdateManyWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUncheckedUpdateManyWithoutDocumentNestedInput
    correction?: DocumentUncheckedUpdateOneWithoutCorrectionPourNestedInput
  }

  export type DocumentCreateWithoutCommentairesInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere?: MatiereCreateNestedOneWithoutDocumentsInput
    uploader: UserCreateNestedOneWithoutDocumentsInput
    deleter?: UserCreateNestedOneWithoutDeletedDocumentsInput
    documentPFE?: DocumentPFECreateNestedOneWithoutDocumentInput
    documentMatieres?: DocumentMatiereCreateNestedManyWithoutDocumentInput
    correctionPour?: DocumentCreateNestedOneWithoutCorrectionInput
    correction?: DocumentCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentUncheckedCreateWithoutCommentairesInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    matiereId?: string | null
    telchargePar: string
    correctionId?: string | null
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documentPFE?: DocumentPFEUncheckedCreateNestedOneWithoutDocumentInput
    documentMatieres?: DocumentMatiereUncheckedCreateNestedManyWithoutDocumentInput
    correction?: DocumentUncheckedCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentCreateOrConnectWithoutCommentairesInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutCommentairesInput, DocumentUncheckedCreateWithoutCommentairesInput>
  }

  export type UserCreateWithoutCommentairesInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    filiere?: FiliereCreateNestedOneWithoutUsersInput
    niveau?: NiveauCreateNestedOneWithoutUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentCreateNestedManyWithoutDeleterInput
    professeurMatieres?: ProfesseurMatiereCreateNestedManyWithoutProfesseurInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentairesInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    filiereId?: string | null
    niveauId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentUncheckedCreateNestedManyWithoutDeleterInput
    professeurMatieres?: ProfesseurMatiereUncheckedCreateNestedManyWithoutProfesseurInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentairesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentairesInput, UserUncheckedCreateWithoutCommentairesInput>
  }

  export type CommentaireCreateWithoutRepliesInput = {
    id?: string
    contenu: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentCreateNestedOneWithoutCommentairesInput
    user: UserCreateNestedOneWithoutCommentairesInput
    parent?: CommentaireCreateNestedOneWithoutRepliesInput
  }

  export type CommentaireUncheckedCreateWithoutRepliesInput = {
    id?: string
    contenu: string
    documentId: string
    userId: string
    parentId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentaireCreateOrConnectWithoutRepliesInput = {
    where: CommentaireWhereUniqueInput
    create: XOR<CommentaireCreateWithoutRepliesInput, CommentaireUncheckedCreateWithoutRepliesInput>
  }

  export type CommentaireCreateWithoutParentInput = {
    id?: string
    contenu: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentCreateNestedOneWithoutCommentairesInput
    user: UserCreateNestedOneWithoutCommentairesInput
    replies?: CommentaireCreateNestedManyWithoutParentInput
  }

  export type CommentaireUncheckedCreateWithoutParentInput = {
    id?: string
    contenu: string
    documentId: string
    userId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentaireUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentaireCreateOrConnectWithoutParentInput = {
    where: CommentaireWhereUniqueInput
    create: XOR<CommentaireCreateWithoutParentInput, CommentaireUncheckedCreateWithoutParentInput>
  }

  export type CommentaireCreateManyParentInputEnvelope = {
    data: Enumerable<CommentaireCreateManyParentInput>
    skipDuplicates?: boolean
  }

  export type DocumentUpsertWithoutCommentairesInput = {
    update: XOR<DocumentUpdateWithoutCommentairesInput, DocumentUncheckedUpdateWithoutCommentairesInput>
    create: XOR<DocumentCreateWithoutCommentairesInput, DocumentUncheckedCreateWithoutCommentairesInput>
  }

  export type DocumentUpdateWithoutCommentairesInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutDocumentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    deleter?: UserUpdateOneWithoutDeletedDocumentsNestedInput
    documentPFE?: DocumentPFEUpdateOneWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUpdateManyWithoutDocumentNestedInput
    correctionPour?: DocumentUpdateOneWithoutCorrectionNestedInput
    correction?: DocumentUpdateOneWithoutCorrectionPourNestedInput
  }

  export type DocumentUncheckedUpdateWithoutCommentairesInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    matiereId?: NullableStringFieldUpdateOperationsInput | string | null
    telchargePar?: StringFieldUpdateOperationsInput | string
    correctionId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentPFE?: DocumentPFEUncheckedUpdateOneWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUncheckedUpdateManyWithoutDocumentNestedInput
    correction?: DocumentUncheckedUpdateOneWithoutCorrectionPourNestedInput
  }

  export type UserUpsertWithoutCommentairesInput = {
    update: XOR<UserUpdateWithoutCommentairesInput, UserUncheckedUpdateWithoutCommentairesInput>
    create: XOR<UserCreateWithoutCommentairesInput, UserUncheckedCreateWithoutCommentairesInput>
  }

  export type UserUpdateWithoutCommentairesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filiere?: FiliereUpdateOneWithoutUsersNestedInput
    niveau?: NiveauUpdateOneWithoutUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUpdateManyWithoutDeleterNestedInput
    professeurMatieres?: ProfesseurMatiereUpdateManyWithoutProfesseurNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentairesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    filiereId?: NullableStringFieldUpdateOperationsInput | string | null
    niveauId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUncheckedUpdateManyWithoutDeleterNestedInput
    professeurMatieres?: ProfesseurMatiereUncheckedUpdateManyWithoutProfesseurNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentaireUpsertWithoutRepliesInput = {
    update: XOR<CommentaireUpdateWithoutRepliesInput, CommentaireUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentaireCreateWithoutRepliesInput, CommentaireUncheckedCreateWithoutRepliesInput>
  }

  export type CommentaireUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutCommentairesNestedInput
    user?: UserUpdateOneRequiredWithoutCommentairesNestedInput
    parent?: CommentaireUpdateOneWithoutRepliesNestedInput
  }

  export type CommentaireUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentaireUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentaireWhereUniqueInput
    update: XOR<CommentaireUpdateWithoutParentInput, CommentaireUncheckedUpdateWithoutParentInput>
    create: XOR<CommentaireCreateWithoutParentInput, CommentaireUncheckedCreateWithoutParentInput>
  }

  export type CommentaireUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentaireWhereUniqueInput
    data: XOR<CommentaireUpdateWithoutParentInput, CommentaireUncheckedUpdateWithoutParentInput>
  }

  export type CommentaireUpdateManyWithWhereWithoutParentInput = {
    where: CommentaireScalarWhereInput
    data: XOR<CommentaireUpdateManyMutationInput, CommentaireUncheckedUpdateManyWithoutRepliesInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    filiere?: FiliereCreateNestedOneWithoutUsersInput
    niveau?: NiveauCreateNestedOneWithoutUsersInput
    documents?: DocumentCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentCreateNestedManyWithoutDeleterInput
    commentaires?: CommentaireCreateNestedManyWithoutUserInput
    professeurMatieres?: ProfesseurMatiereCreateNestedManyWithoutProfesseurInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    filiereId?: string | null
    niveauId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    deletedDocuments?: DocumentUncheckedCreateNestedManyWithoutDeleterInput
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutUserInput
    professeurMatieres?: ProfesseurMatiereUncheckedCreateNestedManyWithoutProfesseurInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filiere?: FiliereUpdateOneWithoutUsersNestedInput
    niveau?: NiveauUpdateOneWithoutUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUpdateManyWithoutDeleterNestedInput
    commentaires?: CommentaireUpdateManyWithoutUserNestedInput
    professeurMatieres?: ProfesseurMatiereUpdateManyWithoutProfesseurNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    filiereId?: NullableStringFieldUpdateOperationsInput | string | null
    niveauId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUncheckedUpdateManyWithoutDeleterNestedInput
    commentaires?: CommentaireUncheckedUpdateManyWithoutUserNestedInput
    professeurMatieres?: ProfesseurMatiereUncheckedUpdateManyWithoutProfesseurNestedInput
  }

  export type DocumentCreateWithoutDocumentMatieresInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    matiere?: MatiereCreateNestedOneWithoutDocumentsInput
    uploader: UserCreateNestedOneWithoutDocumentsInput
    deleter?: UserCreateNestedOneWithoutDeletedDocumentsInput
    commentaires?: CommentaireCreateNestedManyWithoutDocumentInput
    documentPFE?: DocumentPFECreateNestedOneWithoutDocumentInput
    correctionPour?: DocumentCreateNestedOneWithoutCorrectionInput
    correction?: DocumentCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentUncheckedCreateWithoutDocumentMatieresInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    matiereId?: string | null
    telchargePar: string
    correctionId?: string | null
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commentaires?: CommentaireUncheckedCreateNestedManyWithoutDocumentInput
    documentPFE?: DocumentPFEUncheckedCreateNestedOneWithoutDocumentInput
    correction?: DocumentUncheckedCreateNestedOneWithoutCorrectionPourInput
  }

  export type DocumentCreateOrConnectWithoutDocumentMatieresInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutDocumentMatieresInput, DocumentUncheckedCreateWithoutDocumentMatieresInput>
  }

  export type MatiereCreateWithoutDocumentMatieresInput = {
    id?: string
    nom: string
    code: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    filiere: FiliereCreateNestedOneWithoutMatieresInput
    semestre: SemestreCreateNestedOneWithoutMatieresInput
    documents?: DocumentCreateNestedManyWithoutMatiereInput
    professeurMatieres?: ProfesseurMatiereCreateNestedManyWithoutMatiereInput
  }

  export type MatiereUncheckedCreateWithoutDocumentMatieresInput = {
    id?: string
    nom: string
    code: string
    filiereId: string
    semestreId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutMatiereInput
    professeurMatieres?: ProfesseurMatiereUncheckedCreateNestedManyWithoutMatiereInput
  }

  export type MatiereCreateOrConnectWithoutDocumentMatieresInput = {
    where: MatiereWhereUniqueInput
    create: XOR<MatiereCreateWithoutDocumentMatieresInput, MatiereUncheckedCreateWithoutDocumentMatieresInput>
  }

  export type DocumentUpsertWithoutDocumentMatieresInput = {
    update: XOR<DocumentUpdateWithoutDocumentMatieresInput, DocumentUncheckedUpdateWithoutDocumentMatieresInput>
    create: XOR<DocumentCreateWithoutDocumentMatieresInput, DocumentUncheckedCreateWithoutDocumentMatieresInput>
  }

  export type DocumentUpdateWithoutDocumentMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutDocumentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    deleter?: UserUpdateOneWithoutDeletedDocumentsNestedInput
    commentaires?: CommentaireUpdateManyWithoutDocumentNestedInput
    documentPFE?: DocumentPFEUpdateOneWithoutDocumentNestedInput
    correctionPour?: DocumentUpdateOneWithoutCorrectionNestedInput
    correction?: DocumentUpdateOneWithoutCorrectionPourNestedInput
  }

  export type DocumentUncheckedUpdateWithoutDocumentMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    matiereId?: NullableStringFieldUpdateOperationsInput | string | null
    telchargePar?: StringFieldUpdateOperationsInput | string
    correctionId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: CommentaireUncheckedUpdateManyWithoutDocumentNestedInput
    documentPFE?: DocumentPFEUncheckedUpdateOneWithoutDocumentNestedInput
    correction?: DocumentUncheckedUpdateOneWithoutCorrectionPourNestedInput
  }

  export type MatiereUpsertWithoutDocumentMatieresInput = {
    update: XOR<MatiereUpdateWithoutDocumentMatieresInput, MatiereUncheckedUpdateWithoutDocumentMatieresInput>
    create: XOR<MatiereCreateWithoutDocumentMatieresInput, MatiereUncheckedCreateWithoutDocumentMatieresInput>
  }

  export type MatiereUpdateWithoutDocumentMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filiere?: FiliereUpdateOneRequiredWithoutMatieresNestedInput
    semestre?: SemestreUpdateOneRequiredWithoutMatieresNestedInput
    documents?: DocumentUpdateManyWithoutMatiereNestedInput
    professeurMatieres?: ProfesseurMatiereUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateWithoutDocumentMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    filiereId?: StringFieldUpdateOperationsInput | string
    semestreId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutMatiereNestedInput
    professeurMatieres?: ProfesseurMatiereUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type DocumentCreateManyUploaderInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    matiereId?: string | null
    correctionId?: string | null
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyDeleterInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    matiereId?: string | null
    telchargePar: string
    correctionId?: string | null
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentaireCreateManyUserInput = {
    id?: string
    contenu: string
    documentId: string
    parentId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfesseurMatiereCreateManyProfesseurInput = {
    id?: string
    matiereId: string
    role: ProfesseurRole
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: AuditAction
    resource?: string | null
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutDocumentsNestedInput
    deleter?: UserUpdateOneWithoutDeletedDocumentsNestedInput
    commentaires?: CommentaireUpdateManyWithoutDocumentNestedInput
    documentPFE?: DocumentPFEUpdateOneWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUpdateManyWithoutDocumentNestedInput
    correctionPour?: DocumentUpdateOneWithoutCorrectionNestedInput
    correction?: DocumentUpdateOneWithoutCorrectionPourNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    matiereId?: NullableStringFieldUpdateOperationsInput | string | null
    correctionId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: CommentaireUncheckedUpdateManyWithoutDocumentNestedInput
    documentPFE?: DocumentPFEUncheckedUpdateOneWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUncheckedUpdateManyWithoutDocumentNestedInput
    correction?: DocumentUncheckedUpdateOneWithoutCorrectionPourNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    matiereId?: NullableStringFieldUpdateOperationsInput | string | null
    correctionId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutDeleterInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneWithoutDocumentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    commentaires?: CommentaireUpdateManyWithoutDocumentNestedInput
    documentPFE?: DocumentPFEUpdateOneWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUpdateManyWithoutDocumentNestedInput
    correctionPour?: DocumentUpdateOneWithoutCorrectionNestedInput
    correction?: DocumentUpdateOneWithoutCorrectionPourNestedInput
  }

  export type DocumentUncheckedUpdateWithoutDeleterInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    matiereId?: NullableStringFieldUpdateOperationsInput | string | null
    telchargePar?: StringFieldUpdateOperationsInput | string
    correctionId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: CommentaireUncheckedUpdateManyWithoutDocumentNestedInput
    documentPFE?: DocumentPFEUncheckedUpdateOneWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUncheckedUpdateManyWithoutDocumentNestedInput
    correction?: DocumentUncheckedUpdateOneWithoutCorrectionPourNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutDeletedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    matiereId?: NullableStringFieldUpdateOperationsInput | string | null
    telchargePar?: StringFieldUpdateOperationsInput | string
    correctionId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentaireUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutCommentairesNestedInput
    parent?: CommentaireUpdateOneWithoutRepliesNestedInput
    replies?: CommentaireUpdateManyWithoutParentNestedInput
  }

  export type CommentaireUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentaireUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentaireUncheckedUpdateManyWithoutCommentairesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfesseurMatiereUpdateWithoutProfesseurInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProfesseurRoleFieldUpdateOperationsInput | ProfesseurRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneRequiredWithoutProfesseurMatieresNestedInput
  }

  export type ProfesseurMatiereUncheckedUpdateWithoutProfesseurInput = {
    id?: StringFieldUpdateOperationsInput | string
    matiereId?: StringFieldUpdateOperationsInput | string
    role?: EnumProfesseurRoleFieldUpdateOperationsInput | ProfesseurRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfesseurMatiereUncheckedUpdateManyWithoutProfesseurMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    matiereId?: StringFieldUpdateOperationsInput | string
    role?: EnumProfesseurRoleFieldUpdateOperationsInput | ProfesseurRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumAuditActionFieldUpdateOperationsInput | AuditAction
    resource?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiliereCreateManyNiveauInput = {
    id?: string
    nom: string
    code: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SemestreCreateManyNiveauInput = {
    id?: string
    nom: string
    ordre: number
  }

  export type UserCreateManyNiveauInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    filiereId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiliereUpdateWithoutNiveauInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matieres?: MatiereUpdateManyWithoutFiliereNestedInput
    users?: UserUpdateManyWithoutFiliereNestedInput
  }

  export type FiliereUncheckedUpdateWithoutNiveauInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matieres?: MatiereUncheckedUpdateManyWithoutFiliereNestedInput
    users?: UserUncheckedUpdateManyWithoutFiliereNestedInput
  }

  export type FiliereUncheckedUpdateManyWithoutFilieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SemestreUpdateWithoutNiveauInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    matieres?: MatiereUpdateManyWithoutSemestreNestedInput
  }

  export type SemestreUncheckedUpdateWithoutNiveauInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
    matieres?: MatiereUncheckedUpdateManyWithoutSemestreNestedInput
  }

  export type SemestreUncheckedUpdateManyWithoutSemestresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    ordre?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpdateWithoutNiveauInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filiere?: FiliereUpdateOneWithoutUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUpdateManyWithoutDeleterNestedInput
    commentaires?: CommentaireUpdateManyWithoutUserNestedInput
    professeurMatieres?: ProfesseurMatiereUpdateManyWithoutProfesseurNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNiveauInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    filiereId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUncheckedUpdateManyWithoutDeleterNestedInput
    commentaires?: CommentaireUncheckedUpdateManyWithoutUserNestedInput
    professeurMatieres?: ProfesseurMatiereUncheckedUpdateManyWithoutProfesseurNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    filiereId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatiereCreateManyFiliereInput = {
    id?: string
    nom: string
    code: string
    semestreId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserCreateManyFiliereInput = {
    id?: string
    email: string
    password: string
    prenom: string
    nom: string
    role: UserRole
    isActive?: boolean
    niveauId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatiereUpdateWithoutFiliereInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semestre?: SemestreUpdateOneRequiredWithoutMatieresNestedInput
    documents?: DocumentUpdateManyWithoutMatiereNestedInput
    documentMatieres?: DocumentMatiereUpdateManyWithoutMatiereNestedInput
    professeurMatieres?: ProfesseurMatiereUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateWithoutFiliereInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    semestreId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutMatiereNestedInput
    documentMatieres?: DocumentMatiereUncheckedUpdateManyWithoutMatiereNestedInput
    professeurMatieres?: ProfesseurMatiereUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateManyWithoutMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    semestreId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutFiliereInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    niveau?: NiveauUpdateOneWithoutUsersNestedInput
    documents?: DocumentUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUpdateManyWithoutDeleterNestedInput
    commentaires?: CommentaireUpdateManyWithoutUserNestedInput
    professeurMatieres?: ProfesseurMatiereUpdateManyWithoutProfesseurNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFiliereInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    niveauId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    deletedDocuments?: DocumentUncheckedUpdateManyWithoutDeleterNestedInput
    commentaires?: CommentaireUncheckedUpdateManyWithoutUserNestedInput
    professeurMatieres?: ProfesseurMatiereUncheckedUpdateManyWithoutProfesseurNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MatiereCreateManySemestreInput = {
    id?: string
    nom: string
    code: string
    filiereId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MatiereUpdateWithoutSemestreInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filiere?: FiliereUpdateOneRequiredWithoutMatieresNestedInput
    documents?: DocumentUpdateManyWithoutMatiereNestedInput
    documentMatieres?: DocumentMatiereUpdateManyWithoutMatiereNestedInput
    professeurMatieres?: ProfesseurMatiereUpdateManyWithoutMatiereNestedInput
  }

  export type MatiereUncheckedUpdateWithoutSemestreInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    filiereId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutMatiereNestedInput
    documentMatieres?: DocumentMatiereUncheckedUpdateManyWithoutMatiereNestedInput
    professeurMatieres?: ProfesseurMatiereUncheckedUpdateManyWithoutMatiereNestedInput
  }

  export type DocumentCreateManyMatiereInput = {
    id?: string
    titre: string
    description?: string | null
    cheminFichier: string
    nomFichier: string
    tailleFichier: bigint | number
    typeMime: string
    categorie: DocumentCategorie
    telchargePar: string
    correctionId?: string | null
    downloadCount?: number
    viewCount?: number
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentMatiereCreateManyMatiereInput = {
    id?: string
    documentId: string
    createdAt?: Date | string
  }

  export type ProfesseurMatiereCreateManyMatiereInput = {
    id?: string
    professeurId: string
    role: ProfesseurRole
    createdAt?: Date | string
  }

  export type DocumentUpdateWithoutMatiereInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    deleter?: UserUpdateOneWithoutDeletedDocumentsNestedInput
    commentaires?: CommentaireUpdateManyWithoutDocumentNestedInput
    documentPFE?: DocumentPFEUpdateOneWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUpdateManyWithoutDocumentNestedInput
    correctionPour?: DocumentUpdateOneWithoutCorrectionNestedInput
    correction?: DocumentUpdateOneWithoutCorrectionPourNestedInput
  }

  export type DocumentUncheckedUpdateWithoutMatiereInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cheminFichier?: StringFieldUpdateOperationsInput | string
    nomFichier?: StringFieldUpdateOperationsInput | string
    tailleFichier?: BigIntFieldUpdateOperationsInput | bigint | number
    typeMime?: StringFieldUpdateOperationsInput | string
    categorie?: EnumDocumentCategorieFieldUpdateOperationsInput | DocumentCategorie
    telchargePar?: StringFieldUpdateOperationsInput | string
    correctionId?: NullableStringFieldUpdateOperationsInput | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    viewCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentaires?: CommentaireUncheckedUpdateManyWithoutDocumentNestedInput
    documentPFE?: DocumentPFEUncheckedUpdateOneWithoutDocumentNestedInput
    documentMatieres?: DocumentMatiereUncheckedUpdateManyWithoutDocumentNestedInput
    correction?: DocumentUncheckedUpdateOneWithoutCorrectionPourNestedInput
  }

  export type DocumentMatiereUpdateWithoutMatiereInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutDocumentMatieresNestedInput
  }

  export type DocumentMatiereUncheckedUpdateWithoutMatiereInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentMatiereUncheckedUpdateManyWithoutDocumentMatieresInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfesseurMatiereUpdateWithoutMatiereInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProfesseurRoleFieldUpdateOperationsInput | ProfesseurRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    professeur?: UserUpdateOneRequiredWithoutProfesseurMatieresNestedInput
  }

  export type ProfesseurMatiereUncheckedUpdateWithoutMatiereInput = {
    id?: StringFieldUpdateOperationsInput | string
    professeurId?: StringFieldUpdateOperationsInput | string
    role?: EnumProfesseurRoleFieldUpdateOperationsInput | ProfesseurRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentaireCreateManyDocumentInput = {
    id?: string
    contenu: string
    userId: string
    parentId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentMatiereCreateManyDocumentInput = {
    id?: string
    matiereId: string
    createdAt?: Date | string
  }

  export type CommentaireUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentairesNestedInput
    parent?: CommentaireUpdateOneWithoutRepliesNestedInput
    replies?: CommentaireUpdateManyWithoutParentNestedInput
  }

  export type CommentaireUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentaireUncheckedUpdateManyWithoutParentNestedInput
  }

  export type DocumentMatiereUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matiere?: MatiereUpdateOneRequiredWithoutDocumentMatieresNestedInput
  }

  export type DocumentMatiereUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    matiereId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentaireCreateManyParentInput = {
    id?: string
    contenu: string
    documentId: string
    userId: string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    isEdited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentaireUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutCommentairesNestedInput
    user?: UserUpdateOneRequiredWithoutCommentairesNestedInput
    replies?: CommentaireUpdateManyWithoutParentNestedInput
  }

  export type CommentaireUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentaireUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentaireUncheckedUpdateManyWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contenu?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isEdited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}